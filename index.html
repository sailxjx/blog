
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>novolander</title>
	<meta name="author" content="tristan">

	
	<meta name="description" content="在基于事件的异步模型大行其道的今天，各语言都相继推出了自己的异步框架，nodejs原生的异步模型当然是其中的翘楚，然后python有Twisted，ruby有EventMachine(名字俗了点)。php也有一个不错的异步框架，react。下面我们从内而外的看看这个异步模型是怎么实现的。 &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/blog/atom.xml" rel="alternate" title="novolander" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/blog/favicon.ico" rel="shortcut icon">
	<link href="/blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/blog/">novolander</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/blog/">Blog</a></li>
	<li><a href="/blog/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/blog/">Blog</a></li>
	<li><a href="/blog/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:sailxjx.github.com/blog">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		<a class="google" href="https://plus.google.com/sailxjx?rel=author" title="Google+">Google+</a>
		
		
		
		<a class="github" href="https://github.com/sailxjx" title="GitHub">GitHub</a>
		
		
		
		
		
		<a class="rss" href="/blog/atom.xml" title="RSS">RSS</a>
		
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:sailxjx.github.com/blog">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h1 class="title"><a href="/blog/blog/2013/03/05/react-dot-php-zhong-de-yi-bu-shi-xian/">react.php 中的异步实现</a></h1>
	<div class="entry-content">
		<p>在基于事件的异步模型大行其道的今天，各语言都相继推出了自己的异步框架，nodejs原生的异步模型当然是其中的翘楚，然后python有Twisted，ruby有EventMachine(名字俗了点)。php也有一个不错的异步框架，<a href="https://github.com/reactphp/react">react</a>。下面我们从内而外的看看这个异步模型是怎么实现的。</p>

<h3>événement</h3>

<p>首先react的事件模型是建立在一个叫<a href="https://github.com/igorw/evenement">événement</a>的框架上，也是react作者所作，代码只有短短的74行，实现了<code>on</code>(事件监听),<code>emit</code>(触发事件)等方法。下面就单就这两个事件方法分析一下。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="k">public</span> <span class="k">function</span> <span class="nf">on</span><span class="p">(</span><span class="nv">$event</span><span class="p">,</span> <span class="nv">$listener</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">is_callable</span><span class="p">(</span><span class="nv">$listener</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nx">\InvalidArgumentException</span><span class="p">(</span><span class="s1">&#39;The provided listener was not a valid callable.&#39;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">listeners</span><span class="p">[</span><span class="nv">$event</span><span class="p">]))</span> <span class="p">{</span>
</span><span class='line'>            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">listeners</span><span class="p">[</span><span class="nv">$event</span><span class="p">]</span> <span class="o">=</span> <span class="k">array</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">listeners</span><span class="p">[</span><span class="nv">$event</span><span class="p">][]</span> <span class="o">=</span> <span class="nv">$listener</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="k">public</span> <span class="k">function</span> <span class="nf">emit</span><span class="p">(</span><span class="nv">$event</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$arguments</span> <span class="o">=</span> <span class="k">array</span><span class="p">())</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">foreach</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">listeners</span><span class="p">(</span><span class="nv">$event</span><span class="p">)</span> <span class="k">as</span> <span class="nv">$listener</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="nb">call_user_func_array</span><span class="p">(</span><span class="nv">$listener</span><span class="p">,</span> <span class="nv">$arguments</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="cp">?&gt;</span><span class="x"></span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的<code>$event</code>其实就是一个事件标识，一般是一个字符串，<code>$listener</code>是一个回调方法。调用<code>on</code>时用数组listeners记录所有回调方法，调用<code>emit</code>时再按次序触发，由此还衍生了<code>once</code>(只触发一次就解除绑定的事件)，<code>removeListener</code>(移除事件)等方法。</p>

<h3>EventLoop</h3>

<p>更进一步，react事件模型的上一层是一个监听循环，叫做<code>EventLoop</code>，有了这个，就往消息队列或webserver的异步处理模型更近了一步。</p>

<p>下面可以看一下<code>EventLoop</code>的接口文件<code>LoopInterface.php</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="k">namespace</span> <span class="nx">React\EventLoop</span><span class="p">;</span>
</span><span class='line'><span class="k">interface</span> <span class="nx">LoopInterface</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">addReadStream</span><span class="p">(</span><span class="nv">$stream</span><span class="p">,</span> <span class="nv">$listener</span><span class="p">);</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">addWriteStream</span><span class="p">(</span><span class="nv">$stream</span><span class="p">,</span> <span class="nv">$listener</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">removeReadStream</span><span class="p">(</span><span class="nv">$stream</span><span class="p">);</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">removeWriteStream</span><span class="p">(</span><span class="nv">$stream</span><span class="p">);</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">removeStream</span><span class="p">(</span><span class="nv">$stream</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">addTimer</span><span class="p">(</span><span class="nv">$interval</span><span class="p">,</span> <span class="nv">$callback</span><span class="p">);</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">addPeriodicTimer</span><span class="p">(</span><span class="nv">$interval</span><span class="p">,</span> <span class="nv">$callback</span><span class="p">);</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">cancelTimer</span><span class="p">(</span><span class="nv">$signature</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">tick</span><span class="p">();</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">run</span><span class="p">();</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">stop</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cp">?&gt;</span><span class="x"></span>
</span></code></pre></td></tr></table></div></figure>


<p><code>react</code>支持php的社区库<code>libevent</code>提供的事件支持，同时有个<code>LibEventLoop.php</code>用来实现<code>LoopInterface</code>接口，但是<code>react</code>也有自己的实现方案<code>StreamSelectLoop</code>，与<code>LibEventLoop</code>不兼容，这点可以在<code>EventLoop\LibEventLoop\Factory</code>中看到。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">create</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// @codeCoverageIgnoreStart</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nb">function_exists</span><span class="p">(</span><span class="s1">&#39;event_base_new&#39;</span><span class="p">))</span> <span class="p">{</span> <span class="c1">//使用libevent</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="nx">LibEventLoop</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="nx">StreamSelectLoop</span><span class="p">();</span> <span class="c1">//不使用libevent</span>
</span><span class='line'>        <span class="c1">// @codeCoverageIgnoreEnd</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="cp">?&gt;</span><span class="x"></span>
</span></code></pre></td></tr></table></div></figure>


<p>我们主要来看看<code>StreamSelectLoop</code>的实现。<code>LoopInterface</code>中几个重要的方法<code>addReadStream</code>, <code>addWriteStream</code>, <code>addTimer</code>, <code>tick</code>都可以在<code>StreamSelectLoop</code>找到踪影。下面先说一下<code>addReadStream</code>中的两个参数：</p>

<p><em><code>$stream</code>是一个由<code>stream_socket_server</code>方法生成的socket句柄，支持tcp或文件socket等方式。
</em><code>$listener</code>其实就是一个callback方法，在这个方法中就需要实现具体的应用逻辑了。</p>

<p><code>addWriteStream</code>与<code>addReadStream</code>方法差不多，这两个方法其实啥都没做，只是注册一下两个方法，以供后面调用。真正起作用的方法是<code>tick</code>和<code>runStreamSelect</code>。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'>    <span class="k">protected</span> <span class="k">function</span> <span class="nf">runStreamSelect</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nv">$read</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">readStreams</span> <span class="o">?:</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>        <span class="nv">$write</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">writeStreams</span> <span class="o">?:</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>        <span class="nv">$except</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$read</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nv">$write</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">sleepOnPendingTimers</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">return</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nb">stream_select</span><span class="p">(</span><span class="nv">$read</span><span class="p">,</span> <span class="nv">$write</span><span class="p">,</span> <span class="nv">$except</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getNextEventTimeInMicroSeconds</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="nv">$read</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">foreach</span> <span class="p">(</span><span class="nv">$read</span> <span class="k">as</span> <span class="nv">$stream</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="nv">$listener</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">readListeners</span><span class="p">[(</span><span class="nx">int</span><span class="p">)</span> <span class="nv">$stream</span><span class="p">];</span>
</span><span class='line'>                    <span class="k">if</span> <span class="p">(</span><span class="nb">call_user_func</span><span class="p">(</span><span class="nv">$listener</span><span class="p">,</span> <span class="nv">$stream</span><span class="p">,</span> <span class="nv">$this</span><span class="p">)</span> <span class="o">===</span> <span class="k">false</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">removeReadStream</span><span class="p">(</span><span class="nv">$stream</span><span class="p">);</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="nv">$write</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">foreach</span> <span class="p">(</span><span class="nv">$write</span> <span class="k">as</span> <span class="nv">$stream</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">writeListeners</span><span class="p">[(</span><span class="nx">int</span><span class="p">)</span> <span class="nv">$stream</span><span class="p">]))</span> <span class="p">{</span>
</span><span class='line'>                        <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>                    <span class="nv">$listener</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">writeListeners</span><span class="p">[(</span><span class="nx">int</span><span class="p">)</span> <span class="nv">$stream</span><span class="p">];</span>
</span><span class='line'>                    <span class="k">if</span> <span class="p">(</span><span class="nb">call_user_func</span><span class="p">(</span><span class="nv">$listener</span><span class="p">,</span> <span class="nv">$stream</span><span class="p">,</span> <span class="nv">$this</span><span class="p">)</span> <span class="o">===</span> <span class="k">false</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">removeWriteStream</span><span class="p">(</span><span class="nv">$stream</span><span class="p">);</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="cp">?&gt;</span><span class="x"></span>
</span></code></pre></td></tr></table></div></figure>


<p><code>runStreamSelect</code>方法在<code>tick</code>方法中被调用，目的是在每个间隔中重复调用之前绑定的<code>$listener</code>方法，这个可以理解，因为本来<code>EventLoop</code>的目的就是实现事件的监听，监听的最简单方法就是通过轮询的方式来调用，假如某些方法不希望被重复调用或者希望在某次成功之后就不再调用，那么在定义<code>$listener</code>方法时，将返回值设置成false即可。至于这个间隔，则是通过<code>Timer</code>来实现的。</p>

<p>在<code>runStreamSelect</code>中调用了一个有意思的方法<a href="http://php.net/manual/en/function.stream-select.php"><code>stream_select</code></a>，用timeout取代传统的<code>sleep</code>，并兼具监听socket端口的功能，一旦有新的连接或者改动，<code>stream_select</code>会立刻返回read或write中被修改的socket连接总数。这样，既能合理的释放cpu资源，又能及时对事件发起响应。比起传统的<code>while+sleep</code>，实在是高明很多。</p>

<h3>Timer</h3>

<p>说到<code>tick</code>就不得不提<code>Timer</code>，<code>react</code>中用一个<code>Timer</code>类来模拟步进操作。每隔一定的ticket会唤起一个事件，这样才能保证异步操作能正确的被调用，这个ticket的数量有讲究，设置的太小会让系统耗用大量资源，设置的太大又不能保证异步事件能及时的被调用。下面我们来看看<code>Timer</code>中的tick。</p>

<p><code>Timer</code>中使用一个队列来记录所有将触发的事件，并且将它们按照优先级(也就是触发事件)排序，最后每次调用优先级最高的事件。</p>

<p><code>react</code>中使用<code>SplPriorityQueue</code>类来做优先级队列，这是php5.3后新增的一个标准库类，其功能很简单，就是实现一个按照rank排序的队列，有点类似redis中的zset，但是其值是可以重复的，所以它不是一个集合。它实现了<code>insert</code>, <code>count</code>, <code>count</code>, <code>extract</code>等方法，通过<code>insert</code>往队列中插入的数据会自动按照优先级(priority)由大到小排序(<code>react</code>中根据interval时间取负，实现了由小到大排序)，免去了sort的麻烦，然后可以通过<code>extract</code>方法得到队列顶部优先级(priority)最高的数据。</p>

<p>有了Timer，用户就可以给<code>react</code>设置延迟事件，可以参考js中的<code>setTimeout</code>方法。</p>

<p>最后，<code>react</code>通过<code>EventLoop</code>中的<code>run</code>方法将tick放入一个while循环，实现了监听的目的。</p>

<p>总结一下，<code>react</code>的异步事件模型：</p>

<p>核心的on-emit事件模型 &#8211;> EventLoop实现响应socket事件 &#8211;> Timer实现事件优先级排序 &#8211;> while循环来pending服务端的程序。</p>

<p><code>react</code>还提供了很多的示例文件，一个简单的http-server可以实现如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="k">require</span> <span class="nx">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../vendor/autoload.php&#39;</span><span class="p">;</span>
</span><span class='line'><span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="nv">$app</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$response</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="o">&amp;</span><span class="nv">$i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nv">$i</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="nv">$text</span> <span class="o">=</span> <span class="s2">&quot;This is request number </span><span class="si">$i</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="nv">$headers</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nv">$headers</span><span class="p">);</span>
</span><span class='line'>    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">end</span><span class="p">(</span><span class="nv">$text</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="nv">$loop</span> <span class="o">=</span> <span class="nx">React\EventLoop\Factory</span><span class="o">::</span><span class="na">create</span><span class="p">();</span>
</span><span class='line'><span class="nv">$socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">React\Socket\Server</span><span class="p">(</span><span class="nv">$loop</span><span class="p">);</span>
</span><span class='line'><span class="nv">$http</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">React\Http\Server</span><span class="p">(</span><span class="nv">$socket</span><span class="p">);</span>
</span><span class='line'><span class="nv">$http</span><span class="o">-&gt;</span><span class="na">on</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">,</span> <span class="nv">$app</span><span class="p">);</span>
</span><span class='line'><span class="nv">$socket</span><span class="o">-&gt;</span><span class="na">listen</span><span class="p">(</span><span class="mi">1337</span><span class="p">);</span>
</span><span class='line'><span class="nv">$loop</span><span class="o">-&gt;</span><span class="na">run</span><span class="p">();</span>
</span><span class='line'><span class="cp">?&gt;</span><span class="x"></span>
</span></code></pre></td></tr></table></div></figure>


<h2>后记</h2>

<p><code>react</code>中用到了很多php5.3之后才出现的新特性(EventEmitter2甚至只支持5.4以上的php版本)，很多方法以前也没有接触过，可以说相比于国内对php的应用，老外对语言的研究更加透彻。想起国内这么普及的php应用，很多人只是略知皮毛，就喜欢大言不惭，甚至能人云亦云的挑出一堆语言的弊端。老外的钻研精神确实值得学习。</p>

<p>记录一下几个可能有用但是不常用的类或方法：</p>

<ul>
<li><a href="http://php.net/manual/en/function.stream-socket-server.php"><code>stream_socket_server</code></a> 创建一个服务端套接字。</li>
<li><a href="http://php.net/manual/en/function.stream-select.php"><code>stream_select</code></a> 监听读写socket状态的变化，带timeout时间</li>
<li><a href="http://www.php.net/manual/en/splpriorityqueue.insert.php"><code>SplPriorityQueue</code></a> 创建一个带优先级的有序队列</li>
</ul>


<h2>参考文档</h2>

<p><a href="http://www.mwop.net/blog/253-Taming-SplPriorityQueue.html">Taming SplPriorityQueue</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-03-05T15:29:00+08:00" pubdate data-updated="true">2013.03.05</time></div>
	<div class="tags">


	<a class='category' href='/blog/blog/categories/php/'>php</a>, <a class='category' href='/blog/blog/categories/react/'>react</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/blog/blog/2013/03/04/php-de-namespace/">Php的命名空间</a></h1>
	<div class="entry-content">
		<p>php中命名空间的概念出现的比较晚(>=5.3)，这也造成了很多人写php程序的时候忽略了这个问题(包括我:)，不过，最近很多老外的开源项目中渐渐流行起在php中使用命名空间。于是我也跟风一把，看看究竟好在哪儿。</p>

<p>在php namespace语句出现之前，通行的做法是根据文件路径定义类名，某些特殊文件再加上后缀，比如存放controller的文件夹中有两个文件，分别存放在<code>controller/Base.php</code>和<code>controller/login/Base.php</code>，根据命名可以看出这是两个基类文件，文件名是一样的，它们的类名一般会写成<code>BaseController</code>和<code>Login_BaseController</code>(首字母大写也是一种约定)，这样就不存在类名冲突的问题了。这样做的一个缺点是类名会很长，用某些人的说法，就是不够优雅，于是命名空间就应运而生了。</p>

<p>命名空间的使用在别的语言中的使用历史不算短，其中微软系的c#由盛。在php中基本是照搬这种思想，下面先举个简单的栗子：</p>

<figure class='code'><figcaption><span>myname1.php  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="k">namespace</span> <span class="nx">my\name1</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{}</span> <span class="c1">//定义类</span>
</span><span class='line'><span class="k">function</span> <span class="nf">myfunction</span><span class="p">()</span> <span class="p">{</span><span class="k">echo</span> <span class="s2">&quot;helloworld&quot;</span><span class="p">;}</span> <span class="c1">//定义方法</span>
</span><span class='line'><span class="k">const</span> <span class="no">MYCONST</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//定义常量</span>
</span></code></pre></td></tr></table></div></figure>


<p>假如我们有另一个php文件myname2.php，需要include myname1.php。用下面几种方式是可以的。</p>

<p>一. 在同一namespace下</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="k">namespace</span> <span class="nx">my\name1</span><span class="p">;</span>
</span><span class='line'><span class="k">include</span> <span class="s1">&#39;myname1.php&#39;</span><span class="p">;</span>
</span><span class='line'><span class="nb">print_r</span><span class="p">(</span><span class="k">new</span> <span class="nx">MyClass</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>从输出结果可以看出实例名已经变成了<code>my\name1\MyClass Object</code>，命名空间会自动的加到类名前面。</p>

<p>二. 在不同namespace下用<code>use</code></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="x">namespace my\name2; //不同的命名空间</span>
</span><span class='line'><span class="x">include &#39;myname1.php&#39;;</span>
</span><span class='line'><span class="x">use my\name1; //使用命名空间</span>
</span><span class='line'><span class="x">print_r(\my\name1\MYCONST); //这里用调用常量举例</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，在使用namespace前需要以<code>\</code>开头，否则会自动加到当前的namespace后面，变成<code>my\name2\my\name1\MYCONST</code>，也就得不到正确的结果了。这个有点类似url或*nux系统中用<code>/</code>来表示PATH的根目录。</p>

<p>三. 在不同namespace下用<code>use .. as ..</code></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="x">namespace my\name2;</span>
</span><span class='line'><span class="x">include &#39;myname1.php&#39;;</span>
</span><span class='line'><span class="x">use my\name1 as m1; //使用命名空间别名</span>
</span><span class='line'><span class="x">m1\myfunction(); //调用方法举例</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就是命名空间的真正益处了，短啊~不过别名前就不能用<code>\</code>符号了，否则会把<code>m1</code>当做已存在的命名空间来处理。</p>

<h3>P.S.</h3>

<ul>
<li>php5.3之后还有一个全局常量<code>__NAMESPACE__</code>来表明当前文件所在的命名空间，至于用处？谁知道呢。</li>
<li>在同一个文件中是可以使用多个namespace的。</li>
<li>假如在命名空间中定义了与全局方法同名的方法，可以使用在前面加<code>\</code>符号的方式调用全局方法，例如在<code>fopen</code>中用<code>\fopen()</code>。而不使用命名空间的时候，重复定义是不允许的。遇到重定义常量也是一样。</li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-03-04T11:38:00+08:00" pubdate data-updated="true">2013.03.04</time></div>
	<div class="tags">


	<a class='category' href='/blog/blog/categories/php/'>php</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/blog/blog/2013/02/18/virtualbox-hates-sendfile/">Virtualbox Hates Sendfile</a></h1>
	<div class="entry-content">
		<p>事情的起因是这个样子滴~</p>

<p>代码文件都放在mac中，运行环境在virtualbox中，通过mount主机的文件夹来工作，相信很多同学都搭建过这样的环境，一切相安无事，直到某一天。。。</p>

<p>修改过的静态文件不生效了！</p>

<p>本来以为是nginx中缓存设置的问题，使尽各种解数，包括把expires设置为off，header中加Expire为0，给文件加时间戳，依然如此。果断google之，原来是virtualbox使用的特殊文件系统造成的。</p>

<p>apache和nginx中都有个默认开启的选项sendfile，表示通过内核文件指针来读取或复制文件，在vboxsf(virtualbox共享文件所使用的文件系统)中，sendfile会造成文件无法更新。于是我们无论怎么刷新，都只能看到第一次访问得到的文件了。</p>

<p>解决办法也很简单，将nginx.conf中设置<code>sendfile off</code>就可以了。</p>

<p>由于这个问题折腾了我很久，特此记录一下，同时借用某同样遇到此问题的<a href="http://abitwiser.wordpress.com/2011/02/24/virtualbox-hates-sendfile/">blog标题</a>。</p>

<h2>后记</h2>

<p>1.<a href="https://forums.virtualbox.org/viewtopic.php?f=1&amp;t=24905">virtualbox论坛</a>2009年的时候就有人讨论过这个问题，那时候的版本还是3.0，现在都4.2了，问题仍然没有得到解决，唉~被oracle X过的软件果然不行啊~。</p>

<p>2.在主机中修改文件，虚拟机中的inode不会变化，反过来也一样，不知道是不是因为vboxsf的问题，然而使用samba共享的文件系统中两边的inode是同时变化的。</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://abitwiser.wordpress.com/2011/02/24/virtualbox-hates-sendfile/">VirtualBox Hates Sendfile</a></li>
<li><a href="http://serverfault.com/questions/269420/disable-caching-when-serving-static-files-with-nginx-for-development">serverfault</a></li>
<li><a href="https://forums.virtualbox.org/viewtopic.php?f=1&amp;t=24905">virtualbox forum</a></li>
<li><a href="http://wiki.nginx.org/HttpCoreModule#sendfile">nginx wiki</a></li>
<li><a href="http://comments.gmane.org/gmane.linux.kernel.cifs/3517">mac中samba共享的问题</a></li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-02-18T16:39:00+08:00" pubdate data-updated="true">2013.02.18</time></div>
	<div class="tags">


	<a class='category' href='/blog/blog/categories/linux/'>linux</a>, <a class='category' href='/blog/blog/categories/nginx/'>nginx</a>, <a class='category' href='/blog/blog/categories/virtualbox/'>virtualbox</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/blog/blog/2013/02/06/cypher-query-language-xue-xi-bi-ji-2/">Cypher Query Language 学习笔记(2)</a></h1>
	<div class="entry-content">
		<h3>create unique</h3>

<p>顾名思义，<code>create unique</code>与<code>create</code>在功能上是类似的，不过当新建的node或relationship已经存在时，<code>create unique</code>不会再生成一个新的node或relationship。</p>

<p>另一个区别是<code>create unique</code>只能在一个<code>path</code>表达式中使用，例如下面的代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">bran</span> <span class="o">=</span> node<span class="o">(</span>6<span class="o">)</span> create unique bran-<span class="o">[</span>r:littlebrotherof<span class="o">]</span>-&gt;<span class="o">(</span>n<span class="o">{</span>name:<span class="s2">&quot;jon&quot;</span><span class="o">})</span> <span class="k">return </span>n;
</span><span class='line'>+----------------------------+
</span><span class='line'>| n                          |
</span><span class='line'>+----------------------------+
</span><span class='line'>| Node<span class="o">[</span>7<span class="o">]{</span>name:<span class="s2">&quot;jon&quot;</span>,age:17<span class="o">}</span> |
</span><span class='line'>+----------------------------+
</span><span class='line'>1 row
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中，path中name=&#8221;jon&#8221;的node已经存在，neo4j认为这是一个<code>unique node</code>，所以不会再新建一个node，稍加修改，将age属性调整一下，就可以新建一个不同的node。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">bran</span> <span class="o">=</span> node<span class="o">(</span>6<span class="o">)</span> create unique bran-<span class="o">[</span>r:littlebrotherof<span class="o">]</span>-&gt;<span class="o">(</span>n<span class="o">{</span>name:<span class="s2">&quot;jon&quot;</span>,age:18<span class="o">})</span> <span class="k">return </span>n;
</span><span class='line'>+----------------------------+
</span><span class='line'>| n                          |
</span><span class='line'>+----------------------------+
</span><span class='line'>| Node<span class="o">[</span>8<span class="o">]{</span>name:<span class="s2">&quot;jon&quot;</span>,age:18<span class="o">}</span> |
</span><span class='line'>+----------------------------+
</span><span class='line'>1 row
</span><span class='line'>Nodes created: 1
</span><span class='line'>Relationships created: 1
</span><span class='line'>Properties <span class="nb">set</span>: 2
</span></code></pre></td></tr></table></div></figure>


<p>新建relationship的方式和上面差不多，举一反三即可。</p>

<h3>foreach</h3>

<p>foreach针对的neo4j中的集合做遍历，可以做一些批量的修改操作。其语法块需要用括号围起来，像下面的代码，更新path p关联的所有node的uptime属性为100。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">bran</span> <span class="o">=</span> node<span class="o">(</span>6<span class="o">)</span> match <span class="nv">p</span> <span class="o">=</span> bran-<span class="o">[]</span>-&gt;<span class="o">()</span> foreach <span class="o">(</span>n in nodes<span class="o">(</span>p<span class="o">)</span>: <span class="nb">set </span>n.uptime <span class="o">=</span> 100<span class="o">)</span>;
</span><span class='line'>+-------------------+
</span><span class='line'>| No data returned. |
</span><span class='line'>+-------------------+
</span><span class='line'>Properties <span class="nb">set</span>: 4
</span></code></pre></td></tr></table></div></figure>


<p>至于什么是neo4j中的集合，比如<code>nodes()</code>方法得到的结果就是一个集合，用集合表达式表示的也是一个集合，但是<code>n = node(*)</code>中匹配出来的n并不是一个集合。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">bran</span> <span class="o">=</span> node<span class="o">(</span>6<span class="o">)</span>, <span class="nv">jon</span> <span class="o">=</span> node<span class="o">(</span>7<span class="o">)</span> foreach <span class="o">(</span>n in <span class="o">[</span>bran, jon<span class="o">]</span>: <span class="nb">set </span>n.uptime <span class="o">=</span> 101<span class="o">)</span>;
</span><span class='line'>+-------------------+
</span><span class='line'>| No data returned. |
</span><span class='line'>+-------------------+
</span><span class='line'>Properties <span class="nb">set</span>: 2
</span></code></pre></td></tr></table></div></figure>


<h3>functions</h3>

<p><a href="http://docs.neo4j.org/chunked/milestone/query-function.html">官方手册</a>中罗列了所有的可用方法，非常详尽，需要慢慢研究了。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-02-06T14:32:00+08:00" pubdate data-updated="true">2013.02.06</time></div>
	<div class="tags">


	<a class='category' href='/blog/blog/categories/cypher/'>cypher</a>, <a class='category' href='/blog/blog/categories/learn/'>learn</a>, <a class='category' href='/blog/blog/categories/neo4j/'>neo4j</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/blog/blog/2013/02/06/vagrant-da-bao-yu-fa-bu/">Vagrant 打包与发布</a></h1>
	<div class="entry-content">
		<p>上次失败的<a href="/blog/blog/2012/12/11/vagrant-bi-ji/">vagrant尝试</a>之后，很久没有再去捣鼓这玩意儿，最近又想试一试，居然一举成功了，特别记录一下。</p>

<h2>打包</h2>

<p>上手第一件事就是制作自己的box，网上已经有了许多现成的<a href="http://www.vagrantbox.es/">各linux版本box</a></p>

<p>首先用virtualbox安装好自己的linux，版本任选，我这里用的是ubuntu server 12.10，虚拟机名是<code>ubuntu_server_12.10</code>，装好后在其中添加<code>vagrant</code>账号。再用下面的命令就可以生成自己的box了。</p>

<blockquote><p>vagrant package &#8211;base ubuntu_server_12.10 &#8211;output vagrant_ubuntu.box</p></blockquote>

<p>这样就在当前目录下生成了一个vagrant_ubuntu.box文件，压缩前原始vdi文件在1.4G左右，打包后的box是415M，压缩比还是不错的。</p>

<h2>导入</h2>

<p>下面就是导入box文件了。</p>

<blockquote><p>vagrant box add vagrant_ubuntu vagrant_ubuntu.box</p></blockquote>

<p>vagrant的磁盘文件储存在<code>~/.vagrant.d/</code>文件夹中。导入之后用下面的命令生成一个&#8217;Vagrantfile&#8217;配置文件</p>

<blockquote><p>vagrant init</p></blockquote>

<p>然后就可以通过<code>up</code>命令启动虚拟机了</p>

<blockquote><p>vagrant up</p></blockquote>

<h2>ssh</h2>

<p>如果不做任何修改，虚拟机默认使用的是NAT的连接方式，而且做了一个端口转发(22->2222)，这个时候直接通过<code>vagrant ssh</code>命令或22端口是登陆不了虚拟机的，需要在Vagrantfile中添加下面两项</p>

<blockquote><p>config.ssh.port = 2222</p>

<p>config.ssh.private_key_path = &#8220;/Users/tristan/.ssh/id_rsa&#8221;</p></blockquote>

<p>其中第一项指定使用本机的2222作为ssh端口，其中第二项是指定使用的私钥路径，如果事先在虚拟机中加入了对应的公钥，这样连接时就可以免去输入密码的步骤。(还要注意的是网上大部分box都是使用vagrant用户名，密码也是vagrant，算是一个便于传播的约定)。现在可以看一下ssh配置。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>tristan@bran:vagrant<span class="nv">$ </span>vagrant ssh-config
</span><span class='line'>Host default
</span><span class='line'>  HostName 127.0.0.1
</span><span class='line'>  User vagrant
</span><span class='line'>  Port 2222
</span><span class='line'>  UserKnownHostsFile /dev/null
</span><span class='line'>  StrictHostKeyChecking no
</span><span class='line'>  PasswordAuthentication no
</span><span class='line'>  IdentityFile /Users/tristan/.ssh/id_rsa
</span><span class='line'>  IdentitiesOnly yes
</span></code></pre></td></tr></table></div></figure>


<p>然后使用下面的命令，就可以直接登录虚拟机了。</p>

<blockquote><p>vagrant ssh</p></blockquote>

<p>包括下面的一系列命令，也均可以使用。</p>

<ul>
<li><code>vagrant up</code> 启动</li>
<li><code>vagrant halt</code> 关机</li>
<li><code>vagrant reload</code> 重启</li>
<li><code>vagrant suspend</code> 休眠</li>
</ul>


<p>总而言之，搞定ssh，一切就很顺利鸟。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-02-06T14:31:00+08:00" pubdate data-updated="true">2013.02.06</time></div>
	<div class="tags">


	<a class='category' href='/blog/blog/categories/vagrant/'>vagrant</a>, <a class='category' href='/blog/blog/categories/virtualbox/'>virtualbox</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/blog/blog/2013/02/01/cypher-query-language-xue-xi-bi-ji-1/">Cypher Query Language 学习笔记(1)</a></h1>
	<div class="entry-content">
		<p>紧接前文<a href="http://sailxjx.github.com/blog/blog/2013/01/23/chu-shi-tu-xing-shu-ju-ku-neo4j/">初试图形数据库 neo4j</a>初窥了这种语言的特性，几天使用下来，初期不适应的便秘感慢慢退去，渐入佳境，竟然觉得有些妙不可言鸟。就如同nodejs基于事件的特点和函数式语法对传统编程方法的改变，学习<code>Cypher</code>同样需要改改传统<code>Sql</code>的思路，下面记录一下最近的新发现。</p>

<h3>版本号</h3>

<p><code>dbinfo</code>可以用于查询一些与数据库状态相关的信息，查看版本号是其中一个应用。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>dbinfo -g Kernel
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="s2">&quot;KernelStartTime&quot;</span>: <span class="s2">&quot;Mon Feb 04 14:45:48 CST 2013&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;KernelVersion&quot;</span>: <span class="s2">&quot;Neo4j - Graph Database Kernel 1.9.M04&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;MBeanQuery&quot;</span>: <span class="s2">&quot;org.neo4j:instance=kernel#0,name=*&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;ReadOnly&quot;</span>: <span class="nb">false</span>,
</span><span class='line'>  <span class="s2">&quot;StoreCreationDate&quot;</span>: <span class="s2">&quot;Thu Jan 31 16:42:31 CST 2013&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;StoreDirectory&quot;</span>: <span class="s2">&quot;/usr/local/neo4j/data/graph.db&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;StoreId&quot;</span>: <span class="s2">&quot;b9dcdac5ae2b9e82&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;StoreLogVersion&quot;</span>: 1
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>match</h3>

<p>说起这<code>match</code>真是个很神奇的东西，可以用<code>sql</code>中的<code>where</code>作类比，但是又不同于<code>where</code>，因为<code>Cypher</code>中有专门的<code>where</code>。</p>

<p>这个<code>match</code>可以比作正则中的捕获组，还兼具了赋值的功能，如下面的例子</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">bran</span> <span class="o">=</span> node<span class="o">(</span>13<span class="o">)</span> match bran-<span class="o">[</span>r<span class="o">]</span>-&gt;b <span class="k">return </span>r, b;
</span><span class='line'>+--------------------------------------------------------------------------+
</span><span class='line'>| r                                         | b                            |
</span><span class='line'>+--------------------------------------------------------------------------+
</span><span class='line'>| :islittlebrotherof<span class="o">[</span>2<span class="o">]</span> <span class="o">{</span>age:1359622995523<span class="o">}</span> | Node<span class="o">[</span>14<span class="o">]{</span>name:<span class="s2">&quot;snow&quot;</span>,age:17<span class="o">}</span> |
</span><span class='line'>+--------------------------------------------------------------------------+
</span><span class='line'>1 row
</span><span class='line'>0 ms
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子中通过<code>match</code>找出了节点bran出去的所有关系r和所有终点b，这在传统的<code>sql</code>中可以比较难办到的哦。</p>

<p><code>match</code>一般需要和下面要提到的独有的模式(pattern)配合使用，比如下面这个很神奇的语句，能匹配出与节点summer和snow都有关系的中间节点，甚至你可以在中途添加一些表达式来获得沿途的关系对象。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">summer</span> <span class="o">=</span> node<span class="o">(</span>15<span class="o">)</span>, <span class="nv">snow</span> <span class="o">=</span> node<span class="o">(</span>14<span class="o">)</span> match summer-<span class="o">[</span>r<span class="o">]</span>-&gt;n&lt;--snow <span class="k">return </span>n, r;
</span><span class='line'>+--------------------------------------------------------+
</span><span class='line'>| n                            | r                       |
</span><span class='line'>+--------------------------------------------------------+
</span><span class='line'>| Node<span class="o">[</span>13<span class="o">]{</span>name:<span class="s2">&quot;bran&quot;</span>,age:10<span class="o">}</span> | :isdogof<span class="o">[</span>3<span class="o">]</span> <span class="o">{</span>ctime:100<span class="o">}</span> |
</span><span class='line'>+--------------------------------------------------------+
</span><span class='line'>1 row
</span><span class='line'>1 ms
</span></code></pre></td></tr></table></div></figure>


<p>当你不想要将匹配结果赋值时，可以使用()来代替node，用[]来代替relationship，当然，relationship不填写也是可以的。</p>

<p><code>match</code>中还有一种表示深度的方式，类似于<code>coffee</code>中的数组定义<code>[0..10]</code>来表示深度范围。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">s</span> <span class="o">=</span> node<span class="o">(</span>15<span class="o">)</span>, <span class="nv">snow</span> <span class="o">=</span> node<span class="o">(</span>14<span class="o">)</span> match <span class="nv">p</span> <span class="o">=</span> s-<span class="o">[</span>r:knowns*1..2<span class="o">]</span>-&gt;snow <span class="k">return </span>r;
</span><span class='line'>+-------------------------------+
</span><span class='line'>| r                             |
</span><span class='line'>+-------------------------------+
</span><span class='line'>| <span class="o">[</span>:knowns<span class="o">[</span>6<span class="o">]</span> <span class="o">{}</span>,:knowns<span class="o">[</span>7<span class="o">]</span> <span class="o">{}]</span> |
</span><span class='line'>+-------------------------------+
</span><span class='line'>1 row
</span><span class='line'>1 ms
</span></code></pre></td></tr></table></div></figure>


<p>官网手册中还提供了一个深度为0的例子，表示指向自己的relationship。同样如果不需要赋值或者不需要指定类型，用[*1..2]代替。</p>

<p>求最短路径在很多地方都会应用到,neo4j提供了<code>shortestpath</code>方法来提供两点间的最短路径</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">bran</span> <span class="o">=</span> node<span class="o">(</span>1<span class="o">)</span>, <span class="nv">jon</span> <span class="o">=</span> node<span class="o">(</span>2<span class="o">)</span> match <span class="nv">p</span> <span class="o">=</span> shortestpath<span class="o">(</span>bran-<span class="o">[</span>*..2<span class="o">]</span>-&gt;jon<span class="o">)</span> <span class="k">return </span>p;
</span><span class='line'>+------------------------------------------------------------------------------------------------------+
</span><span class='line'>| p                                                                                                    |
</span><span class='line'>+------------------------------------------------------------------------------------------------------+
</span><span class='line'>| <span class="o">[</span>Node<span class="o">[</span>1<span class="o">]{</span>name:<span class="s2">&quot;bran&quot;</span>,age:10<span class="o">}</span>,:islittlebrotherof<span class="o">[</span>0<span class="o">]</span> <span class="o">{</span>ctime:1359963465947<span class="o">}</span>,Node<span class="o">[</span>2<span class="o">]{</span>name:<span class="s2">&quot;jon&quot;</span>,age:17<span class="o">}]</span> |
</span><span class='line'>+------------------------------------------------------------------------------------------------------+
</span><span class='line'>1 row
</span><span class='line'>1 ms
</span></code></pre></td></tr></table></div></figure>


<p>不过假如在<code>shortestpath</code>参数中指定最短长度值的话会报错(如<code>p = shortestpath(bran-[*0..2]-&gt;jon)</code>)，不过貌似没有<code>longestpath</code>来获得最长路径，可能一是因为应用场景较少，二是在算法上也会复杂很多，略显遗憾。</p>

<h3>pattern</h3>

<p>现在再记录pattern有点本末倒置的感觉，毕竟前面的match已经用到了很多种pattern，那么这里权作总结，将常用的pattern归归类。</p>

<ul>
<li><code>a--&gt;b</code> 最简单的，由一个node到另一个node</li>
<li><code>a-[r]-&gt;b</code> 加上了relationship的path</li>
<li><code>()-[]-&gt;b</code> 如果都不想要标注变量，可用<code>()</code>表示一个node（或一个子pattern），用<code>[]</code>表示一个relationship</li>
<li><code>a-[r:TYPE1|TYPE2]-&gt;b</code> 指定relationship type，其中type可以指定多个，为或的关系。</li>
<li><code>a-[?*]-&gt;b</code> 得到node a到node b的所有路径，如果不存在路径则返回null。（假如没有<code>?</code>则返回空）</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">a</span> <span class="o">=</span> node<span class="o">(</span>1<span class="o">)</span> match <span class="nv">p</span> <span class="o">=</span> a-<span class="o">[</span>*<span class="o">]</span>-&gt;b <span class="k">return </span>p;
</span><span class='line'>+----------------------------------------------------------------------------------------------------------------------+
</span><span class='line'>| p                                                                                                                    |
</span><span class='line'>+----------------------------------------------------------------------------------------------------------------------+
</span><span class='line'>| <span class="o">[</span>Node<span class="o">[</span>1<span class="o">]{</span>name:<span class="s2">&quot;bran&quot;</span>,age:10<span class="o">}</span>,:islittlebrotherof<span class="o">[</span>0<span class="o">]</span> <span class="o">{</span>ctime:1359963465947<span class="o">}</span>,Node<span class="o">[</span>2<span class="o">]{</span>name:<span class="s2">&quot;jon&quot;</span>,age:17<span class="o">}]</span>                 |
</span><span class='line'>| <span class="o">[</span>Node<span class="o">[</span>1<span class="o">]{</span>name:<span class="s2">&quot;bran&quot;</span>,age:10<span class="o">}</span>,:isownerof<span class="o">[</span>1<span class="o">]</span> <span class="o">{}</span>,Node<span class="o">[</span>3<span class="o">]{</span>name:<span class="s2">&quot;summer&quot;</span>,age:4<span class="o">}]</span>                                          |
</span><span class='line'>| <span class="o">[</span>Node<span class="o">[</span>1<span class="o">]{</span>name:<span class="s2">&quot;bran&quot;</span>,age:10<span class="o">}</span>,:isownerof<span class="o">[</span>1<span class="o">]</span> <span class="o">{}</span>,Node<span class="o">[</span>3<span class="o">]{</span>name:<span class="s2">&quot;summer&quot;</span>,age:4<span class="o">}</span>,:knowns<span class="o">[</span>5<span class="o">]</span> <span class="o">{}</span>,Node<span class="o">[</span>2<span class="o">]{</span>name:<span class="s2">&quot;jon&quot;</span>,age:17<span class="o">}]</span> |
</span><span class='line'>+----------------------------------------------------------------------------------------------------------------------+
</span><span class='line'>3 rows
</span><span class='line'>1 ms
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>a-[*3..5]-&gt;b</code> 指定path的深度，是可以是一个范围值。</li>
<li><code>me-[:KNOWS*1..2]-remote_friend</code> 将前面集中pattern整合一下，主要是注意其中各pattern的位置，不能搞乱。</li>
</ul>


<h3>index</h3>

<p><code>neo4j</code>的索引是一个key=>value对，基于lucene，据说也可以换其他的引擎，没试过。通过索引可以供<code>Cypher</code>或Rest api查找对应的node或relationship或任何想要的集合。</p>

<p>索引分为两种，自动索引和手动索引，就目前的<code>Cypher</code>版本(1.9.M04)来说，还没有提供创建手动索引的功能，遗憾的是，在nodejs客户端中同样没有完善这一功能，所以我找到了一个ruby版本的客户端用于实验这一功能。</p>

<p><a href="https://github.com/maxdemarzi/neography">neography</a>是官方推荐的一个ruby driver(其实官方推荐中排名更靠前的是<a href="https://github.com/andreasronge/neo4j">neo4j.rb</a>，但是基于jruby的，出于对java的不感冒，还是绕行了)，文档很详细，不赘述了</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;neography&#39;</span>
</span><span class='line'><span class="vi">@neo</span> <span class="o">=</span> <span class="no">Neography</span><span class="o">::</span><span class="no">Rest</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="vi">@neo</span><span class="o">.</span><span class="n">create_node_index</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>                      <span class="c1">#新增一个索引，其中第一个参数是索引主键</span>
</span><span class='line'><span class="vi">@neo</span><span class="o">.</span><span class="n">add_node_to_index</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;bran&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">#将一个node添加到索引，其中最后的`1`是node id，也可以是一个node对象，很神奇，很kiss</span>
</span></code></pre></td></tr></table></div></figure>


<p>建好一个索引之后，就可以由<code>Cypher</code>出场了。<code>Cypher</code>中通过索引可以查到对应的node和relationship。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#                       节点:索引主键(key=value)</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">n</span> <span class="o">=</span> node:name<span class="o">(</span><span class="nv">name</span><span class="o">=</span><span class="s2">&quot;bran&quot;</span><span class="o">)</span> <span class="k">return </span>n;
</span><span class='line'>+-----------------------------+
</span><span class='line'>| n                           |
</span><span class='line'>+-----------------------------+
</span><span class='line'>| Node<span class="o">[</span>1<span class="o">]{</span>name:<span class="s2">&quot;bran&quot;</span>,age:10<span class="o">}</span> |
</span><span class='line'>+-----------------------------+
</span><span class='line'>1 row
</span></code></pre></td></tr></table></div></figure>


<p>使用<code>Cypher</code>可以创建自动索引，前提是配置中打开了<code>node_auto_indexing</code>(针对node)或<code>relationship_auto_indexing</code>(针对relationship)这一项，而且这个索引是后写入的，也就是说假如之前已经存在的node，在没有改动的情况下，是不会加入到索引中的。</p>

<p>自动索引可以设定需要的fields，在配置文件中用<code>node_keys_indexable</code>和<code>relationship_keys_indexable</code>表示</p>

<p>创建索引的<code>Cypher</code>语句如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>index --create node_auto_index -t node
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>index --indexes
</span><span class='line'>Node indexes:
</span><span class='line'>  name
</span><span class='line'>  node_auto_index
</span><span class='line'>
</span><span class='line'>Relationship indexes:
</span></code></pre></td></tr></table></div></figure>


<p>自动索引默认是关闭的，可能是出于效率的考虑，毕竟在正常的应用中我们不需要对所有node进行索引。而且自动索引是只读的，就是说索引建立以后，除了清空数据库，木有别的方法删掉它啊~。</p>

<h2>注意事项</h2>

<ul>
<li><code>Cypher</code>中遇到某些查询条件中包含空格或别的非英文字符的，可以用`把字符串包起来。</li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="http://docs.neo4j.org/chunked/milestone/">v1.9手册</a></li>
<li><a href="https://github.com/maxdemarzi/neography/wiki">neography wiki</a></li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-02-01T11:30:00+08:00" pubdate data-updated="true">2013.02.01</time></div>
	<div class="tags">


	<a class='category' href='/blog/blog/categories/cypher/'>cypher</a>, <a class='category' href='/blog/blog/categories/learn/'>learn</a>, <a class='category' href='/blog/blog/categories/neo4j/'>neo4j</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/blog/blog/2013/01/30/get-post-put-delete-sha-sha-fen-bu-qing-chu/">Get Post Put Delete 傻傻分不清楚</a></h1>
	<div class="entry-content">
		<p>最近看了一些REST API设计的文章，被http中的四种请求类型搞的晕头转向，记录一下，以免忘记。</p>

<h2>准备工具</h2>

<ul>
<li><a href="https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?utm_source=chrome-ntp-icon">Chrome插件REST Console</a></li>
<li>一个用于接收参数的php文件</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="nb">print_r</span><span class="p">(</span><span class="nv">$_REQUEST</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>开始</h2>

<p>在通常的lamp开发中，我们最常用到的两种类型是<code>GET</code>和<code>POST</code>，例如用户注册的表单我们会通过<code>POST</code>方式提交到服务器，而一般的ajax接口我们通过<code>GET</code>方式调用。另两种方式不常用，根据w3c关于http1.1的草案，<code>PUT</code>在对象存在的时候用于更新，不存在时与<code>POST</code>相同，用于新建，<code>DELETE</code>顾名思义就是删除对象了。</p>

<p>这也解释了为什么我们在一般的web接口设计中(即使想尽量迎合<code>restful</code>)很少用到<code>PUT</code>和<code>DELETE</code>了，就拿用户账号来说，一般我们的服务器api清楚用户需要做什么，一般分为以下几种情况。</p>

<ul>
<li>注册： 用户初来乍到，肯定是新建资料，这个时候用<code>POST</code></li>
<li>登录： 登录需要获取用户信息和密码，用<code>GET</code></li>
<li>修改账户： 修改的操作比较纠结，按照<code>rest</code>的设计风格，应该用<code>PUT</code>，但是我们一般在服务器端会先做校验，而且当用户信息不存在的情况下不会主动去做创建的操作，而是返回错误信息，更重要的一点是，目前的表单中只支持<code>GET</code>和<code>POST</code>两种方式，所以这个时候一般还是用<code>POST</code>。</li>
<li>注销账户： 注销账户的情况比较少，而且一般不会做硬删除(否则用户后悔了找上门来咋办捏~)，所以这个时候实质上还是更新的操作，那么同上，一般会使用<code>POST</code>。</li>
</ul>


<p>如此看来，<code>PUT</code>和<code>DELETE</code>岂不是没有用武之地了？在很多server-to-server的api设计中，这些请求方式还是很有用的，灵活利用，可以设计出优雅易读的web-api来，<a href="https://github.com/sofish">@sofish</a>在数月之前有一篇<a href="http://sofish.de/2100">博文</a>很好的解释这种设计的理念和优势。</p>

<h2>application/x-www-form-urlencoded</h2>

<p>为了对比<code>GET</code>和<code>POST</code>的异同，在测试过程中还有一个新发现。REST console中默认发送<code>application/x-www-form-urlencoded</code>这个请求头，于是在使用<code>POST</code>方式时，服务器端的php代码不能正确的获得参数，查看请求头，发现本来应该是<code>POST DATA</code>的地方变成了下面这样。</p>

<blockquote><p>Request Payload
url=http%3A%2F%2Fwww.google.com</p></blockquote>

<p>google了一个这个<code>Request Payload</code>，找到了<a href="http://stackoverflow.com/questions/9597052/how-to-retrieve-request-payload">stackoverflow君</a>，大意是说假如header中没有<code>application/x-www-form-urlencoded</code>的话，参数不是通过表单项来传递，而是作为request body的一部分。我们的server比较死板，自然认不出这些马甲咯。</p>

<h2>安全与幂等</h2>

<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">w3c关于http method的定义</a>中有一段犹如天书一样的文字，解释了各种方式之间的异同，其中提到了<code>安全</code>与<code>幂等</code>两个概念，大致可以做如下解释。</p>

<ul>
<li>安全性： api的目的只是从服务器获取数据，无任何新建或更新操作，就认为是安全的。例如<code>GET</code>和<code>HEAD</code></li>
<li>幂等性： 这个比较难解释的，概括一下可以说是不管一个api调用多少次，返回的结果应该都是唯一的。比如设计的比较规范的<code>GET</code>和<code>DELETE</code>接口。</li>
</ul>


<h2>rest api的效率问题</h2>

<p>api的效率其实就是http的效率，可以用一个例子来说明。</p>

<p>redis是一个高性能的nosql数据库，但是没有提供rest api。通过tcp连接redis读写效率快的没话说，可是假如对外提供api则需要通过php等客户端做中间件。一次请求需要经过<code>http request-&gt;nginx-&gt;php-&gt;redis</code>层层深入，才能到达最终目标，降低了效率，<a href="https://github.com/nicolasff/webdis">webdis</a>则通过提供redis的rest api将流程简化成了<code>http request-&gt;webdis-&gt;redis</code>，省去了中间的周折，效率自然也就上去了。</p>

<h2>所有method类型</h2>

<p><a href="http://hc.apache.org/httpclient-3.x/apidocs/org/apache/commons/httpclient/HttpMethod.html">apache的interface httpmethod</a>中列举了所有已知的类型，林林总总加起来有十多项了，可以作为一个查询的索引。不过最常用的应该还是<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>四种了。</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_services">RESTful_web_services</a></li>
<li><a href="http://sofish.de/2100">让牛懂琴 by sofish</a></li>
<li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">rfc2616</a></li>
<li><a href="http://coolshell.cn/articles/4787.html">HTTP幂等性概念和应用 by </a></li>
<li><a href="http://hc.apache.org/httpclient-3.x/apidocs/org/apache/commons/httpclient/HttpMethod.html">Interface HttpMethod</a></li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-01-30T12:41:00+08:00" pubdate data-updated="true">2013.01.30</time></div>
	<div class="tags">


	<a class='category' href='/blog/blog/categories/http/'>http</a>, <a class='category' href='/blog/blog/categories/rest/'>rest</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/blog/blog/2013/01/28/node-neo4j-xue-xi-bi-ji/">Node-neo4j 学习笔记</a></h1>
	<div class="entry-content">
		<h2><a href="https://github.com/thingdom/node-neo4j">node-neo4j</a></h2>

<h3>查找节点</h3>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">neo4j = </span><span class="nx">require</span> <span class="s">&#39;neo4j&#39;</span>
</span><span class='line'><span class="nv">db = </span><span class="k">new</span> <span class="nx">neo4j</span><span class="p">.</span><span class="nx">GraphDatabase</span><span class="p">(</span><span class="s">&#39;http://localhost:7474&#39;</span><span class="p">)</span>
</span><span class='line'><span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">(err, node)-&gt;</span>
</span><span class='line'>    <span class="k">if</span> <span class="nx">err</span> <span class="o">||</span> <span class="o">!</span><span class="nx">node</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">err</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">node</span><span class="p">.</span><span class="nx">data</span>
</span></code></pre></td></tr></table></div></figure>


<p>查找节点的api设计的很有dom的风格，与大多数nodejs方法一样，node-neo4j提供的api都是异步的，回调函数中第一个参数都是错误流，第二个因方法而异，<code>getNodeById</code>中的第二个参数node是一个完整的json对象，在这个对象上可以使用node-neo4j针对node的所有方法，要取得或修改node中的成员则可以通过<code>node.data</code>获取。</p>

<h3>创建关系</h3>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="c1"># 创建节点</span>
</span><span class='line'><span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">(err, n1)-&gt;</span>
</span><span class='line'>    <span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">2</span><span class="p">,</span> <span class="nf">(err, n2)-&gt;</span>
</span><span class='line'>       <span class="c1">#当前节点                 目标节点 关系类型 关系结构</span>
</span><span class='line'>        <span class="nx">n2</span><span class="p">.</span><span class="nx">createRelationshipTo</span> <span class="nx">n1</span><span class="p">,</span> <span class="s">&#39;isdogof&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nv">ctime: </span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()},</span> <span class="nf">(err, r)-&gt;</span>
</span><span class='line'>            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">r</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 查找节点</span>
</span><span class='line'><span class="nx">db</span><span class="p">.</span><span class="nx">getRelationshipById</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">(err, rel)-&gt;</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">rel</span>
</span></code></pre></td></tr></table></div></figure>


<p>目前通过<code>node-neo4j</code>创建关系只能在node上做文章，通过<code>createRelationshipFrom</code>和<code>createRelationshipTo</code>来创建点对点的关系。客户端的作者很坑爹的在Graphdatabase._coffee中声明了一个<code>createRelationship</code>方法，但是没有实现，调用这个方法是不会有任何效果的。</p>

<h3>查询关系</h3>

<p><code>node-neo4j</code>中声明了四种方式来获取关于某个节点的关系，分别是
* node.getRelationships 获取与节点相关的所有关系
* node.outgoing         获取以该节点为起点的关系
* node.incoming         获取以该节点为终点的关系
* node.all              同getRelationships
这些方法最终都调用<code>_getRelationships</code>，虽然我们也能直接调用这个方法，不过既然人家已声明其为私有，那还是直接调用上面的方法比较好。下面举例：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">2</span><span class="p">,</span> <span class="nf">(err, nBran)-&gt;</span>
</span><span class='line'>    <span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">(err, nSnow)-&gt;</span>
</span><span class='line'>        <span class="nx">nSnow</span><span class="p">.</span><span class="nx">incoming</span> <span class="s">&#39;islittlebrotherof&#39;</span><span class="p">,</span> <span class="nf">(err, rel)-&gt;</span>
</span><span class='line'>            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">rel</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">data</span>
</span></code></pre></td></tr></table></div></figure>


<p>假如关系类型(type)不存在或者没有关联到这个节点的关系，getRelationships返回rel为一个空数组。否则返回节点在这个类型的所有关系数组，<code>rel[0].data</code>则是获取关系的属性。</p>

<h3>根据关系种类查询</h3>

<p>neo4j的关系中还有个比较重要的概念是种类(type)，在<code>Cypher</code>中可以通过<code>type()</code>方法来获取某个关系的种类</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">r</span> <span class="o">=</span> rel<span class="o">(</span>*<span class="o">)</span> <span class="k">return </span><span class="nb">type</span><span class="o">(</span>r<span class="o">)</span>;
</span><span class='line'>+---------------------+
</span><span class='line'>| <span class="nb">type</span><span class="o">(</span>r<span class="o">)</span>             |
</span><span class='line'>+---------------------+
</span><span class='line'>| <span class="s2">&quot;islittlebrotherof&quot;</span> |
</span><span class='line'>+---------------------+
</span><span class='line'>1 row
</span><span class='line'>0 ms
</span></code></pre></td></tr></table></div></figure>


<p>在<code>node-neo4j</code>中，<code>getRelationships</code>可以获取某节点某个种类的关系，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">13</span><span class="p">,</span> <span class="nf">(err, bran)-&gt;</span>
</span><span class='line'>    <span class="nx">bran</span><span class="p">.</span><span class="nx">getRelationships</span> <span class="s">&#39;islittlebrotherof&#39;</span><span class="p">,</span> <span class="nf">(err, rel)-&gt;</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">rel</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">data</span>
</span></code></pre></td></tr></table></div></figure>


<p>callback中返回的是一个关系对象数组。</p>

<h3>万能的query</h3>

<p>db对象上有一个万能的<code>query</code>方法，就是直接通过<code>Cypher</code>语句得到查询结果啦，这个弥补了作者很多没有实现的方法。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-01-28T11:49:00+08:00" pubdate data-updated="true">2013.01.28</time></div>
	<div class="tags">


	<a class='category' href='/blog/blog/categories/learn/'>learn</a>, <a class='category' href='/blog/blog/categories/neo4j/'>neo4j</a>, <a class='category' href='/blog/blog/categories/nodejs/'>nodejs</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/blog/blog/2013/01/23/chu-shi-tu-xing-shu-ju-ku-neo4j/">初试图形数据库 Neo4j</a></h1>
	<div class="entry-content">
		<h2>安装</h2>

<p>作为一个java软件，就得充分发挥它<code>Write Once, Run Anywhere</code>的精神。直接下载tarball，解压后运行即可。官方还很贴心的提供了一个init脚本(./bin/neo4j)，链接到init.d下就可以开搞啦。</p>

<p>默认的服务实例在localhost:7474，其余配置还是值得好好研究一番的。</p>

<h2>neo4j shell</h2>

<p>neo4j提供了一种叫做<code>Cypher Query Language</code>的查询方言，可以看做是图形数据库的sql，neo4j还提供了一个<code>neo4j-shell</code>用于做查询交互，在命令行下可以使用<code>./bin/neo4j-shell</code>来开启，web中也有一个tab叫做<code>power-tool console</code>可以使用neo4j-shell。</p>

<h3>增删改节点</h3>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 创建节点</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>CREATE <span class="nv">n</span> <span class="o">=</span> <span class="o">{</span> name : <span class="s1">&#39;Andres&#39;</span>, title : <span class="s1">&#39;Developer&#39;</span> <span class="o">}</span> RETURN n;
</span><span class='line'>+-------------------------------------------+
</span><span class='line'>| n                                         |
</span><span class='line'>+-------------------------------------------+
</span><span class='line'>| Node<span class="o">[</span>37<span class="o">]{</span>name:<span class="s2">&quot;Andres&quot;</span>,title:<span class="s2">&quot;Developer&quot;</span><span class="o">}</span> |
</span><span class='line'>+-------------------------------------------+
</span><span class='line'>1 row
</span><span class='line'>Nodes created: 1
</span><span class='line'>Properties <span class="nb">set</span>: 2
</span><span class='line'>8 ms
</span><span class='line'><span class="c"># 修改节点</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>START <span class="nv">n</span> <span class="o">=</span> node<span class="o">(</span>37<span class="o">)</span> SET n.surname <span class="o">=</span> <span class="s1">&#39;Taylor&#39;</span> RETURN n;
</span><span class='line'>+------------------------------------------------------------+
</span><span class='line'>| n                                                          |
</span><span class='line'>+------------------------------------------------------------+
</span><span class='line'>| Node<span class="o">[</span>37<span class="o">]{</span>name:<span class="s2">&quot;Andres&quot;</span>,title:<span class="s2">&quot;Developer&quot;</span>,surname:<span class="s2">&quot;Taylor&quot;</span><span class="o">}</span> |
</span><span class='line'>+------------------------------------------------------------+
</span><span class='line'>1 row
</span><span class='line'>Properties <span class="nb">set</span>: 1
</span><span class='line'>15 ms
</span><span class='line'><span class="c"># 删除节点</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>START <span class="nv">n</span> <span class="o">=</span> node<span class="o">(</span>37<span class="o">)</span> DELETE n;
</span><span class='line'>+-------------------+
</span><span class='line'>| No data returned. |
</span><span class='line'>+-------------------+
</span><span class='line'>Nodes deleted: 1
</span><span class='line'>4 ms
</span></code></pre></td></tr></table></div></figure>


<h3>创建关系</h3>

<p>图形数据库最重要的一个概念就是关系(relationship)，各个节点直接通过双向或单向的关系连接在一起，这样才能从一个节点查找到其他的节点，这种设计在某些场景下会让查询变得更加高效而灵活，例如社交网络中的好友关系，人立方中查找任意两人之间的亲友，假如使用传统的关系数据库，查找朋友的朋友就会变得非常的困难，其耗时也是指数型的增长，而使用图形数据库，则可以保持线性的效率。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 创建两个节点的关系</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>START <span class="nv">a</span> <span class="o">=</span> node<span class="o">(</span>34<span class="o">)</span>, <span class="nv">b</span> <span class="o">=</span> node<span class="o">(</span>36<span class="o">)</span> CREATE a-<span class="o">[</span>r:knowns<span class="o">]</span>-&gt;b RETURN r;
</span><span class='line'>+---------------+
</span><span class='line'>| r             |
</span><span class='line'>+---------------+
</span><span class='line'>| :knowns<span class="o">[</span>0<span class="o">]</span> <span class="o">{}</span> |
</span><span class='line'>+---------------+
</span><span class='line'>1 row
</span><span class='line'>Relationships created: 1
</span><span class='line'>20 ms
</span><span class='line'><span class="c"># 查找关系</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">r</span> <span class="o">=</span> rel<span class="o">(</span>0<span class="o">)</span> <span class="k">return </span>r;
</span><span class='line'>+-----------------------------------+
</span><span class='line'>| r                                 |
</span><span class='line'>+-----------------------------------+
</span><span class='line'>| :isdogof<span class="o">[</span>0<span class="o">]</span> <span class="o">{</span>ctime:1359365331933<span class="o">}</span> |
</span><span class='line'>+-----------------------------------+
</span><span class='line'>1 row
</span><span class='line'>1 ms
</span><span class='line'><span class="c"># 删除某节点和它的所有关系</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>START <span class="nv">n</span> <span class="o">=</span> node<span class="o">(</span>34<span class="o">)</span> MATCH n-<span class="o">[</span>r<span class="o">]</span>-<span class="o">()</span> DELETE n, r;
</span><span class='line'>+-------------------+
</span><span class='line'>| No data returned. |
</span><span class='line'>+-------------------+
</span><span class='line'>Nodes deleted: 1
</span><span class='line'>Relationships deleted: 3
</span><span class='line'>3 ms
</span><span class='line'><span class="c"># 查找节点的关系</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">a</span> <span class="o">=</span> node<span class="o">(</span>2<span class="o">)</span> match a&lt;-<span class="o">[</span>r:isfamilyof<span class="o">]</span>-&gt;b RETURN a,r,b;
</span><span class='line'>+----------------------------------------------------------------------------------------+
</span><span class='line'>| a                           | r                          | b                           |
</span><span class='line'>+----------------------------------------------------------------------------------------+
</span><span class='line'>| Node<span class="o">[</span>2<span class="o">]{</span>name:<span class="s2">&quot;bran&quot;</span>,age:10<span class="o">}</span> | :isfamilyof<span class="o">[</span>2<span class="o">]</span> <span class="o">{</span>ctime:200<span class="o">}</span> | Node<span class="o">[</span>1<span class="o">]{</span>name:<span class="s2">&quot;snow&quot;</span>,age:17<span class="o">}</span> |
</span><span class='line'>+----------------------------------------------------------------------------------------+
</span></code></pre></td></tr></table></div></figure>


<p>有意思的是注意其中<code>CREATE a-[r:knowns]-&gt;b</code>中的箭头走向表示这种关系的指向，我们可以通过<code>CREATE a&lt;-[r:knowns]-b</code>来创建一个b到a的关系，但是当我想用<code>CREATE a&lt;-[r:knowns]-&gt;b</code>来创建一个双向关系时却没有成功，仍然只创建了从a到b的关系。而在查找某个节点的关系时，双向箭头确是起作用的，应该算做一个bug。</p>

<h3>删除所有节点和关系</h3>

<p><code>Cypher</code>中可以使用通配符<code>*</code>来找出所有的节点或者关系，那么假如我们需要删除所有节点，语句如下</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 如果节点上还有对应的关系，该节点是无法删除的，所以需要先删除所有关系</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">r</span> <span class="o">=</span> rel<span class="o">(</span>*<span class="o">)</span> delete r;
</span><span class='line'>+--------------------------------------------+
</span><span class='line'>| No data returned, and nothing was changed. |
</span><span class='line'>+--------------------------------------------+
</span><span class='line'>0 ms
</span><span class='line'><span class="c"># 删除节点</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">n</span> <span class="o">=</span> node<span class="o">(</span>*<span class="o">)</span> delete n;
</span><span class='line'>+-------------------+
</span><span class='line'>| No data returned. |
</span><span class='line'>+-------------------+
</span><span class='line'>Nodes deleted: 2
</span><span class='line'>4 ms
</span></code></pre></td></tr></table></div></figure>


<p>删除所有节点后，在web端显示的节点数和关系数可能会对不上真实的数据，这些数量官方叫做&#8221;Primitive count&#8221;，其实在<code>neo4j-shell</code>下可以用下面的命令得到，按字面意思应该表示一个估算值，并不准确。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>0<span class="o">)</span><span class="nv">$ </span>dbinfo -g <span class="s2">&quot;Primitive count&quot;</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="s2">&quot;NumberOfNodeIdsInUse&quot;</span>: 1,
</span><span class='line'>  <span class="s2">&quot;NumberOfPropertyIdsInUse&quot;</span>: 0,
</span><span class='line'>  <span class="s2">&quot;NumberOfRelationshipIdsInUse&quot;</span>: 0,
</span><span class='line'>  <span class="s2">&quot;NumberOfRelationshipTypeIdsInUse&quot;</span>: 0
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在自己看来，<code>Cypher Query Language</code>的增删改语句还是比较直观的，但是一旦牵涉到关系就有点没节操了，一句查询中一半的操作符，真是让人看花眼，相较之下还是sql发展的比较成熟，也更易为人所接受了。<a href="http://docs.neo4j.org/chunked/milestone/cypher-query-lang.html">更多的操作符和更多的语法</a></p>

<p>不过，各种neo4j的客户端都将晦涩的<code>Cypher</code>语言封装起来，提供了可读性更高的接口方法，下面就找个客户端来试用一下。</p>

<h2>nodejs bundle</h2>

<p>官网上给出了java和python版本的实例，我等屌丝玩点轻量级的，这里找了一个<a href="https://github.com/thingdom/node-neo4j">nodejs的客户端</a>，初窥图形数据库的魅力。</p>

<h3>创建及修改节点</h3>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">neo4j = </span><span class="nx">require</span> <span class="s">&#39;neo4j&#39;</span>     <span class="c1">#使用coffee-script，那就尽量写的更coffee一点儿吧</span>
</span><span class='line'><span class="nv">db = </span><span class="k">new</span> <span class="nx">neo4j</span><span class="p">.</span><span class="nx">GraphDatabase</span><span class="p">(</span><span class="s">&#39;http://localhost:7474&#39;</span><span class="p">)</span> <span class="c1">#连接默认的REST端口</span>
</span><span class='line'><span class="nx">node</span><span class="p">.</span><span class="nx">createNode</span> <span class="p">{</span>             <span class="c1">#初始化一个节点</span>
</span><span class='line'>    <span class="nv">username: </span><span class="s">&#39;bran&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">node</span><span class="p">.</span><span class="nx">save</span> <span class="nf">(err, node)-&gt;</span>       <span class="c1">#需要save才能真正的保存这个节点到数据库</span>
</span><span class='line'>    <span class="nv">node.data = </span><span class="p">{</span>           <span class="c1">#可以通过直接修改node的data属性来修改node值</span>
</span><span class='line'>        <span class="nv">username: </span><span class="s">&#39;bran&#39;</span>
</span><span class='line'>        <span class="nv">nickname: </span><span class="s">&#39;bird man&#39;</span>
</span><span class='line'>        <span class="nv">email: </span><span class="s">&#39;bran@gmail.com&#39;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">node</span><span class="p">.</span><span class="nx">save</span><span class="p">()</span>             <span class="c1">#不要忘了再次保存</span>
</span></code></pre></td></tr></table></div></figure>


<h2>备份数据库</h2>

<p>之前造出了那么多的脏数据，有点洁癖的人都想要把数据清理一下吧。网上找了找，发现只有&#8217;enterprise&#8217;版才有export的功能，这不是明摆着鄙视我等屌丝么。在<a href="http://www.mail-archive.com/user@lists.neo4j.org/msg08932.html">这里</a>(翻墙可入)有兄台说了一个很暴力的办法，直接删除<code>data/graph.db</code>文件夹，我试了一下，确实可行，重启后世界干干净净，只剩下了0号node，果断再用<code>start n = node(0) delete n;</code>删除之。这大概也是nosql的好处，数据就是文件，取消了维护索引，关系等等的麻烦，随去随用，冷备份和迁移的时候也简单，直接copy文件夹即可。</p>

<h2>参考文档</h2>

<ul>
<li><a href="http://docs.neo4j.org/chunked/milestone/">v1.9手册</a></li>
<li><a href="http://docs.neo4j.org.cn/">v1.8中文开发文档</a></li>
<li><a href="http://coffeedoc.info/github/thingdom/node-neo4j/master/">node-neo4j文档</a></li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-01-23T11:25:00+08:00" pubdate data-updated="true">2013.01.23</time></div>
	<div class="tags">


	<a class='category' href='/blog/blog/categories/coffee/'>coffee</a>, <a class='category' href='/blog/blog/categories/database/'>database</a>, <a class='category' href='/blog/blog/categories/neo4j/'>neo4j</a>, <a class='category' href='/blog/blog/categories/nodejs/'>nodejs</a>


</div>
	
</div></article>


    <article class="post">
	<h1 class="title"><a href="/blog/blog/2013/01/21/awk-xue-xi-bi-ji-2/">Awk 学习笔记(2)</a></h1>
	<div class="entry-content">
		<h2>常用的选项</h2>

<ul>
<li>-F 指定分隔符</li>
<li>-f 指定调用脚本，可以多次引用，不同文件会被合并成一个awk脚本</li>
<li>-d 输出所有变量到文件，默认输出到awkvars.out，也可以通过在-d后加文件路径来指定文件，但是注意-d与文件名之间不能有空格。调试的时候这个选项会非常有用。</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk -d./awk.dump <span class="s1">&#39;BEGIN { foo = &quot;test&quot; } /^foo/ { print $0 }&#39;</span> BBS-list
</span><span class='line'><span class="nv">$ </span>cat ./awk.dump
</span><span class='line'>ARGC: 2
</span><span class='line'>ARGIND: 1
</span><span class='line'>ARGV: array, 2 elements
</span><span class='line'>foo: <span class="s2">&quot;test&quot;</span>
</span><span class='line'>...
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>-p 将命令行下的awk脚本格式化输出到awkprof.out文件，可以在-p后加文件路径来指定文件，注意也不能有空格</li>
<li>-v 预设置awk程序变量，可以设置多次</li>
</ul>


<h2>分隔符的四种形式</h2>

<ul>
<li><code>-F " "</code>      默认，以空格或tab分隔，首尾的空格会被排除掉</li>
<li><code>-F "a"</code>      以普通字符串分隔，用户指定</li>
<li><code>-F "[: ]"</code>   以正则表达式分隔，一般在设定多个分隔符时比较有用（如右边就是按<code>:</code>或空格分隔）</li>
<li><code>-F ""</code>       每个字符都是单独的一列，只在gawk中支持</li>
</ul>


<h2>@include</h2>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="err">@</span><span class="o">in</span><span class="nx">clude</span> <span class="s1">&#39;./libfoo.awk&#39;</span>
</span><span class='line'><span class="nx">END</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">print</span> <span class="s2">&quot;end of file&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>多行记录</h2>

<p>有些文件中相关联的数据可能会分为多行显示，<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Multiple-Line">看手册中的例子</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Jane Doe
</span><span class='line'>123 Main Street
</span><span class='line'>Anywhere, SE 12345-6789
</span><span class='line'>
</span><span class='line'>John Smith
</span><span class='line'>456 Tree-lined Avenue
</span><span class='line'>Smallville, MW 98765-4321</span></code></pre></td></tr></table></div></figure>


<p>很明显每个块中的数据是有联系的，然后每个块都以一行空字符分割，那么分析的awk脚本可以写成这样。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="nx">BEGIN</span> <span class="p">{</span> <span class="nb">RS</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="p">;</span> <span class="nb">FS</span> <span class="o">=</span> <span class="s2">&quot;\n&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kr">print</span> <span class="s2">&quot;Name is:&quot;</span><span class="p">,</span> <span class="o">$</span><span class="mi">1</span>
</span><span class='line'>    <span class="kr">print</span> <span class="s2">&quot;Address is:&quot;</span><span class="p">,</span> <span class="o">$</span><span class="mi">2</span>
</span><span class='line'>    <span class="kr">print</span> <span class="s2">&quot;City and State are:&quot;</span><span class="p">,</span> <span class="o">$</span><span class="mi">3</span>
</span><span class='line'>    <span class="kr">print</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的RS也是支持正则表达式的</p>

<h2>格式化控制符</h2>

<p>OFMT与printf中用到的格式化控制符可以参考c中的printf，具体可以<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Control-Letters">参考手册</a></p>

<h2>I/O</h2>

<p>awk可以用<code>&gt;</code>,<code>&gt;&gt;</code>,<code>|</code>将输出定向到文件或管道，但需要注意的是后面的文件名或命令都需要用双引号包起来。</p>

<h2>switch</h2>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>top -bn1|grep java|grep -v grep|awk <span class="s1">&#39;{ switch ($6) { case /m$/: print $6*1024;break; default: print $6; } }&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>switch语句与C中相同，注意break的使用。此外，在兼容模式下不可用。</p>

<h2>man tag</h2>

<p><a href="http://www.gnu.org/software/gawk/manual/gawk.html#Special-Files">Special-Files</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-01-21T17:42:00+08:00" pubdate data-updated="true">2013.01.21</time></div>
	<div class="tags">


	<a class='category' href='/blog/blog/categories/awk/'>awk</a>, <a class='category' href='/blog/blog/categories/learn/'>learn</a>


</div>
	
</div></article>

<nav id="pagenavi">
    
    
        <a href="/blog/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2013

    tristan

</footer>
	<script src="/blog/javascripts/slash.js"></script>
<script src="/blog/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'sailxjx';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-33186961-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>