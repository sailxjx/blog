<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: caprice | CodeBean]]></title>
  <link href="http://sailxjx.github.io/blog/blog/categories/caprice/atom.xml" rel="self"/>
  <link href="http://sailxjx.github.io/blog/"/>
  <updated>2014-04-19T18:06:12+08:00</updated>
  <id>http://sailxjx.github.io/blog/</id>
  <author>
    <name><![CDATA[tristan]]></name>
    <email><![CDATA[sailxjx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[软件与配置]]></title>
    <link href="http://sailxjx.github.io/blog/blog/2014/02/28/ruan-jian-yu-pei-zhi/"/>
    <updated>2014-02-28T13:07:00+08:00</updated>
    <id>http://sailxjx.github.io/blog/blog/2014/02/28/ruan-jian-yu-pei-zhi</id>
    <content type="html"><![CDATA[<p>前段时间不间断的开发新项目，实际是想得多，写得少，最后落实到代码中，大概也就200多k文件。现在回头看一下，觉得还挺满意的，因为每个新项目会找出些不一样的地方，不求做到最好，但求标新立异，否则岂不是失去了开发的意义，也辜负了“程序猿”这个需要些许创造性的工作。</p>

<p>每次新项目达到一个阶段，能回顾一下，总是极好的。这次细想一下，有什么值得总结的地方，就又回到了“软件配置”这个极庸俗的话题上来了。</p>

<p>在我看来，任何软件都少不了配置，但是在之前的文章中我也提到过，<a href="/blog/2013/09/17/ruan-jian-ji-jian-zhu-yi/">配置是软件的大敌</a>。任何软件配置越复杂，学习成本也就越高，这是一种反人类的趋势，所以这种软件，要么被更新，更简单的软件取代，要么就根本无人问津，消失在软件的海洋中。</p>

<p>当然，配置也可以被广泛的定义，形式是多种多样的，有些还是群众们喜闻乐见的，不能一棒子打死了。下面谨罗列一下我心目中的配置文件类型，和它们的适用范围。</p>

<h2 id="key-value">第一阶段，单纯的key-value</h2>
<p>这应该是最常见的一种配置，也最接近配置文件的本意。所谓人各有所好，软件在部署的过程中会遭遇不同的平台，也会遇到不同的适用情况和环境，这个时候就需要依靠配置文件来告诉软件应该怎样正确的运行。操作系统中的环境变量就是一种最常见的配置，<code>PATH</code>定义了用户需要的可执行文件的搜索范围，<code>SHELL</code>决定了和人交互的shell版本。在web应用中，数据库连接，域名，api签名秘钥等等都应当以配置的形式出现，否则就是给懒惰的开发者增加麻烦。</p>

<p>为什么说是“懒惰的开发者”，应为这些配置其实都可以通过在源代码中通过<code>if-else</code>条件来解决，要是碰到个勤快的开发（也许也是愚蠢的开发），就会把签名秘钥写在代码中，通过<code>if-else</code>来判断哪种环境应该调用哪种签名生成规则。但是在编程界，“懒惰是一种美德”，前面的做法非但徒增开发的难度，也不够灵活，用逼格更高的话来说，就是“不够优雅”。</p>

<p>所以需要用到<code>key-value</code>类型的配置。通常情况下，这种配置文件的出现形式会是一个json文件或是一个xml文件。假如这种配置文件不需要做到跨语言调用的话，跟进一步的做法是直接使用软件可用的脚本语言，通常会于源代码的语言保持一致。像我们写nodejs应用，使用js文件来做配置，就会比用json来的更加灵活。</p>

<h2 id="section">第二阶段，预定义方法</h2>
<p>下面提到的配置类型都有别于狭义的配置文件。比如说某些预先定义好的方法。我们可以在软件中预先定义好一些方法，这些方法我们不知道会不会用到，也不知道什么时候会用到，唯一明确的一点就是，我们知道这些方法能接受哪些参数，并且会得到哪些输出。我们在定义这些方法时，假如能确保他们的参数形式保持一致，那就更好了。这样对于习惯拿来主义的用户或我们自己，就更加的便利了。</p>

<p>具体的例子，比方说rails中的路由就是个这样的例子（从routes.rb文件的位置也可以看出它就是个配置文件），作者给我们定义好了一系列的方法，<code>get</code>，<code>post</code>，最有意思的就是<code>resource</code>。我们知道这些方法需要什么样的参数，能得到什么样的效果，假如我们不用这些配置，那么写上完整的路由控制代码，也能达到一样的目的。但是不需要，因为我们“很懒惰”。</p>

<h2 id="section-1">第三阶段，钩子</h2>
<p>如果你对于软件的使用者有足够的信心或信任，那么完全可以将一些接口留给用户来实现，软件中的钩子就是一个很好的例子，这在很多full-stack的框架中是很常见的，另一个场景是git的hook，在每个命令的前后，git都预留了钩子由用户来实现，这样它的可玩性就高了很多，到了github上，网站把很多常用的钩子打包成一个个模块，用户只需要给需要的模块打上勾就行了，这也可以称为配置的一种形式。</p>

<h2 id="section-2">第四阶段，可编程性</h2>
<p>这已经脱离了配置的范畴了，一些软件提供强大的api，用户通过这些api来拓展软件，甚至集成到软件本身。比如nginx使用lua来作为对单纯配置的拓展，实现了任何你所需要的功能。而github有一个很有意思的项目，叫做<a href="https://github.com/github/hubot">hubot</a>，是一个智能机器人项目，以消息的输入输出作为基本要素，用户可以加上任意的adapter，为hubot增加应答规则。其核心非常简单，但是众人拾柴火焰高，也许日久天长，这种基于规则库的低级智能，真的能发展成影响到每个人生活方方面面的智能管家。</p>

<h2 id="section-3">第五阶段，无配置文件</h2>
<p>从智能的话题延伸出去，既然软件本身需要具有智慧，那么为什么不能领悟它自己的需求，而要由人来给它写好配置？最起码，软件要能记忆曾经执行的过的操作，记录过的配置。</p>

<p>以两个monitor软件为例，’supervisor’是一款老牌的进程监控软件，由python写成，’pm2’是后起之秀，由nodejs写成，但是他们都不局限于监控python或nodejs进程，而可以做到全平台任意进程的监控。</p>

<p>假如初次使用这两款软件，更多的人会习惯于’supervisor’的操作方式，先写好一个配置文件，也许叫做<code>supervisor.conf</code>，定义好有哪些程序需要运行，执行文件的路径，环境变量，等等。然后我们敲下’supervisord start’来让这些进程运行起来，一切看起都很完美。</p>

<p>然后我们开始使用pm2，一开始会惊奇于它没有要求任何配置文件，你找到需要执行的文件，敲下<code>pm2 start app.js</code>，程序就开始执行，然后我们就可以通过<code>start|restart|reload|kill</code>等一系列命令操作这个进程。这个过程没有任何要求编写配置文件的步骤。</p>

<p>这怎么可能？我一开始的反应是这样，然后开始在各个目录中翻找所谓的’默认配置’，发现一无所获，后来我阅读了pm2的<a href="https://github.com/Unitech/pm2">源代码</a>，发现其实所有的配置，都在第一次启动进程的时候被忠实的记录下来。事情本该如此，既然第一次我已经告诉了软件需要的所有参数和变量，为什么有那么多的软件，还需要进行人为的干预来决定需要的参数，这不是一个优秀软件应该具备的素质。</p>

<p>我最近在修改一个在团队内部用了一段时间的部署工具<a href="https://github.com/sailxjx/sneaky">sneaky</a>。一直以来它都工作的很好，唯一的烦恼是在发布一个新项目前需要编写一段配置文件，填上发布的目标地址，端口，必要的时候再加上一些钩子。近期的一次更新已经将原本需要的5到6个配置项缩减到最少1个。下一步，当然是干掉配置文件。我们告诉它，把软件部署到某某服务器，然后到了下次，我们需要干同样的事时，软件已经比我们先知道它要做的事。这才是软件的未来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件极简主义]]></title>
    <link href="http://sailxjx.github.io/blog/blog/2013/09/17/ruan-jian-ji-jian-zhu-yi/"/>
    <updated>2013-09-17T21:03:00+08:00</updated>
    <id>http://sailxjx.github.io/blog/blog/2013/09/17/ruan-jian-ji-jian-zhu-yi</id>
    <content type="html"><![CDATA[<p>今天回家的路上，竟然刮起了大风，虽然骑行艰难，但是想想公交中的闷热，倒是觉得凉爽多了。</p>

<p>在路上的时间是无聊的，于是就喜欢胡思乱想，很多自以为很棒的点子其实都是在这种不经意间想到的，办公室里的久坐反而显得效率低下了。回味一下最近做的几个项目，高屋建瓴的想想当初的设计，突然很想写一些关于软件设计的文章。就着饮料和巧克力（来点酒么？），今天就来写写软件极简主义吧。</p>

<p>Google了一圈，也没找到对“软件极简主义”的定义，姑且当做是我的独创吧。一般认为“极简主义”是设计界的一种风潮，但是软件发展至今，好像也渐渐有了这样的趋势，甚至我认为这是未来的必然，我们经常听人说“flexible”这个词，字面上来看就是“灵活的”，但是具体到这个软件是否灵活，就不太好判断了。但是，简单的软件，一定是灵活的。</p>

<h2 id="section">极简主义的的大敌</h2>

<p>软件极简主义的三个大敌：配置文件，冗余的参数，和大量复杂的接口。</p>

<p>很多人热爱配置，迷恋配置，认为越多的配置项意味着软件越强大，适用范围越广，但这是九十年代的事了。实际我们仔细翻翻常用的软件，90%的配置都是多余，没有人明白他是做什么的，也没有人希望去改变他。比方很多软件的configure文件，常常能列出上百个配置项，但是我们真的需要这么多吗？不，我们需要默认的那些值就行了。何谓默认？因为软件的设计者觉得这些是最优化也最有可能被选择的配置，那么既然是最优配置，我们又有什么理由去改变他们？</p>

<p>再说说冗余的参数，linux中有一个非常强大的命令’tar’，从man文件看来他起码有二十来个参数，但是我真的需要这么多参数吗？其实我只要记住压缩是<code>-c</code>，解压是<code>-x</code>就可以了，那么何必为了1%的功能而去加上这99%的参数呢。</p>

<p>最后是复杂的接口，举个栗子，全文搜索引擎solr非常强大，能满足我们对于文档索引的各种需求。但是他使用起来可不简单，原因我想就是因为他那种sql式的查询接口，把一件很单纯的事情搞复杂了。我们来设想一下，需要找出包含某几个关键词的文章，必要的条件是什么？关键词，文档，没了。而文档是存储在服务器的，为什么我们提供了关键词之后，仍需加上各种条件，他才能告诉我们想要的答案呢？我想软件发展到一定的智能，他就应该像一部能说话的百科全书，提问，然后告诉我们答案即可。</p>

<p>凡事都要对比着看，所以我们找点软件来对比一下。</p>

<h2 id="redis--sql">redis 与 sql</h2>

<p>redis很灵巧，所有源代码加起来不满5M，但是他很强大，hash结构能取代我们80%对于sql的需求。他也有配置文件，但是选项很少，而且每一项都有详尽的注释，并且使用默认配置就可以应对大部分的情况。唯一值得诟病的就是他的接口种类繁多，但好在这些接口很有规律可循，你只需了解了redis的基础数据结构，那么跟着官网的文档就很容易搞懂所有接口的用途，而且大部分的接口都只接受3个以内的参数，这可好记多了。我刚接触redis的时候，只花了半个小时就能玩得起来，我想面对sql恐怕没人能这么轻松的掌握吧。</p>

<h2 id="cake--grunt">cake 与 grunt</h2>
<p><a href="https://github.com/jashkenas/coffee-script/blob/master/src/cake.coffee">cake</a>和<a href="https://github.com/gruntjs/grunt">grunt</a>是nodejs中两个管理任务的模块，后者的名声更大一些，前者甚至不能说是一个模块，他只是coffeescript中附带的一个小工具。我曾尝试使用grunt来做任务管理，但是当我看到grunt官网那长长的一段initConfig时，就望而却步了。就像是我希望在墙里敲个钉子，你却给了我一台破城锤。我只不过想要给每个任务起个名字方便我以后调用和查阅而已，所以cake的一行命令足矣。</p>

<h2 id="zmq--rabbitmq">zmq 与 rabbitmq</h2>
<p>zmq是我见过的最具有极简主义风格的软件（组件）。一方面他要面对的任务非常繁杂，在异步通信中所有我们可能遇到的情况，他都为我们考虑到了，但是他又将底层的复杂问题掩盖起来，让我们看到一个光滑的表面，深藏功与名。同样来看看他的同行rabbitmq，关键词：中心服务，多线程，模式单一，最后一个特点，慢！而仅有1.7M的zmq，快是最直观的感觉，而分布式和扩展性则是锦上添花。有人说zmq就像乐高积木，每个人都能搭出他想要的形状，这话一点都不错。</p>

<h2 id="section-1">不是结束的结语</h2>
<p>软件的设计日新月异，将来肯定会接触到更多优秀的软件，也许哪天我想法变了，也许哪天遇到了更神奇的方案，可能我会补充在这里。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于公司架构的一些吐槽]]></title>
    <link href="http://sailxjx.github.io/blog/blog/2013/07/12/guan-yu-gong-si-jia-gou-de-yi-xie-tu-cao/"/>
    <updated>2013-07-12T09:42:00+08:00</updated>
    <id>http://sailxjx.github.io/blog/blog/2013/07/12/guan-yu-gong-si-jia-gou-de-yi-xie-tu-cao</id>
    <content type="html"><![CDATA[<p>写了这么多文章，技术屌丝味太浓了，以前每次想写点随想也是<a href="/blog/2012/07/29/jing-ji-de-le-qu/">起了个标题就没下文了</a>，正好今天早上看到了一篇<a href="http://www.36kr.com/p/204557.html">喷技术创业的文章</a>，文中观点不敢苟同，趁着早晨清醒的时刻，咱也文艺范一次，写点有感而发的文字。</p>

<p>很多公司，无论大小，都想将部门划分的细之又细。所谓麻雀虽小，五脏俱全。随意拉一张公司的组织结构图出来看看 – 总裁办，行政部，人力资源部，技术部，产品部，市场部，客服部，运营部。。。别人有的我们就得有，别人没有的我们也得有，不论有些部门是不是必须，只要一两个人也能成立个部门。不明真相的人跑来一看，瞧，多正规，高端洋气上档次。</p>

<p>且不论其他职能部门，我就来说说跟研发关系最大的一些部门，以及如何显得他们的工作是不可或缺的。</p>

<h2 id="section">产品部</h2>

<p>产品部本身就是一个比较扯的部门，因为这个词打击面太大，整天挖空心思想点子的，想的是不是产品？没日没夜扣腚的，做的是不是产品？上线后胆战心惊监测的，维护的是不是产品？我们尊崇’less is more’，谁也说不清产品到底是个啥玩意，但是就有这样一个部门，叫做“产品部”。</p>

<p>再回到<a href="http://www.36kr.com/p/204557.html">这篇文章</a>的观点，技术人员过于注重技术，而忽略了对产品的思考，所以需要专门设置这样一个产品经理的职位来构思整个产品的走向。看似有理，但是他的前提是“技术人员不会思考产品”，这就是一个弥天大谎，我见过的大部分技术人员，对于项目的细节，业务逻辑的理解都比普通产品高出不知道多少个档次，我们不能纸上谈兵，只有真正理解了产品实现的业务逻辑，才能提出更有建设性和创新性的意见，这叫站在巨人的肩膀上。但是我看到的很多产品是，进入公司一个礼拜都不到，以前从来没有用过公司的产品，就能洋洋洒洒写出一大篇设计文档来，而问到为什么要这样改，则又支支吾吾，说不出个所以然，最后来一句我看到某某网站也是这样做的，所以我们也要这样做。</p>

<p>回到技术人员的自我修养上来，我认为每个研发应该视自己开发的产品如孩子一般，在关注技术进步之余，能花时间来培养这个孩子，让其更健壮，更优雅，更招人待见。同时，也要多看看外面的世界，试用别人的产品，包括竞争对手的，以和自己创造的孩子进行对比。技术人员提出的产品改进意见往往更务实，更切中要害。</p>

<p>将这种视如己出的概念再推广到所有员工身上，其实人人都可以为产品添砖加瓦出谋划策，那么，产品部门存在的价值何在？</p>

<h2 id="section-1">测试部</h2>

<p>测试可以分为好多类：1.做黑盒的。2.做白盒的。3.自动化测试。
我们一一道来。</p>

<p>先说第一种，做黑盒的。很多公司曲解了黑盒的意思，认为做黑盒就是一个功能开发好了，你拿去用，不出问题就行了。这样就把软件开发变成了一个劳动密集型行业，这样的测试与拿到内测账号的用户有什么区别。更何况我们有些测试人员的使用经验可能还不如用户。这样的测试，效率既低下，效果还不明显。</p>

<p>再说第二种，做白盒的。一些公司有白盒测试，其实就是看看代码。很多公司认为，这个人写代码不行，就让他做测试吧。这是一个大大的误区，对测试人员的要求应该比研发更高，因为我认为<a href="http://blogs.msdn.com/b/ericlippert/archive/2004/06/14/reading-code-is-hard.aspx">读代码往往比写代码更难</a>。上面这种做法的后果就是，一些人做白盒测试的时候，一旦看到不明白的地方，就跑来问研发，需要研发手把手的一条条教来，这不光是浪费双方的时间，也是在做无用功。我相信任意一个合格的研发人员，在提测之前应该都对代码做完整细致的自测。</p>

<p>最后说说第三种，做自动化测试的。这个其实要求较高，很多公司没有，即使有也是认为装个hudson写写配置文件就算自动化测试了。而我认为的自动化测试应该有很强的编码能力，能写出简单有效的单元测试用例，能配置不同的运行环境来确保软件的跨平台性，能进行性能测试，来保证软件的工作效率。这都对测试人员提出了较高的要求，这种人少之又少，而我见到的大多数测试人员连apache的vhost文件都不会写。</p>

<p>真正的测试人员应该得到相当的尊敬，因为他们需要对业务和代码都有很深的理解，他们比程序员更细心，既能防止程序员犯一些低级的错误，又能在一些容易忽略的问题是上保持警惕。</p>

<p>假如找不到这样合适的测试人员，测试部就没有存在的意义。</p>

<h2 id="ued">UED部</h2>

<p>UED这个词是个舶来品，你甚至很难找到合适的中文替代词，只能用“用户体验”这种虚无缥缈的词来囊括。很多公司的UED，其实就是美工。</p>

<p>我自认为对设计和绘画不在行，所以我很尊重设计师的工作。设计师负责原型和效果设计，程序员负责实现，这是由人的左右半脑分工决定的，而且一个好的设计师，简而美的设计，应该是先在公司内部群体中产生认同感，才能让更多的用户认可。</p>

<p>下面是我的吐槽，一些我见过的设计师，可能读过一本<a href="http://book.douban.com/subject/1440223/">Don’t Make Me Think</a>，就能自诩得到了设计的精髓，接着就对页面开始做大刀阔斧的改革，也不需要其他人的意见，因为设计师都有一些自负天才的心理在作怪（嗯，其实程序员也有）。更有甚者，是一天一小改，三天一大改，也没有统一的风格，去别的网站东边抄一块，西边抄一块，就变成了咱家的东西。别人做瀑布流，我们也搞瀑布流，别人做下拉刷新，我们也用下拉刷新，可是从来没有独创的功能被人认可，这也是“一直在模仿，从未被超越”的典型了。</p>

<p>再说到“用户体验”这个词上，世界上恐怕再也找不到这样一个百搭的词了。一个按钮加大点可以叫用户体验，换个字体也叫用户体验，但是众口难调，<a href="http://lesswrong.com/lw/dr/generalizing_from_one_example/">人的大脑是很奇怪的</a>，你喜欢的未必是人家喜欢的。所以真正需要做到的是在公司这个小范围内赢得众人的认同，然后将风格延续下去，这样才能让更多的用户接受乃至迷恋这种风格。有个很成功的例子就是苹果。</p>

<p>这里又要说到关于设计师和程序员两类人的区别了。我认为一个好的设计师和一个好的程序员应该是可以互补并相互学习的。我以前的一个研发经理，技术上肯定是毋庸置疑的，但是也做得一手好画，从鼠绘到原型到效果图，无所不能。这样的人才非常难得，但并不是没有，一个诸葛亮是远远高于三个臭皮匠的。而更多的人可以在学习中达到这个高度。</p>

<h2 id="section-2">理想中的组织架构</h2>

<p>任何组织发展壮大之后，人员就会变得复杂，管理难度相应也会增大。职场如战场，公司就是一个缩小的社会，我们不妨就从历史中找个例子出来。清廷倒台之前，曾有一番关于“共和”还是“立宪”的争论，两派人争得不可开交，最后的结果我们知道，共和派取得了胜利。</p>

<p>“共和”和“立宪”的根本区别还是权力集中在何处。相比帝制的独裁，“立宪”在名义上是说君主也要遵纪守法，权力还是集中于小部分人（真正的“立宪”君主只是个象征，内阁还是要选举的）。而“共和”则将权力下放于大众，政府则是大众意志的集中。</p>

<p>开源软件的圣经<a href="http://en.wikipedia.org/wiki/The_Cathedral_and_the_Bazaar">《大教堂与市集》</a>其实也表达了这样一种思想。软件开发由自上而下的瀑布流发展到今天的开源模式，最有代表性的就是<a href="http://scottchacon.com/2011/08/31/github-flow.html">github flow</a>。就是任何人都有权利对产品提出改进意见，并且可以亲自来实现这些功能，而项目的管理者(owner)在更新自己的产品之余，还需要接受来自四面八方的(pull request)。owner有权力决定这些功能的加入，也有义务鉴定这个功能的风险。</p>

<p>同样对公司的管理也是这样，权力不应该集中于个人，每个员工都应该有发言权。每个员工都应该有自由发挥的空间，来实现自己需要的功能。同时也不能忽略了合作的重要性，所以在日常的工作中，需要三两人一组，作为一个cell，可以是同一个部门中志同道合的人，也可以是不同部门中可以互补的人(比如设计师和程序员)。以cell为最小单位，来完成每个任务。最基本的目标：追求效率，追求自我提高，追求快乐工作。</p>

<p>这对个人也是有要求的，就是每个人都需要能独当一面。我想谁都不会愿意与一个一无所知和整日拖沓的同事合作吧（MM除外）。同时，管理层(owner)的责任就是协调cell之间的工作，有权力决定cell提出的功能的去留，也有义务听取大家的意见。</p>

<p>这也是我觉得创业公司比大公司好的一个原因，就是你有决定权，或者能将意见直接反馈到管理层，而不需要经过大公司死板结构的层层汇报。同样，这样的办事效率也是很多公司望尘莫及的。赠人玫瑰手有余香，以开放的心态接受他人，那么他人也会以同样的姿态来回报你。</p>

<p>最后贴一个豆瓣上的小段子，娱乐一下。<a href="http://www.douban.com/note/157604143/">不同部门员工吃饭时聊些什么</a>。</p>
]]></content>
  </entry>
  
</feed>
