<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: awk | CodeBean]]></title>
  <link href="http://sailxjx.github.com/blog/blog/categories/awk/atom.xml" rel="self"/>
  <link href="http://sailxjx.github.com/blog/"/>
  <updated>2013-03-13T17:17:45+08:00</updated>
  <id>http://sailxjx.github.com/blog/</id>
  <author>
    <name><![CDATA[tristan]]></name>
    <email><![CDATA[sailxjx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[awk 学习笔记(2)]]></title>
    <link href="http://sailxjx.github.com/blog/blog/2013/01/21/awk-xue-xi-bi-ji-2/"/>
    <updated>2013-01-21T17:42:00+08:00</updated>
    <id>http://sailxjx.github.com/blog/blog/2013/01/21/awk-xue-xi-bi-ji-2</id>
    <content type="html"><![CDATA[<h2>常用的选项</h2>

<ul>
<li>-F 指定分隔符</li>
<li>-f 指定调用脚本，可以多次引用，不同文件会被合并成一个awk脚本</li>
<li>-d 输出所有变量到文件，默认输出到awkvars.out，也可以通过在-d后加文件路径来指定文件，但是注意-d与文件名之间不能有空格。调试的时候这个选项会非常有用。
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk -d./awk.dump <span class="s1">&#39;BEGIN { foo = &quot;test&quot; } /&lt;sup&gt;foo/&lt;/sup&gt; { print $0 }&#39;</span> BBS-list
</span><span class='line'><span class="nv">$ </span>cat ./awk.dump
</span><span class='line'>ARGC: 2
</span><span class='line'>ARGIND: 1
</span><span class='line'>ARGV: array, 2 elements
</span><span class='line'>foo: <span class="s2">&quot;test&quot;</span>
</span><span class='line'>...
</span></code></pre></td></tr></table></div></figure></notextile></div></li>
<li>-p 将命令行下的awk脚本格式化输出到awkprof.out文件，可以在-p后加文件路径来指定文件，注意也不能有空格</li>
<li>-v 预设置awk程序变量，可以设置多次</li>
</ul>


<h2>分隔符的四种形式</h2>

<ul>
<li><code>-F " "</code>      默认，以空格或tab分隔，首尾的空格会被排除掉</li>
<li><code>-F "a"</code>      以普通字符串分隔，用户指定</li>
<li><code>-F "[: ]"</code>   以正则表达式分隔，一般在设定多个分隔符时比较有用（如右边就是按<code>:</code>或空格分隔）</li>
<li><code>-F ""</code>       每个字符都是单独的一列，只在gawk中支持</li>
</ul>


<h2>@include</h2>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="err">@</span><span class="o">in</span><span class="nx">clude</span> <span class="s1">&#39;./libfoo.awk&#39;</span>
</span><span class='line'><span class="nx">END</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kr">print</span> <span class="s2">&quot;end of file&quot;</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>多行记录</h2>

<p>有些文件中相关联的数据可能会分为多行显示，<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Multiple-Line">看手册中的例子</a>
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Jane Doe
</span><span class='line'>123 Main Street
</span><span class='line'>Anywhere, SE 12345-6789&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>John Smith
</span><span class='line'>456 Tree-lined Avenue
</span><span class='line'>Smallville, MW 98765-4321</span></code></pre></td></tr></table></div></figure></notextile></div>
很明显每个块中的数据是有联系的，然后每个块都以一行空字符分割，那么分析的awk脚本可以写成这样。
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="nx">BEGIN</span> <span class="p">{</span> <span class="nb">RS</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="p">;</span> <span class="nb">FS</span> <span class="o">=</span> <span class="s2">&quot;\n&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kr">print</span> <span class="s2">&quot;Name is:&quot;</span><span class="p">,</span> <span class="o">$</span><span class="mi">1</span>
</span><span class='line'><span class="kr">print</span> <span class="s2">&quot;Address is:&quot;</span><span class="p">,</span> <span class="o">$</span><span class="mi">2</span>
</span><span class='line'><span class="kr">print</span> <span class="s2">&quot;City and State are:&quot;</span><span class="p">,</span> <span class="o">$</span><span class="mi">3</span>
</span><span class='line'><span class="kr">print</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
这里的RS也是支持正则表达式的</p>

<h2>格式化控制符</h2>

<p>OFMT与printf中用到的格式化控制符可以参考c中的printf，具体可以<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Control-Letters">参考手册</a></p>

<h2>I/O</h2>

<p>awk可以用<code>&gt;</code>,<code>&gt;&gt;</code>,<code>|</code>将输出定向到文件或管道，但需要注意的是后面的文件名或命令都需要用双引号包起来。</p>

<h2>switch</h2>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>top -bn1|grep java|grep -v grep|awk <span class="s1">&#39;{ switch ($6) { case /m$/: print $6*1024;break; default: print $6; } }&#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
switch语句与C中相同，注意break的使用。此外，在兼容模式下不可用。</p>

<h2>man tag</h2>

<p><a href="http://www.gnu.org/software/gawk/manual/gawk.html#Special-Files">Special-Files</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[awk 学习笔记(1)]]></title>
    <link href="http://sailxjx.github.com/blog/blog/2013/01/16/awk-xue-xi-bi-ji-1/"/>
    <updated>2013-01-16T21:46:00+08:00</updated>
    <id>http://sailxjx.github.com/blog/blog/2013/01/16/awk-xue-xi-bi-ji-1</id>
    <content type="html"><![CDATA[<h2>第一个awk程序</h2>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;!</span><span class="err">/bin/awk -f&lt;/h1&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kr">print</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这个程序会将所有的输入原封不动的输出，直到EOF(ctrl+d)</p>

<h2>在shell中使用awk</h2>

<h3>命令行</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk <span class="s1">&#39;BEGIN { print &quot;Here is a single quote &amp;lt;&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;&gt;&quot; }&#39;</span>
</span><span class='line'>Here is a single quote &amp;lt;<span class="err">&#39;</span>&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>需要注意的是，在命令行下引号的嵌套可能会造成一些难以预料的错误，假如在awk脚本内需要用到单引号，那就在它之前使用转义符<code>\</code>，并且不要忘了用另一个单引号结束它前面的字符，就上上面做的那样，实际分成了三段awk脚本，shell将他们链接起来之后实际就成了<code>BEGIN { print "Here is a single quote &lt;'&gt;" }</code>。</p>

<h3>在shell文件中</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">FIND_DATA</span><span class="o">=</span><span class="k">$(</span>awk <span class="s1">&#39;</span>
</span><span class='line'><span class="s1">BEGIN {&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="s1">&lt;pre&gt;&lt;code&gt;print &quot;here is a single quote &amp;lt;&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;&amp;gt;&quot;</span>
</span><span class='line'><span class="s1">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="s1">&lt;p&gt;}</span>
</span><span class='line'><span class="s1">&#39;</span><span class="k">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>有的时候awk会写的很长，这个时候需要换行，直接用单引号两边包住即可，注意脚本中的单引号还是需要转义的。</p>

<h2>使用正则表达式</h2>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk <span class="s1">&#39;/&lt;sup&gt;foo/&lt;/sup&gt; { print $0 }&#39;</span> BBS-list
</span><span class='line'><span class="nv">$ </span>awk <span class="s1">&#39;/&lt;sup&gt;foo/&lt;/sup&gt; { print $0 }&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="s1">&lt;blockquote&gt;&lt;p&gt;/foo/ { print $0 }&#39;</span> BBS-list
</span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote>

<p>上面的命令在BBS-list中匹配出所有以<code>foo</code>开头的行，多个表达式可以用在同一行上，会将匹配结果打印在不同行上。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk <span class="s1">&#39;{ if($1 ~ /foo$/) print $0 }&#39;</span> BBS-list
</span><span class='line'>macfoo       555-6480     1200/300          A
</span><span class='line'>sabafoo      555-2127     1200/300          C
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在变量上使用正则表达式，使用<code>~</code>或<code>!~</code>符号，能满足多数的应用。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk <span class="s1">&#39;{ REGEXP = &quot;&lt;sup&gt;foo&quot;;&lt;/sup&gt; if($1 ~ REGEXP) print $0 }&#39;</span> BBS-list
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>动态的设置正则表达式，变量中需要省去两边的<code>/</code>。</p>

<h2>BEGIN/END</h2>

<p>开头和结尾的两块表达式，可以用来做一些全局参数设定和数据统计。</p>

<h2>有用的内置参数</h2>

<ul>
<li>FS            定义分隔符</li>
<li>OFS           定义输出分隔符</li>
<li>NF            列数</li>
<li>NR            行号</li>
<li>RS            输入条目分隔符，awk按这个字符来将整个文本分成不同条记录(默认为"\n")</li>
<li>ORS           输出条目分隔符</li>
<li>IGNORECASE=1  忽略大小写(只支持gawk)</li>
<li>FIELDWIDTHS   指定每列的宽度(只支持gawk)，实际场景中貌似用处不大，除非原文本的格式本身就非常工整(每个field的字符数相等)，下面是<code>FS</code>变量可能会影响<code>FIELDWIDTHS</code>的地方
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk <span class="s1">&#39;BEGIN{FS = &quot;a&quot;;FIELDWIDTHS= &quot;4 4&quot;}{print $1, FS}&#39;</span> BBS-list <span class="c"># FS不生效</span>
</span><span class='line'><span class="nv">$ </span>awk <span class="s1">&#39;BEGIN{FIELDWIDTHS= &quot;4 4&quot;;FS = &quot;a&quot;}{print $1, FS}&#39;</span> BBS-list <span class="c"># FIELDWIDTHS不生效</span>
</span><span class='line'><span class="nv">$ </span>awk -Fa <span class="s1">&#39;BEGIN{FIELDWIDTHS= &quot;4 4&quot;}{print $1, FS}&#39;</span> BBS-list <span class="c"># FS不生效</span>
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;总而言之，就是哪个在后，哪个就优先。&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div></p></li>
<li>PROCINFO      内置数组，用于记录一些程序信息，包括分隔符类型，进程号，用户组等等</li>
<li>FPAT          gawk特有的一个变量，不能与FS，FIELDWIDTHS共存，利用正则匹配出对应的field，手册中给出了一个常用的例子，匹配csv文件，<code>awk -vFPAT="([^,]+)|(\"[^\"]+\")" '{print "NF=",NF; for(i =1 ;i&lt;NF;i++){print $i}}' str.csv</code>，不过这种写法不够直观，也容易出错，用来应急可以，真刀真枪的干，还是求助其他语言吧</li>
<li>OFMT          输出格式，默认为<code>%.6g</code>，这在格式化数字时比较有效，例如用<code>%.1f</code>就是输出四舍五入后的一位小数，而用<code>%i</code>就是输出整数了。</li>
</ul>


<h2>有用的方法</h2>

<ul>
<li>length($1)    计算字符串或数组长度</li>
<li>srand()       生成随机数种子</li>
<li>rand()        生成一个浮点随机数，需要跟srand配合</li>
<li>tolower()     转小写</li>
<li>toupper()     转大写</li>
<li>sub()         <code>$ awk '{ sub(/foo/, "FOO"); print }' BBS-list</code>将foo字符串替换成FOO。</li>
</ul>

]]></content>
  </entry>
  
</feed>
