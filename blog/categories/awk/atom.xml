<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: awk | CodeBean]]></title>
  <link href="http://sailxjx.github.com/blog/blog/categories/awk/atom.xml" rel="self"/>
  <link href="http://sailxjx.github.com/blog/"/>
  <updated>2013-05-03T16:56:06+08:00</updated>
  <id>http://sailxjx.github.com/blog/</id>
  <author>
    <name><![CDATA[tristan]]></name>
    <email><![CDATA[sailxjx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[awk 学习笔记(3)]]></title>
    <link href="http://sailxjx.github.com/blog/blog/2013/04/17/awk-xue-xi-bi-ji-3/"/>
    <updated>2013-04-17T16:11:00+08:00</updated>
    <id>http://sailxjx.github.com/blog/blog/2013/04/17/awk-xue-xi-bi-ji-3</id>
    <content type="html"><![CDATA[<p>最近线上服务出了一点问题，然后搞了一堆的log来分析。log的格式很乱，需要整理一下，虽然几个月前特意看了一下awk，但是过了这么久，也忘得差不多了，正好靠这次机会练练手，把失去的记忆找回来。</p>

<p>log中的每条数据都被分成了多行，而且都存在一个文件中，现在文件已经有8G的大小。现在要做的就是将这些多行的数据合并成每条一行，只取有用的部分。</p>

<p>目标明确之后，就是编码啦。</p>

<p>先以日期开头的行为单条数据的起点，这个日期就通过正则来匹配出来，然后再通过substr来截取。在使用substr的时候貌似awk不支持负数输入，没办法，截取末尾字符的时候只能先计算整行的长度再减去要截取的长度了。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">$</span><span class="mi">0</span> <span class="o">~</span> <span class="sr">/^2013.*[0-9]’$/</span><span class="p">)</span> <span class="p">{</span>  <span class="c1"># id line</span>
</span><span class='line'>        <span class="nx">len</span> <span class="o">=</span> <span class="kr">length</span><span class="p">(</span><span class="o">$</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">date</span> <span class="o">=</span> <span class="kr">substr</span><span class="p">(</span><span class="o">$</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">line</span> <span class="o">=</span> <span class="kr">substr</span><span class="p">(</span><span class="o">$</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">19</span><span class="p">)</span> <span class="kr">substr</span><span class="p">(</span><span class="o">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">len</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>awk中的字符串连接也比较搞，不需要<code>+,.</code>等等符号，直接接上就好了，中间可以加上” “来分隔。</p>

<p>下面就是将每行的匹配数据加到line变量后面，最后，一起print出来，这里重定向到文件也是一个不错的选择</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">$</span><span class="mi">0</span> <span class="o">~</span> <span class="sr">/[template]/</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">line</span> <span class="o">=</span> <span class="nx">line</span><span class="err">”</span> <span class="err">“</span><span class="o">$</span><span class="mi">3</span>
</span><span class='line'>        <span class="kr">print</span> <span class="nx">line</span><span class="err"> »</span> <span class="err">“</span><span class="nx">desc</span><span class="p">.</span><span class="kr">log</span><span class="p">.</span><span class="err">”</span><span class="nx">date</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>下面还有一个需求就是根据统计类似数据再排排序，awk的数组可以实现统计关键词出现的次数，不过它数组的排序功能实在是太弱了，所以还需要结合sort命令。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk ‘<span class="o">{</span>a<span class="o">[</span><span class="nv">$4</span><span class="o">]</span> +<span class="o">=</span> 1<span class="o">}</span>END<span class="o">{</span><span class="k">for</span> <span class="o">(</span>k in a<span class="o">)</span> print a<span class="o">[</span>k<span class="o">]</span>, k<span class="o">}</span>’ <span class="nv">$i</span> | sort -rn &amp;gt; “emailsort_<span class="k">${</span><span class="nv">i</span><span class="k">}</span>”
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>大功告成。</p>

<p>下面整理一下笔记，总结一下用到的东西</p>

<ul>
  <li>正则表达式： 根据gawk的官方文档，原版貌似不支持所谓的<code>interval expression</code>，也就是一些<code>\w</code>,<code>\d</code>之类的东西，实际也确实如此，gawk对它进行了扩展，加上<code>--re-interval</code>之后就行了。</li>
  <li>substr： 截取字符串</li>
  <li><code>&gt;,&gt;&gt;</code>： 重定向，跟shell一样，不过后面的文件名需要加上双引号</li>
  <li>数组： 数组的遍历使用<code>for(k in a) print k</code>的方式，排序有asort方法，不过这样排序之后key就全部丢掉了，我还是倾向于选择通过管道让<code>sort</code>来干这事。</li>
</ul>

<h2 id="link-to">Link to</h2>
<ul>
  <li><a href="/blog/2013/01/16/awk-xue-xi-bi-ji-1/">awk学习笔记1</a></li>
  <li><a href="/blog/2013/01/21/awk-xue-xi-bi-ji-2/">awk学习笔记2</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[awk 学习笔记(2)]]></title>
    <link href="http://sailxjx.github.com/blog/blog/2013/01/21/awk-xue-xi-bi-ji-2/"/>
    <updated>2013-01-21T17:42:00+08:00</updated>
    <id>http://sailxjx.github.com/blog/blog/2013/01/21/awk-xue-xi-bi-ji-2</id>
    <content type="html"><![CDATA[<h2 id="section">常用的选项</h2>
<ul>
  <li>-F 指定分隔符</li>
  <li>-f 指定调用脚本，可以多次引用，不同文件会被合并成一个awk脚本</li>
  <li>-d 输出所有变量到文件，默认输出到awkvars.out，也可以通过在-d后加文件路径来指定文件，但是注意-d与文件名之间不能有空格。调试的时候这个选项会非常有用。
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk -d./awk.dump ‘BEGIN <span class="o">{</span> <span class="nv">foo</span> <span class="o">=</span> “test” <span class="o">}</span> /^foo/ <span class="o">{</span> print <span class="nv">$0</span> <span class="o">}</span>’ BBS-list
</span><span class='line'><span class="nv">$ </span>cat ./awk.dump
</span><span class='line'>ARGC: 2
</span><span class='line'>ARGIND: 1
</span><span class='line'>ARGV: array, 2 elements
</span><span class='line'>foo: “test”
</span><span class='line'>…
</span></code></pre></td></tr></table></div></figure></notextile></div></li>
  <li>-p 将命令行下的awk脚本格式化输出到awkprof.out文件，可以在-p后加文件路径来指定文件，注意也不能有空格</li>
  <li>-v 预设置awk程序变量，可以设置多次</li>
</ul>

<h2 id="section-1">分隔符的四种形式</h2>
<ul>
  <li><code>-F " "</code>      默认，以空格或tab分隔，首尾的空格会被排除掉</li>
  <li><code>-F "a"</code>      以普通字符串分隔，用户指定</li>
  <li><code>-F "[: ]"</code>   以正则表达式分隔，一般在设定多个分隔符时比较有用（如右边就是按<code>:</code>或空格分隔）</li>
  <li><code>-F ""</code>       每个字符都是单独的一列，只在gawk中支持</li>
</ul>

<h2 id="include">@include</h2>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="err">@</span><span class="o">in</span><span class="nx">clude</span> <span class="err">‘</span><span class="p">.</span><span class="o">/</span><span class="nx">libfoo</span><span class="p">.</span><span class="nx">awk</span><span class="err">’</span>
</span><span class='line'><span class="nx">END</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">print</span> <span class="err">“</span><span class="nx">end</span> <span class="nx">of</span> <span class="nx">file</span><span class="err">”</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2 id="section-2">多行记录</h2>
<p>有些文件中相关联的数据可能会分为多行显示，<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Multiple-Line">看手册中的例子</a>
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Jane Doe
</span><span class='line'>123 Main Street
</span><span class='line'>Anywhere, SE 12345-6789&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>John Smith
</span><span class='line'>456 Tree-lined Avenue
</span><span class='line'>Smallville, MW 98765-4321</span></code></pre></td></tr></table></div></figure></notextile></div>
很明显每个块中的数据是有联系的，然后每个块都以一行空字符分割，那么分析的awk脚本可以写成这样。
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="nx">BEGIN</span> <span class="p">{</span> <span class="nb">RS</span> <span class="o">=</span> <span class="err">“”</span> <span class="p">;</span> <span class="nb">FS</span> <span class="o">=</span> <span class="err">“\</span><span class="nx">n</span><span class="err">”</span> <span class="p">}</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kr">print</span> <span class="err">“</span><span class="nx">Name</span> <span class="nx">is</span><span class="err">:”</span><span class="p">,</span> <span class="o">$</span><span class="mi">1</span>
</span><span class='line'>    <span class="kr">print</span> <span class="err">“</span><span class="nx">Address</span> <span class="nx">is</span><span class="err">:”</span><span class="p">,</span> <span class="o">$</span><span class="mi">2</span>
</span><span class='line'>    <span class="kr">print</span> <span class="err">“</span><span class="nx">City</span> <span class="nx">and</span> <span class="nx">State</span> <span class="nx">are</span><span class="err">:”</span><span class="p">,</span> <span class="o">$</span><span class="mi">3</span>
</span><span class='line'>    <span class="kr">print</span> <span class="err">“”</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
这里的RS也是支持正则表达式的</p>

<h2 id="section-3">格式化控制符</h2>
<p>OFMT与printf中用到的格式化控制符可以参考c中的printf，具体可以<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Control-Letters">参考手册</a></p>

<h2 id="io">I/O</h2>
<p>awk可以用<code>&gt;</code>,<code>&gt;&gt;</code>,<code>|</code>将输出定向到文件或管道，但需要注意的是后面的文件名或命令都需要用双引号包起来。</p>

<h2 id="switch">switch</h2>
<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>top -bn1|grep java|grep -v grep|awk ‘<span class="o">{</span> switch <span class="o">(</span><span class="nv">$6</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> /m<span class="nv">$/</span>: print <span class="nv">$6</span>*1024;break; default: print <span class="nv">$6</span>; <span class="o">}</span> <span class="o">}</span>’
</span></code></pre></td></tr></table></div></figure></notextile></div>
switch语句与C中相同，注意break的使用。此外，在兼容模式下不可用。</p>

<h2 id="man-tag">man tag</h2>
<p><a href="http://www.gnu.org/software/gawk/manual/gawk.html#Special-Files">Special-Files</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[awk 学习笔记(1)]]></title>
    <link href="http://sailxjx.github.com/blog/blog/2013/01/16/awk-xue-xi-bi-ji-1/"/>
    <updated>2013-01-16T21:46:00+08:00</updated>
    <id>http://sailxjx.github.com/blog/blog/2013/01/16/awk-xue-xi-bi-ji-1</id>
    <content type="html"><![CDATA[<h2 id="awk">第一个awk程序</h2>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="c1">#!/bin/awk -f</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kr">print</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这个程序会将所有的输入原封不动的输出，直到EOF(ctrl+d)</p>

<h2 id="shellawk">在shell中使用awk</h2>

<h3 id="section">命令行</h3>
<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk ‘BEGIN <span class="o">{</span> print “Here is a single quote &amp;lt;’<span class="err">&#39;</span>’&amp;gt;” <span class="o">}</span>’
</span><span class='line'>Here is a single quote &amp;lt;’&amp;gt;
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>需要注意的是，在命令行下引号的嵌套可能会造成一些难以预料的错误，假如在awk脚本内需要用到单引号，那就在它之前使用转义符<code>\</code>，并且不要忘了用另一个单引号结束它前面的字符，就上上面做的那样，实际分成了三段awk脚本，shell将他们链接起来之后实际就成了<code>BEGIN { print "Here is a single quote &lt;'&gt;" }</code>。</p>

<h3 id="shell">在shell文件中</h3>
<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">FIND_DATA</span><span class="o">=</span><span class="k">$(</span>awk ‘
</span><span class='line'>BEGIN <span class="o">{</span>
</span><span class='line'>    print “here is a single quote &amp;lt;’<span class="err">&#39;</span>’&amp;gt;”
</span><span class='line'><span class="o">}</span>
</span><span class='line'>‘<span class="k">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>有的时候awk会写的很长，这个时候需要换行，直接用单引号两边包住即可，注意脚本中的单引号还是需要转义的。</p>

<h2 id="section-1">使用正则表达式</h2>
<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk ‘/^foo/ <span class="o">{</span> print <span class="nv">$0</span> <span class="o">}</span>’ BBS-list
</span><span class='line'><span class="nv">$ </span>awk ‘/^foo/ <span class="o">{</span> print <span class="nv">$0</span> <span class="o">}</span>
</span><span class='line'>&amp;gt; /foo/ <span class="o">{</span> print <span class="nv">$0</span> <span class="o">}</span>’ BBS-list
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上面的命令在BBS-list中匹配出所有以<code>foo</code>开头的行，多个表达式可以用在同一行上，会将匹配结果打印在不同行上。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk ‘<span class="o">{</span> <span class="k">if</span><span class="o">(</span><span class="nv">$1</span> ~ /foo<span class="nv">$/</span><span class="o">)</span> print <span class="nv">$0</span> <span class="o">}</span>’ BBS-list
</span><span class='line'>macfoo       555-6480     1200/300          A
</span><span class='line'>sabafoo      555-2127     1200/300          C
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在变量上使用正则表达式，使用<code>~</code>或<code>!~</code>符号，能满足多数的应用。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk ‘<span class="o">{</span> <span class="nv">REGEXP</span> <span class="o">=</span> “^foo”; <span class="k">if</span><span class="o">(</span><span class="nv">$1</span> ~ REGEXP<span class="o">)</span> print <span class="nv">$0</span> <span class="o">}</span>’ BBS-list
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>动态的设置正则表达式，变量中需要省去两边的<code>/</code>。</p>

<h2 id="beginend">BEGIN/END</h2>

<p>开头和结尾的两块表达式，可以用来做一些全局参数设定和数据统计。</p>

<h2 id="section-2">有用的内置参数</h2>
<ul>
  <li>FS            定义分隔符</li>
  <li>OFS           定义输出分隔符</li>
  <li>NF            列数</li>
  <li>NR            行号</li>
  <li>RS            输入条目分隔符，awk按这个字符来将整个文本分成不同条记录(默认为”\n”)</li>
  <li>ORS           输出条目分隔符</li>
  <li>IGNORECASE=1  忽略大小写(只支持gawk)</li>
  <li>FIELDWIDTHS   指定每列的宽度(只支持gawk)，实际场景中貌似用处不大，除非原文本的格式本身就非常工整(每个field的字符数相等)，下面是<code>FS</code>变量可能会影响<code>FIELDWIDTHS</code>的地方
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>awk ‘BEGIN<span class="o">{</span><span class="nv">FS</span> <span class="o">=</span> “a”;FIELDWIDTHS<span class="o">=</span> “4 4”<span class="o">}{</span>print <span class="nv">$1</span>, FS<span class="o">}</span>’ BBS-list <span class="c"># FS不生效</span>
</span><span class='line'><span class="nv">$ </span>awk ‘BEGIN<span class="o">{</span><span class="nv">FIELDWIDTHS</span><span class="o">=</span> “4 4”;FS <span class="o">=</span> “a”<span class="o">}{</span>print <span class="nv">$1</span>, FS<span class="o">}</span>’ BBS-list <span class="c"># FIELDWIDTHS不生效</span>
</span><span class='line'><span class="nv">$ </span>awk -Fa ‘BEGIN<span class="o">{</span><span class="nv">FIELDWIDTHS</span><span class="o">=</span> “4 4”<span class="o">}{</span>print <span class="nv">$1</span>, FS<span class="o">}</span>’ BBS-list <span class="c"># FS不生效</span>
</span><span class='line'><span class="c"># 总而言之，就是哪个在后，哪个就优先。</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></li>
  <li>PROCINFO      内置数组，用于记录一些程序信息，包括分隔符类型，进程号，用户组等等</li>
  <li>FPAT          gawk特有的一个变量，不能与FS，FIELDWIDTHS共存，利用正则匹配出对应的field，手册中给出了一个常用的例子，匹配csv文件，<code>awk -vFPAT="([^,]+)|(\"[^\"]+\")" '{print "NF=",NF; for(i =1 ;i&lt;NF;i++){print $i}}' str.csv</code>，不过这种写法不够直观，也容易出错，用来应急可以，真刀真枪的干，还是求助其他语言吧</li>
  <li>OFMT          输出格式，默认为<code>%.6g</code>，这在格式化数字时比较有效，例如用<code>%.1f</code>就是输出四舍五入后的一位小数，而用<code>%i</code>就是输出整数了。</li>
</ul>

<h2 id="section-3">有用的方法</h2>
<ul>
  <li>length($1)    计算字符串或数组长度</li>
  <li>srand()       生成随机数种子</li>
  <li>rand()        生成一个浮点随机数，需要跟srand配合</li>
  <li>tolower()     转小写</li>
  <li>toupper()     转大写</li>
  <li>sub()         <code>$ awk '{ sub(/foo/, "FOO"); print }' BBS-list</code>将foo字符串替换成FOO。</li>
</ul>
]]></content>
  </entry>
  
</feed>
