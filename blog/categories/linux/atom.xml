<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | CodeBean]]></title>
  <link href="http://jingxin.me/blog/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://jingxin.me/blog/"/>
  <updated>2015-12-07T20:23:12+08:00</updated>
  <id>http://jingxin.me/blog/</id>
  <author>
    <name><![CDATA[Xu Jingxin]]></name>
    <email><![CDATA[sailxjx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[start-stop-daemon]]></title>
    <link href="http://jingxin.me/blog/blog/2013/06/19/start-stop-daemon/"/>
    <updated>2013-06-19T13:44:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2013/06/19/start-stop-daemon</id>
    <content type="html"><![CDATA[<p>很多软件不提供init脚本，或者提供的脚本不合胃口，难免要自己动手丰衣足食。下面就推荐一个用来启动守护进程的神器。</p>

<p><code>start-stop-daemon</code>是<a href="http://www.gentoo.org/proj/en/base/openrc/">OpenRC</a>计划的一部分，这个程序最先出现在Debian系的Linux发行版中，这里有个比较古老的<a href="http://man.he.net/man8/start-stop-daemon">手册</a>页面，更详细更直观的办法当然是通过<code>man start-stop-daemon</code>来查看手册了。我使用的是”start-stop-daemon (OpenRC) 0.10 (Funtoo Linux)”版本，大部分功能是差不多的。</p>

<p><code>start-stop-daemon</code>最基本的两个功能就是<code>--start</code>和<code>--stop</code>，简写为<code>-S</code>和<code>-K</code>，然后再加上一个<code>-s|--signal</code>来给进程发送信号，功德圆满。</p>

<p>至于其中比较常用的一些参数，我列出来参考一下，以免忘了：</p>

<ul>
  <li><code>-x, --exec daemon</code>，daemon就是真正要执行的进程脚本，比方说启动nginx，那么就是<code>start-stop-daemon -x nginx</code>。</li>
  <li><code>-p, --pidfile pidfile</code>，指定pid文件，至于pid文件的用途就多了，stop,status都少不了它。</li>
  <li><code>-n, --name</code>，如果没有指定pid文件，那么就要通过指定name来停止进程了。</li>
  <li><code>-u, --user user[:group]</code>，指定脚本用哪个用户或用户组执行，init脚本是必须使用<code>root</code>权限来执行的，但是它fork出来的子进程我们一般会选择一个权限较低的用户。</li>
  <li><code>-b, --background</code>，强制脚本在后台执行。</li>
  <li><code>-m, --make-pidfile</code>，这个一般和<code>-b</code>配合，用于生成pid文件</li>
  <li><code>-d, --chdir path</code>，切换进程的主目录，这个在构建守护进程的时候是很常用的。</li>
  <li><code>-r, --chroot path</code>，在某些安全性要求较高的情况下，我们就需要用到<code>chroot</code>将进程工作环境与物理环境完全隔离开来。</li>
  <li><code>-1, --stdout logfile</code>，将标准输出记录到log文件，与之相对应的就是<code>-2, --stderr</code>标准错误流。</li>
  <li><code>-w, --wait milliseconds</code>，进程启动后，有这个参数会等待几毫秒来检测进程是否仍然存活。</li>
</ul>

<p>参数说完，下面就是一些需要注意的地方了。</p>

<h2 id="b"><code>-b</code>与守护进程</h2>

<p><code>-b</code>是一个很常用的参数，我们使用<code>start-stop-daemon</code>的目的就是为了实现守护进程。但是有些程序自身也实现了守护进程的功能，比方说mongodb中有一个fork选项就是将自己在后台执行，这个时候假如搭配的<code>-b</code>参数，是得不到正确的pid的，因为<code>start-stop-daemon</code>只能得到最初启动的父进程pid，而父进程在fork完之后就自动退出了，那么<code>start-stop-daemon</code>就永远找不到正确的pid来结束进程了。所以使用<code>-b</code>的时候，一定要保证程序是在前台运行的。</p>

<h2 id="section">其他参数</h2>

<p><code>-x daemon</code>后面跟的执行脚本必须只能是一个文件名，有些程序运行时还需要指定一些参数，比如<code>nginx -c file</code>来指定nginx的配置文件，使用<code>start-stop-daemon -x "nginx -c file"</code>是会报错的，这些程序内的参数以另一种方式加载，<code>start-stop-daemon -x daemon -- $ARGV</code>，这里的双横线<code>--</code>后面跟的所有参数就会被带到程序中了，比如<code>start-stop-daemon -x nginx -c /etc/nginx.conf</code>。</p>

<p>下面是mongodb的一个init脚本，用<code>start-stop-daemon</code>是非常简单的。（貌似源代码中没有提供init脚本，只能自己动手了）。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/sbin/runscript</span>
</span><span class='line'><span class="c"># Distributed under the terms of the GNU General Public License v2&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'>&lt;p&gt;MONGO_HOME<span class="o">=</span>/usr/local/mongo
</span><span class='line'><span class="nv">MONGO_USER</span><span class="o">=</span>mongo
</span><span class='line'><span class="nv">MONGO_PID_FILE</span><span class="o">=</span>/var/run/mongo/mongo.pid&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;depend<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    need net
</span><span class='line'><span class="o">}</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;start<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    ebegin “Starting Mongodb”
</span><span class='line'>    start-stop-daemon –start       <span class="se">\ </span>&lt;br /&gt;
</span><span class='line'>        –chdir  “<span class="k">${</span><span class="nv">MONGO_HOME</span><span class="k">}</span>”    <span class="se">\ </span>&lt;br /&gt;
</span><span class='line'>        –user “<span class="k">${</span><span class="nv">MONGO_USER</span><span class="k">}</span>”      <span class="se">\ </span>&lt;br /&gt;
</span><span class='line'>        -m -p “<span class="k">${</span><span class="nv">MONGO_PID_FILE</span><span class="k">}</span>”   <span class="se">\ </span>&lt;br /&gt;
</span><span class='line'>        -b –exec “<span class="k">${</span><span class="nv">MONGO_HOME</span><span class="k">}</span>/bin/mongod” – –config<span class="o">=</span>/etc/mongodb.conf
</span><span class='line'>    eend <span class="nv">$?</span>
</span><span class='line'><span class="o">}</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;stop<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    ebegin “Stopping Mongodb”
</span><span class='line'>    start-stop-daemon –stop        <span class="se">\ </span>&lt;br /&gt;
</span><span class='line'>        –chdir “<span class="k">${</span><span class="nv">MONGO_HOME</span><span class="k">}</span>”     <span class="se">\ </span>&lt;br /&gt;
</span><span class='line'>        –user “<span class="k">${</span><span class="nv">MONGO_USER</span><span class="k">}</span>”      <span class="se">\ </span>&lt;br /&gt;
</span><span class='line'>        -p “<span class="k">${</span><span class="nv">MONGO_PID_FILE</span><span class="k">}</span>”      <span class="se">\ </span>&lt;br /&gt;
</span><span class='line'>    eend <span class="nv">$?</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[virtualbox hates sendfile]]></title>
    <link href="http://jingxin.me/blog/blog/2013/02/18/virtualbox-hates-sendfile/"/>
    <updated>2013-02-18T16:39:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2013/02/18/virtualbox-hates-sendfile</id>
    <content type="html"><![CDATA[<p>事情的起因是这个样子滴~</p>

<p>代码文件都放在mac中，运行环境在virtualbox中，通过mount主机的文件夹来工作，相信很多同学都搭建过这样的环境，一切相安无事，直到某一天。。。</p>

<p>修改过的静态文件不生效了！</p>

<p>本来以为是nginx中缓存设置的问题，使尽各种解数，包括把expires设置为off，header中加Expire为0，给文件加时间戳，依然如此。果断google之，原来是virtualbox使用的特殊文件系统造成的。</p>

<p>apache和nginx中都有个默认开启的选项sendfile，表示通过内核文件指针来读取或复制文件，在vboxsf(virtualbox共享文件所使用的文件系统)中，sendfile会造成文件无法更新。于是我们无论怎么刷新，都只能看到第一次访问得到的文件了。</p>

<p>解决办法也很简单，将nginx.conf中设置<code>sendfile off</code>就可以了。</p>

<p>由于这个问题折腾了我很久，特此记录一下，同时借用某同样遇到此问题的<a href="http://abitwiser.wordpress.com/2011/02/24/virtualbox-hates-sendfile/">blog标题</a>。</p>

<h2 id="section">后记</h2>
<p>1.<a href="https://forums.virtualbox.org/viewtopic.php?f=1&amp;t=24905">virtualbox论坛</a>2009年的时候就有人讨论过这个问题，那时候的版本还是3.0，现在都4.2了，问题仍然没有得到解决，唉~被oracle X过的软件果然不行啊~。</p>

<p>2.在主机中修改文件，虚拟机中的inode不会变化，反过来也一样，不知道是不是因为vboxsf的问题，然而使用samba共享的文件系统中两边的inode是同时变化的。</p>

<h2 id="section-1">参考资料</h2>
<ul>
  <li><a href="http://abitwiser.wordpress.com/2011/02/24/virtualbox-hates-sendfile/">VirtualBox Hates Sendfile</a></li>
  <li><a href="http://serverfault.com/questions/269420/disable-caching-when-serving-static-files-with-nginx-for-development">serverfault</a></li>
  <li><a href="https://forums.virtualbox.org/viewtopic.php?f=1&amp;t=24905">virtualbox forum</a></li>
  <li><a href="http://wiki.nginx.org/HttpCoreModule#sendfile">nginx wiki</a></li>
  <li><a href="http://comments.gmane.org/gmane.linux.kernel.cifs/3517">mac中samba共享的问题</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux 登录用户管理]]></title>
    <link href="http://jingxin.me/blog/blog/2012/12/19/linux-deng-lu-yong-hu-guan-li/"/>
    <updated>2012-12-19T22:35:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2012/12/19/linux-deng-lu-yong-hu-guan-li</id>
    <content type="html"><![CDATA[<p>最近换了mac后，需要在公司和家中多地登录，两地的ip又没有设置成一样的，结果每次切换ip就发现ssh到虚拟机的终端没响应了，再连上之后，之前登录的用户就永远活在虚拟机心中啦~当然这也没什么，但是作为有一点点洁癖的我来说，不清除这几个用户总是一件不太舒服的事情，于是就去网上找找命令，结果发现找到的资料还挺齐全，学到不少，记录下来，以免下次忘了。</p>

<h3 id="who">who</h3>

<blockquote>
  <p>root     tty1         2012-12-19 17:51</p>
</blockquote>

<blockquote>
  <p>tristan  pts/0        2012-12-19 17:57 (macshare)</p>
</blockquote>

<blockquote>
  <p>tristan  pts/1        2012-12-19 18:00 (macshare)</p>
</blockquote>

<p>这个命令不用说，大多数人都知道，查看当前登录用户，登录时间，终端号(tty)和远程登录终端号(pts)</p>

<h3 id="whoami">whoami</h3>

<p>这个命令有点意思，顾名思义，告诉<code>我是谁</code>，曾经有位buddy获得了root权限，但是当使用<code>cd ~</code>的时候仍然回到了先前用户的主目录，这个时候<code>whoami</code>告诉他确实已经是root用户了，仔细想想，原来他是用<code>sudo -s</code>切到了root，所有环境变量沿用了老用户的。说明这个短小的命令还是挺实用啦。</p>

<h3 id="w-user">w [user]</h3>

<blockquote>
  <p>18:43:48 up  9:39,  3 users,  load average: 0.06, 0.06, 0.06</p>
</blockquote>

<blockquote>
  <p>USER     TTY       LOGIN@   IDLE   JCPU   PCPU WHAT</p>
</blockquote>

<blockquote>
  <p>root     tty1      17:51   47:01   0.43s  0.40s -zsh</p>
</blockquote>

<blockquote>
  <p>tristan  pts/0     17:57   30:20   0.44s  0.44s -zsh</p>
</blockquote>

<blockquote>
  <p>tristan  pts/1     18:00    0.00s  0.18s  0.00s w</p>
</blockquote>

<p>更短的命令，却比who更强大。</p>

<p>第一行数值分别表示当前时间，系统运行时间，登录用户数，(1分钟，5分钟，15分钟)内的系统负载</p>

<p>第二行开始就是一个用户相关的表格了，每列的意思分别为：</p>

<ul>
  <li>USER：显示登陆用户帐号名。</li>
  <li>TTY：用户登录的终端号。</li>
  <li>FROM：显示用户在何处登陆系统。</li>
  <li>LOGIN@：是LOGIN AT的意思，表示登陆进入系统的时间。</li>
  <li>IDLE：用户空闲时间，从用户上一次任务结束后，开始记时。</li>
  <li>JCPU：一终端代号来区分，表示在某段时间内，所有与该终端相关的进程任务所耗费的CPU时间。</li>
  <li>PCPU：指WHAT域的任务执行后耗费的CPU时间。</li>
  <li>WHAT：表示当前执行的任务。</li>
</ul>

<h3 id="last-user">last [user]</h3>

<blockquote>
  <p>tristan   ttys003                   Wed Dec 19 22:57   still logged in</p>
</blockquote>

<blockquote>
  <p>tristan   ttys001                   Wed Dec 19 22:47   still logged in</p>
</blockquote>

<blockquote>
  <p>tristan   ttys003                   Wed Dec 19 22:38 - 22:39  (00:01)</p>
</blockquote>

<p>这个命令显示用户的登录记录，后面可以跟用户名来只显示该用户的登录历史。一般还会搭配管道用<code>last | head</code>来显示最后登录历史或<code>last | grep still</code>来获取仍然登录中的用户</p>

<h3 id="ps--ef--grep-pts0">ps -ef | grep [pts/0]</h3>

<blockquote>
  <p>tristan   1042  1041  0 19:01 pts/0    00:00:00 -zsh</p>
</blockquote>

<blockquote>
  <p>tristan   1916  1042  0 19:03 pts/0    00:00:00 ps -ef</p>
</blockquote>

<p>这个命令就是起初写这篇文章的用意啦，根据终端号(可以通过who命令查到)获取目标用户登录相关的pid，比如上面这个1042，然后使用<code>kill -9 1042</code>剔除这个用户，注意<code>kill</code>需要加上<code>-9</code>，默认的TERM信号是杀不了这个进程的。</p>

<h3 id="pkill--u-user">pkill -u [user]</h3>

<p>网上还有一种更简便的方法，根据用户名kill掉这个用户相关的所有进程，包括已这个用户身份运行的所有daemon进程，很黄很暴力，伤敌一千自损八百，不推荐。</p>

<h2 id="section">参考资料</h2>

<ul>
  <li>
    <p><a href="http://blog.csdn.net/linfengfeiye/article/details/4781507">Linux查看和剔除当前登录用户</a></p>
  </li>
  <li>
    <p><a href="http://linux.about.com/library/cmd/blcmdl1_w.htm">Linux / Unix Command: w</a></p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[zsh自动补全]]></title>
    <link href="http://jingxin.me/blog/blog/2012/08/30/zshzi-dong-bu-quan/"/>
    <updated>2012-08-30T18:15:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2012/08/30/zshzi-dong-bu-quan</id>
    <content type="html"><![CDATA[<p>最近被zsh搞的够郁闷，Mark一下，好好翻翻文档，下周写出自己的自动补全脚本</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql 多实例启动]]></title>
    <link href="http://jingxin.me/blog/blog/2012/08/13/mysql-duo-shi-li-qi-dong/"/>
    <updated>2012-08-13T17:03:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2012/08/13/mysql-duo-shi-li-qi-dong</id>
    <content type="html"><![CDATA[<p>当开发与生产环境在同一台机器上，或需要在一台机器上部署多套测试环境时，往往需要同时起多个mysqld进程，最近帮测试搭环境的时候就碰到了这样的问题。</p>

<p>还是从安装mysql开始，下载tarball安装，</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>安装mysql  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>groupadd mysql
</span><span class='line'>useradd -g mysql mysql
</span><span class='line'>cmake . -DCMAKE_INSTALL_PREFIX<span class="o">=</span>/usr/local/mysql5.5.27/  -DMYSQL_DATADIR<span class="o">=</span>/data/mysql  -DWITH_INNOBASE_STORAGE_ENGINE<span class="o">=</span>1  -DMYSQL_TCP_PORT<span class="o">=</span>3306  -DMYSQL_UNIX_ADDR<span class="o">=</span>/var/run/mysql/mysql.sock -DWITH_DEBUG<span class="o">=</span>0
</span><span class='line'>make &amp;amp;&amp;amp; make install
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>然后配置my.cnf，从support-files里面拷贝一个my-medium.cnf到/etc/my.cnf，里面mysqld配置段的内容基本是这个样子</p>

<p>Liquid error: ClassNotFound: no lexer for alias 'cnf' found</p>

<p>默认mysqld只启动一个实例，既然我们的目的是启动多个mysqld实例，需要使用mysqld_multi。它是一个perl脚本，在使用之前，需要给my.cnf加一些料。</p>

<p>Liquid error: ClassNotFound: no lexer for alias 'cnf' found</p>

<p>然后依配置创建mysql运行时文件夹并用mysql_install_db脚本初始化系统库
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>mkdir -p /data/mysql1 /data/mysql2 /var/log/mysql /var/run/mysql
</span><span class='line'>chgrp mysql /data/mysql* /var/log/mysql /var/run/mysql
</span><span class='line'>chown mysql /data/mysql* /var/log/mysql /var/run/mysql
</span><span class='line'>mysql_install_db –datadir<span class="o">=</span>/data/mysql1 –user<span class="o">=</span>mysql
</span><span class='line'>mysql_install_db –datadir<span class="o">=</span>/data/mysql2 –user<span class="o">=</span>mysql
</span><span class='line'>mysqld_multi start 1-2
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>最后一条命令其实已经将我们配置好的mysqld1和mysqld2启动了，这时候在进程表中应该能看到两个mysqld进程，试着用-P参数指定端口能分别访问在/data/mysql1和/data/mysql2下面的两个库，两者互不影响，正好能满足测试的要求。当然需要配置更多的实例也是可以的。</p>

<h2 id="mysql_extra">额外收获</h2>

<p>这次配置过程中还遇到一些额外的问题，记下来备忘。</p>

<ul>
  <li>假如使用的是ubuntu(我目前的版本还是11.10)，默认会安装apparmor，这个软件是一个诡异的存在，它就像一个暗恋者，一直默默限制软件的访问权限，然后又不被系统待见，以至于我根本不知道它的存在。其实它是一个白名单，在/etc/apparmor.d/中指定了/usr/sbin/mysqld对各文件的访问权限，当我想将mysql的数据文件夹迁移到别的位置时，一直报这个错误</li>
</ul>

<p><code>Can't create test file /data/mysql1/littleboy.lower-test</code></p>

<p>而令人费解的就是mysql对这些文件夹是有读写权限的，其实只需要编辑/etc/apparmor.d/usr.sbin.mysqld文件，依样画葫芦地为文件夹加上rw权限就可以了</p>

<ul>
  <li>给mysql设置远程访问权限，只需要下面这条sql</li>
</ul>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">INSERT</span> <span class="n">mysql</span><span class="p">.</span><span class="k">user</span> <span class="p">(</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">Host</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">User</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Password</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span> <span class="err">‘</span><span class="o">%</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">root</span><span class="err">’</span><span class="p">,</span> <span class="n">PASSWORD</span><span class="p">(</span><span class="err">‘</span><span class="mi">123456</span><span class="err">’</span><span class="p">)</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其中最关键的就是那个’%’，表示通过任意host均可以访问到本机的mysql</p>

<ul>
  <li>给mysql设置密码。</li>
</ul>

<p><code>mysqladmin -u root -h 127.0.0.1 password 123456</code></p>

<p>上面那种是在不登录mysql的情况下修改密码，还有两种可以通过改表的方式。见<a href="#mysql_refer">MySQL设置密码的三种方法</a></p>

<p>修改过密码以后，mysqld_multi可能就不能通过默认配置来结束mysqld进程了，这时候需要在配置里加上用户名和密码</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[mysqld_multi]
</span><span class='line'>mysqld = /usr/local/mysql/bin/mysqld
</span><span class='line'>mysqladmin = /usr/local/mysql/bin/mysqladmin
</span><span class='line'>user = root
</span><span class='line'>password = 123456</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>当然这样可能会有一些安全隐患，因为my.cnf是可见的。假如是多人使用，可以将password这行去掉，每次操作mysqld_multi的时候，在后面加上<code>--password=123456</code>参数就行了</p>

<h2 id="mysql_refer">参考资料</h2>
<ul>
  <li><a href="http://www.neocanable.com/error-for-mysql-multi-and-mysql-install-db/">解决apparmor引起的报错1</a></li>
  <li><a href="http://ubuntuforums.org/showthread.php?t=1861136">解决apparmor引起的报错2</a></li>
  <li><a href="http://blog.csdn.net/magicbreaker/article/details/2392764">MySQL设置密码的三种方法</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
