<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nodejs | CodeBean]]></title>
  <link href="http://jingxin.me/blog/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://jingxin.me/blog/"/>
  <updated>2015-07-26T18:37:58+08:00</updated>
  <id>http://jingxin.me/blog/</id>
  <author>
    <name><![CDATA[Xu Jingxin]]></name>
    <email><![CDATA[sailxjx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Node.js 沙盒]]></title>
    <link href="http://jingxin.me/blog/blog/2015/06/18/node-dot-js-sha-he/"/>
    <updated>2015-06-18T16:36:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2015/06/18/node-dot-js-sha-he</id>
    <content type="html"><![CDATA[<h2 id="section">为什么要使用沙盒</h2>

<p>eval 在很多语言中都是一个很有用的方法，合理利用它可以编写出很多让人拍案叫绝的功能。但是由于它实在过于开放和危险，很多人给它冠上了 <strong>evil</strong> 的称号。</p>

<p>使用沙盒可以给 eval 类的功能增加一些条件限制，让它变得更加安全，而不丢失其灵活性。</p>

<p>Node.js 中提供的 vm 模块可以轻松实现沙盒的功能。</p>

<h2 id="vm-">如何使用 vm 模块</h2>

<h3 id="vmruninthiscontext"><code>vm.runInThisContext</code></h3>

<p><code>vm.runInThisContext</code> 可以执行代码并得到它的返回值，被执行的代码没有权限访问本地对象，但是可以访问全局对象。相比之下， eval 则有权限访问上下文中的对象。</p>

<p>```javascript
var localVar = ‘initial value’;</p>

<p>var vmResult = vm.runInThisContext(‘localVar = “vm”;’);
console.log(‘vmResult: ‘, vmResult);
console.log(‘localVar: ‘, localVar);</p>

<p>var evalResult = eval(‘localVar = “eval”;’);
console.log(‘evalResult: ‘, evalResult);
console.log(‘localVar: ‘, localVar);</p>

<p>// vmResult: ‘vm’, localVar: ‘initial value’
// evalResult: ‘eval’, localVar: ‘eval’
```</p>

<h3 id="vmcreatecontext--vmrunincontext"><code>vm.createContext</code> 与 <code>vm.runInContext</code></h3>

<p><code>vm.createContext</code> 则是真正创造了一个沙盒对象，使用 <code>vm.runInContext</code> 可以完全让代码在这个沙盒环境中运行。</p>

<p>```javascript
var util = require(‘util’);
var vm = require(‘vm’);</p>

<p>sandbox = vm.createContext({ globalVar: 1 });</p>

<p>for (var i = 0; i &lt; 10; ++i) {
    vm.runInContext(‘globalVar *= 2;’, sandbox);
}</p>

<p>console.log(util.inspect(sandbox));
console.log(global.globalVar);</p>

<p>// { globalVar: 1024 }
// undefined
```</p>

<h2 id="vm--1">vm 的具体应用</h2>

<p><a href="https://github.com/teambition/configd"><code>configd</code></a> 是我为公司部署流程开发的一个小工具，功能是将各种来源的配置文件合并成一个 json 文件。由于它支持 <code>ssh</code>, <code>git</code>, <code>http</code> 等多种来源的配置或代码，所以需要在工具内部来执行这些代码以实现和本地 <code>require</code> 类似的效果。如果用 <code>eval</code>，那么除却风险问题，<code>module.exports</code> 也不能生效了。所以在工具中使用了 vm 模块来执行这些代码。</p>

<p>```coffeescript
_eval = (js, options = {}) -&gt;
  sandbox = vm.createContext()
  sandbox.exports = exports
  sandbox.module = exports: exports
  sandbox.global = sandbox
  sandbox.require = require
  sandbox.__filename = options.filename or ‘eval’
  sandbox.__dirname = path.dirname sandbox.__filename</p>

<p>vm.runInContext js, sandbox</p>

<p>sandbox.module.exports</p>

<p>data = _eval js
```</p>

<h2 id="section-1">参考资料</h2>

<p><a href="https://nodejs.org/api/vm.html">Executing JavaScript</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一次神奇的 nodejs debug 经历]]></title>
    <link href="http://jingxin.me/blog/blog/2014/09/13/yi-ci-shen-qi-de-nodejs-debug-jing-li/"/>
    <updated>2014-09-13T18:09:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2014/09/13/yi-ci-shen-qi-de-nodejs-debug-jing-li</id>
    <content type="html"><![CDATA[<p>中秋之后，服务器上老是出现 cpu 爆满的情况，难道服务器也闹情绪想休假。当然这种情况是很紧急的，所以马上就着手排查。</p>

<p>还没找出问题，又有同学报测试机上也有这种情况，但是应用进程不同。想到有可能这两件事是有关联的，所以先从测试机开始排查。</p>

<h2 id="settimeout--bug">问题一， setTimeout 的 bug</h2>

<p>测试机上的问题很好排查，每次进程重启后立刻飙升到 100%，通过万能的 log 大法，很快就定位到问题。应用中使用了 <a href="https://github.com/visionmedia/axon">axon</a> 模块作为消息中间件，在连接不成功时会用 <code>setTimeout</code> 尝试重连，间隔由最初的 100ms 开始每次乘以 1.5，这样在三次之后间隔就变成了 337.5ms，nodejs 有<a href="https://github.com/joyent/node/issues/5796">一个 bug</a>，Timer 函数中出现小数时会导致死循环，我们用的是 0.10.30 版本，这个 bug 依然可以重现。所以解决办法也很简单了，直接 <a href="https://github.com/visionmedia/axon/commit/68a23cacd5fd94527b52738b0d43876187ee82e9#diff-595746af128d06d3cac45cb001ad2219R280">round 一下</a>就可以了。以后在使用 Timer 类函数时也需要注意不要出现小数哦。</p>

<h2 id="section">问题二，正则表达式的效率问题</h2>

<p>由于 axon 在生产环境中也有使用，我们就将所有的版本都进行了升级，以为万事大吉。结果却不遂人愿，生产环境中的几个进程在启动后，时不时会出现负载 100% 的情况，这种可能性分析起来就很复杂了。我们依次尝试了 node-inspector，node-heapdump 等工具，都没有找到原因（实话说，以前用这些 debug 内存问题时也是一无所获，nodejs 的 debug 工具实在鸡肋）。也没有重现线上的问题。</p>

<p>一个有趣的现象是，我发现每次进程重启之后，飙升到 100% 的时间不定，但是每次都是瞬间从 0 到 100%。这种现象说明导致问题的原因可能不是程序内部产生，而是由外力产生，这个外力是什么呢，其实就是请求。再一次借助万能 log 大法，express 的 log 只能记录有响应的请求，如果一个请求在中途陷入了死循环，那么就得不到 express 的 log，所以我们自己写了一个中间件，在 express 的最前部引入，只打印出请求的链接。</p>

<p>接下来问题就很明显了（其实也破费一番周折），每当出现某一请求时，程序就陷入了死循环，屡试不爽。一步步排查下来，发现问题出现在 <a href="https://github.com/leizongmin/js-xss">xss</a> 模块中，其中的一个正则表达式，在匹配某些字符串时出现了问题：</p>

<ul>
  <li>表达式：<code>/&lt;!--(.|\s)*?--&gt;/gm</code></li>
  <li>测试字符串：<code>&lt;!--                                    </code></li>
</ul>

<p>当表达式未找到匹配内容时，效率指数级的下降，特别是在多个重复空格和子表达式时。这个原因解释起来就比较复杂了。<a href="http://swtch.com/~rsc/regexp/regexp1.html">大神的一篇文章</a>很好的解释了这个问题，有时间我要翻译一下，一定又有很多收获。</p>

<p>解决的方法很简单，在<a href="https://github.com/leizongmin/js-xss/commit/161f9510aab78aba83cf75c54c0dafd3a0436a84#diff-666d669efc2fef279da605aba853e681L354">这个 Pull Request</a>中可以找到。看来以后使用正则表达式的时候得过留个心眼了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[limbo: 简单访问远程数据库]]></title>
    <link href="http://jingxin.me/blog/blog/2014/08/28/limbo-jian-dan-fang-wen-yuan-cheng-shu-ju-ku/"/>
    <updated>2014-08-28T17:41:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2014/08/28/limbo-jian-dan-fang-wen-yuan-cheng-shu-ju-ku</id>
    <content type="html"><![CDATA[<p><img src="https://dn-talk.oss.aliyuncs.com/site/images/workspace-c16d9d49.jpg" alt="简聊一下 轻松协作" /></p>

<p>对于 nodejs 生态来说，使用 mongoose 作为 Model 模块是再好不过的一件事，其一大特点就是简洁优雅的 Schema 定义，提供了每个键值的类型验证，数据验证，索引声明，虚拟键，并自带实例化方法的扩展，大大节省了开发的成本。但是在考虑开放数据的时候，一切就显得不那么美好了。</p>

<p>在打造<a href="https://talk.ai/">简聊</a>这款应用的过程中，我们就实实在在的遇到了这样的问题。由于需要使用 <a href="https://www.teambition.com/">Teambition</a> 的用户和团队数据，并且当<a href="https://talk.ai/">简聊</a>更新了用户数据之后，在 <a href="https://www.teambition.com/">Teambition</a> 中能实时的将这些更新推送到用户那里。按照惯例，我们最初使用的是 restful 接口。</p>

<h2 id="restful-">第一阶段，使用 restful 接口</h2>

<p>restful 接口的应用面最广，但是仍然存在很多不足，比如接口在参数和结构上限制较多，在考虑修改接口 api 的时候，往往会顾虑客户端的兼容性，而一旦客户端程序有新的需求，则需等待接口的更新。另一个麻烦的地方是需要做签名校验，对于内部的应用来说，我们完全可以通过防火墙来控制特定 ip 对端口的访问，签名在此处就显得有点多余。</p>

<h2 id="schema">第二阶段，单独拆封 Schema</h2>

<p>然后我们想到了将 Schema 拆封成一个单独的仓库，nodejs 有良好的模块管理，在不同的应用中，我们只需要将这些模块引入进来，既做到同步更新，又做到 DRY。相对于 restful 接口的缺点就是，对于数据的调用入口过多，而且应用之间互相是不知情的。例如在<a href="https://talk.ai/">简聊</a>中有更新用户数据，在 <a href="https://www.teambition.com">Teambition</a> 中就无法得知，并推送给其他客户端。</p>

<h2 id="rpc">第三阶段，远程过程调用（rpc）</h2>

<p>这个阶段和 restful 接口其实类似，我们在 <a href="https://www.teambition.com">Teambition</a>  的后端进程中将一些接口方法暴露出来，这样我们的客户端程序就能通过简单的 rpc 方式调用这些接口。例如我们导出了 <code>user.update</code> 方法，在客户端代码中使用 <code>rpc.call('user.update', params, callback)</code> 即可调用相应的过程。这样的调用行为与使用本地代码无异，可能是目前能找到的最简单直接的方式了。</p>

<h2 id="rpc--mongoose-">第四阶段，rpc 与 mongoose 的结合</h2>

<p>事情可以变得更简单，由于目的主要是为了操作数据库，所以我们开发了一个模块 <a href="https://github.com/teambition/limbo">limbo</a>，将 mongoose model 中所有方法暴露出来，以命名空间来划分，实现了在客户端与服务端程序一致的使用体验。</p>

<p>例如我们在服务端程序中使用 limbo 连接 mongodb，只需要做如下声明：（以下的代码都以 coffeescript 作为示例）</p>

<p>```coffeescript
limbo = require ‘limbo’</p>

<h1 id="schema-1">定义 Schema</h1>
<p>UserSchame = (Schema) -&gt;
  # 这里的 Schema 即 mongoose.Schema
  new Schema
    name: String
    email: String</p>

<h1 id="use-">use 方法用作区分不同数据库连接的命名空间，一般参数选择数据库名就行</h1>
<p>db = limbo.use(‘test’).connect(‘mongodb://localhost:27017/test’).load ‘User’, UserSchema
```</p>

<p>使用方式就与 mongoose 一致了</p>

<p><code>coffeescript
user = db.user
# user 是一个 limbo 中用于封装 model 的一个对象，你可以直接使用 user.model 来直接调用 mongoose model
user.findOne _id: 'xxxx'
user.create name: 'xxx', email: 'yyy'
</code></p>

<p>下面是 limbo 中最激动人心的地方，你可以导出一个 collection 中的所有方法到 rpc server 中，只需要通过一个简单的声明</p>

<p><code>coffeescript
limbo.use('test').bind(7001).enableRpc()
</code></p>

<p>下面我们就要提到如何在客户端程序中调用这些方法</p>

<p>```coffeescript
# 在客户端也需要初始化一个 limbo 命名空间，需要与服务端一致，链接改为服务端的域名和端口号
db = limbo.use(‘test’).connect(‘tcp://localhost:7001’)</p>

<h1 id="rpc-1">下面有两种方式来使用 rpc</h1>
<p># 1. 使用 call 方法
db.call ‘user.findOne’, _id: ‘xxxx’, -&gt;
# 2. 使用方法链
db.user.findOne _id: ‘xxxx’, -&gt;
# 第二种方式存在一个延迟，必须要在 limbo 与服务端程序握手成功之后才可以使用，
# 否则会抛出一个对象不存在的异常，不过在一般的应用中，
# 初始化所需的时间都会长于这个链接所需时间，所以延迟可以忽略不计了
```</p>

<p>可以看出，上面的第二种方式与服务端在本地使用 mongoose 的方式一模一样，这种黑魔法式的调用方式应该是广大码农喜闻乐见的。</p>

<p>limbo 另一个值得称道的功能是可以在服务端程序监听这些远程调用的事件，这得益于 nodejs 的 event 对象，limbo 本身就继承于 EventEmitter 对象，所以我们在每次远程调用后会触发一个事件给服务端程序，而在服务端只需要简单的监听这个事件即可</p>

<p><code>coffeescript
limbo.on 'test.user.findOne', (user) -&gt; ...
</code></p>

<p>正是这种 rpc 加事件反馈的机制，让<a href="https://talk.ai/">简聊</a>和 <a href="https://www.teambition.com">Teambition</a> 可以实现简单实时的数据交换。我们将 <a href="https://github.com/teambition/limbo">limbo</a> 托管在 github 上开源，是深知它还存在很多可以改进的地方，所以不免庸俗的说一句，欢迎 issue 和 pr~</p>

<p>最后，欢迎访问我们的新产品<a href="https://talk.ai">简聊</a>，一款基于话题的轻量级协作应用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回调 vs 协同程序]]></title>
    <link href="http://jingxin.me/blog/blog/2014/04/19/hui-diao-vs-xie-tong-cheng-xu/"/>
    <updated>2014-04-19T15:44:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2014/04/19/hui-diao-vs-xie-tong-cheng-xu</id>
    <content type="html"><![CDATA[<blockquote>
  <p>原文地址：<a href="https://medium.com/code-adventures/174f1fe66127">Callbacks vs Coroutines</a></p>
</blockquote>

<p>最近 Google V8 引擎的一个补丁提供了 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">ES6 生成器</a>，一篇叫做<a href="http://jlongster.com/A-Study-on-Solving-Callbacks-with-JavaScript-Generators">“用 Javascript 生成器来解决回调问题的研究”</a>的文章引发了很大的争议。虽然生成器到目前为止仍然需要 <code>--harmony</code> 或 <code>--harmony-generators</code> 选项才能激活，但是它已经值得你跃跃欲试！在这篇文章中我想要阐述的是自己对于<a href="http://en.wikipedia.org/wiki/Coroutine">协同程序</a>的体验，并且说明为什么我认为它们是一种好方法。</p>

<h2 id="section">回调和生成器</h2>
<p>在认识回调和生成器之间的不同之前，我们先来看看生成器在 Nodejs 或浏览器这种由回调主宰的环境中是怎样发挥作用的。</p>

<p>首先生成器是回调的一种扩展，有些类型的回调就是用来“模拟”生成器的。这些“futures”，“thunks”，或“promises” —— 无论你怎么称呼，都是用来延迟执行一小段逻辑的，就好比你 yield 了一个变量然后由生成器来处理其他的部分。</p>

<p>一旦这些变量 yield 给了调用方，这个调用方等待回调然后重新回到生成器。见仁见智，生成器的原理和回调其实是一样的，然而下面我们会说到使用它的一些好处。</p>

<p>假如你还是不太清楚该怎么使用生成器，这里有一个简单的例子实现了由生成器来控制流程。</p>

<p>```javascript
var fs = require(‘fs’);
function thread(fn) {
  var gen = fn();
  function next(err, res) {
    var ret = gen.next(res);
    if (ret.done) return;
    ret.value(next);
  }</p>

<p>next();
}
thread(function *(){
  var a = yield read(‘app.js’);
  var b = yield read(‘package.json’);
  console.log(a);
  console.log(b);
});
function read(path) {
  return function(done){
    fs.readFile(path, ‘utf8’, done);
  }
}
```</p>

<h2 id="section-1">为什么协同程序会使代码更健壮</h2>

<p>对于传统的浏览器或 Nodejs 环境，协同程序在自己的堆栈上运行每个“纤程”。这些纤程的实现各不相同，但是它们只需要一个很小的栈空间就能初始化（大约4kb），然后随需求增长。</p>

<p>为什么这样棒极了？错误处理！假如你使用过 Nodejs， 你就会知道错误处理不是那么简单。有些时候你会得到多个包含未知边际效应的回调，或者完全忘了回调这回事并且没有正确的处理和汇报异常。也许你忘了监听一个“error”事件，这样的话它就变成了一个未捕获的异常而让整个进程挂掉。</p>

<p>有些人喜欢使用进程，而且这样也挺好，但是作为一个在早期就使用 Nodejs 的人来说，在我看来这种流程有很多地方值得改进。Nodejs 在很多方面都很出色，但是这个就是它的阿喀琉斯之踵。</p>

<p>我们用一个简单的例子来看看由回调来读写同一个文件：</p>

<p><code>javascript
function read(path, fn) {
  fs.readFile(path, 'utf8', fn);
}
function write(path, str, fn) {
  fs.writeFile(path, str, fn);
}
function readAndWrite(fn) {
  read('Readme.md', function(err, str){
    if (err) return fn(err);
    str = str.replace('Something', 'Else');
    write('Readme.md', str, fn);
  });
}
</code></p>

<p>你可能会想这看起来也没那么糟糕，那是因为你整天看到这样的代码！好吧这是错误的:)为什么？应为大多数 node 核心方法，和多数第三方库都没有 try/catch 他们的回调。</p>

<p>下面的代码会抛出一个未捕获异常而且没有任何方法能捕获它。就算内核检测到这个异常并且告诉调用方这可能是一个错误点，大多数回调都有未知的行为。</p>

<p><code>javascript
function readAndWrite(fn) {
  read('Readme.md', function(err, str){
    throw new Error('oh no, reference error etc');
    if (err) return fn(err);
    str = str.replace('Something', 'Else');
    write('Readme.md', str, fn);
  });
}
</code></p>

<p>所以生成器是怎么来优化这一点的？下面的代码片段用生成器和 <a href="https://github.com/visionmedia/co">Co</a> 库来实现了相同的逻辑。你可能会想“这只是一些愚蠢的语法糖而已” - 但是你错了。只要我们将生成器传给 <code>Co()</code> 方法，所有委派给调用方的 yields，特别是强健的错误处理都会由 Co 来委派。</p>

<p><code>javascript
co(function *(){
  var str = yield read('Readme.md')
  str = str.replace('Something', 'Else')
  yield write('Readme.md', str)
})
</code></p>

<p>就像下面这样，Co 这样的库会将异常“抛”回给他们原本的流程，这意味着你可以用 try/catch 来捕获异常，或者任其自流由最后 Co 的回调来处理这些错误。</p>

<p><code>javascript
co(function *(){
  try {
    var str = yield read('Readme.md')
  } catch (err) {
    // whatever
  }
  str = str.replace('Something', 'Else')
  yield write('Readme.md', str)
})
</code></p>

<p>在编写 Co 的时候貌似只有它实现了健壮的错误处理，但是假如你看一下 Co 的<a href="https://github.com/visionmedia/co/blob/master/index.js#L30">源代码</a>你会注意到所有的 try/catch 代码块。假如你用生成器你需要将 try/catch 添加到每个你用过的库中，来保证代码的健壮性。这就是为什么在今天看来，用 Nodejs 编写健壮性代码是一件不可能完成的任务。</p>

<h2 id="section-2">生成器对于协同程序</h2>
<p>生成器有时会被当成“半协同程序”，一个不完善，仅对调用方有效的协同程序。这让使用生成器比协同程序的目的更明确，好比 yield 能被当成“线程”。</p>

<p>协同程序要更加灵活一些，看起来就像是普通代码块，而不需要 yield：</p>

<p><code>javascript
var str = read('Readme.md')
str = str.replace('Something', 'Else')
write('Readme.md', str)
console.log('all done!')
</code></p>

<p>有些人认为完整的协同程序是“危险的”，因为它不清楚哪个方法有没有延迟执行线程。个人来说我认为这种争论很可笑，大部分延迟执行的方法都很明显，比方说从文件或套接字中读写，http 请求，睡眠等等延迟执行不会让任何人感到惊讶。</p>

<p>假如有些不友善的方法，那么你就 “fork” 它们来强迫这些任务变成异步的，就像你在 Go 中做的一样。</p>

<p>在我看来生成器可能比协同程序更危险（当然比回调好得多）——仅仅是忘记一个 yield 表达式就可能让你费解或在它执行下面的代码时导致未知的行为结果。半协同程序和协同程序两者各自有优缺点，但是我很高兴现在至少已经有了其一。</p>

<p>让我们来看看你用生成器可以怎样实现新的构造方法。</p>

<h2 id="section-3">用协同程序实现简单的异步流程</h2>
<p>你已经看到一个简单读/写表达式看起来比回调更优雅，我们来看看更多的内容。</p>

<p>假设所有操作默认按顺序执行简化了模型，有些人声称生成器或协同程序使状态变得复杂化，这事不正确的。用回调处理状态也是一样的。全局变量依然是全局变量，局部变量依然是局部变量，而闭包依然是闭包。</p>

<p>我们用例子来说明这个流程，假设你需要请求一个 web 页面，解析其中的链接，然后同步请求所有的链接并输出他们的 Content-types。</p>

<p>这里是一个使用传统回调的例子，没有使用第三方流程控制库。</p>

<p>```javascript
function showTypes(fn) {
 get(‘http://cloudup.com’, function(err, res){
   if (err) return fn(err);
   var done;
   var urls = links(res.text);
   var pending = urls.length;
   var results = new Array(pending);
   urls.forEach(function(url, i){
     get(url, function(err, res){
       if (done) return;
       if (err) return done = true, fn(err);
       results[i] = res.header[‘content-type’];
       —pending || fn(null, results);
     });
   });
 });
}</p>

<p>showTypes(function(err, types){
  if (err) throw err;
  console.log(types);
});
```</p>

<p>这么简单的一个任务被回调搞得毫无可读性。再加上错误处理，重复回调的预防，存储结果和他们本身的一些回调，你会完全搞不懂这个方法是用来干嘛的。假如你需要使代码更健壮，还需要在最后的方法处加上 try/catch 代码块。</p>

<p>现在下面有一个由生成器实现的相同的 showTypes() 方法。你会看到结果和用回调实现的方法是一样的，在这里例子中 Co 处理了所有我们在上面需要手工处理的错误和结果集的组装。被 urls.maps(get) 方法 yield 的数组被平行执行，但是结果集然后是保持不变的顺序。</p>

<p><code>javascript
function header(field) {
  return function(res){
    return res.headers[field]
  }
}
function showTypes(fn) {
  co(function *(){
    var res = yield get('http://cloudup.com')
    var responses = yield links(res.text).map(get)
    return responses.map(header('content-type'))
  })(fn)
}
</code></p>

<p>我并不是建议所有的 Npm 模块使用生成器并且强制依赖 Co，我仍然建议使用相反的方法 —— 但是在应用层面我强烈推荐它。</p>

<p>我希望这能说明协同程序在编写无阻塞的程序时是一个强有力的工具。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个例子验证 do 在 coffeescript 中干了什么]]></title>
    <link href="http://jingxin.me/blog/blog/2013/08/07/yi-ge-li-zi-yan-zheng-do-zai-coffeescript-zhong-gan-li-shen-me/"/>
    <updated>2013-08-07T17:20:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2013/08/07/yi-ge-li-zi-yan-zheng-do-zai-coffeescript-zhong-gan-li-shen-me</id>
    <content type="html"><![CDATA[<p>使用jslint的时候有可能会见到这样的提示</p>

<blockquote>
  <p>Don’t make functions within a loop</p>
</blockquote>

<p>一直没有太在意这个警告，直到最近做项目的时候还真的碰到了因为这个问题产生的bug。</p>

<p>那么下面就用一个例子来看看在循环中定义方法会产生什么样的后果吧。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">array = </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="k">for</span> <span class="nx">num</span> <span class="k">in</span> <span class="nx">array</span>
</span><span class='line'>  <span class="nx">setTimeout</span> <span class="p">(</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">num</span><span class="p">),</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>得到的结果是’3,3,3’，而不是预期的’1,2,3’，先不说为什么，我们来看看coffeescript给出的解决方案。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">array = </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="k">for</span> <span class="nx">num</span> <span class="k">in</span> <span class="nx">array</span>
</span><span class='line'>    <span class="nx">do</span> <span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>        <span class="nx">setTimeout</span> <span class="p">(</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">num</span><span class="p">),</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在这里不得不佩服<a href="https://github.com/jashkenas">Jeremy Ashkenas</a>的无限创造力，短短一个<code>do</code>，就解决了这么让人纠结的问题。下面来看看编译成javascript之后的结果</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">array</span><span class="p">,</span> <span class="nx">num</span><span class="p">,</span> <span class="nx">_fn</span><span class="p">,</span> <span class="nx">_i</span><span class="p">,</span> <span class="nx">_len</span><span class="p">;</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">_fn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">setTimeout</span><span class="p">((</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}),</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_len</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&amp;</span><span class="nx">lt</span><span class="p">;</span> <span class="nx">_len</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">num</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
</span><span class='line'>    <span class="nx">_fn</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}).</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>下面我们来解释一下为什么上面的代码会有问题，以及这个<code>do</code>为我们做了些啥。</p>

<p>关于javascript的作用域，我们可以看一下<a href="http://rzrsharp.net/2011/06/27/what-does-coffeescripts-do-do.html">这篇文章的引用</a></p>

<blockquote>
  <p>JavaScript’s scopes are function-level, not block-level, and creating a closure just means that the enclosing scope gets added to the lexical environment of the enclosed function.</p>
</blockquote>

<p>大意是说</p>

<blockquote>
  <p>JavaScript的作用域是方法级别，而非块级的。创造一个闭包可以将作用域限定在这个封闭的方法中</p>
</blockquote>

<p>这里的<code>for..in</code>循环在其他语言中就是一个块级的作用域，但是Javascript并不买它的帐，于是最后在方法中调用的num就变成了整个作用域中最后的状态(3)。解决的办法就是在循环中创建闭包，让num当成参数传入闭包，那么它在方法作用域中就不会受外部的变化而改变(实际上完全可以当成一个新的变量，不信你传个object进去，在闭包中的任何修改，都不会对外部作用域的object产生影响的)。</p>

<p>coffeescript用<code>do</code>关键字为我们将这种操作最简化，所以，尝试一下吧。</p>

<h2 id="section">参考文档</h2>

<ul>
  <li><a href="http://stackoverflow.com/questions/10810815/variable-scope-in-coffeescript-for-loop">Variable scope in coffeescript for loop?</a></li>
  <li><a href="http://rzrsharp.net/2011/06/27/what-does-coffeescripts-do-do.html">What Does Coffeescript’s “Do” Do?</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
