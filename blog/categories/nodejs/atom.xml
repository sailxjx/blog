<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nodejs | CodeBean]]></title>
  <link href="http://jingxin.me/blog/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://jingxin.me/blog/"/>
  <updated>2014-08-31T18:38:02+08:00</updated>
  <id>http://jingxin.me/blog/</id>
  <author>
    <name><![CDATA[Xu Jingxin]]></name>
    <email><![CDATA[sailxjx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[limbo: 简单访问远程数据库]]></title>
    <link href="http://jingxin.me/blog/blog/2014/08/28/limbo-jian-dan-fang-wen-yuan-cheng-shu-ju-ku/"/>
    <updated>2014-08-28T17:41:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2014/08/28/limbo-jian-dan-fang-wen-yuan-cheng-shu-ju-ku</id>
    <content type="html"><![CDATA[<p><img src="https://dn-talk.oss.aliyuncs.com/site/images/workspace-c16d9d49.jpg" alt="简聊一下 轻松协作" /></p>

<p>对于 nodejs 生态来说，使用 mongoose 作为 Model 模块是再好不过的一件事，其一大特点就是简洁优雅的 Schema 定义，提供了每个键值的类型验证，数据验证，索引声明，虚拟键，并自带实例化方法的扩展，大大节省了开发的成本。但是在考虑开放数据的时候，一切就显得不那么美好了。</p>

<p>在打造<a href="https://talk.ai/">简聊</a>这款应用的过程中，我们就实实在在的遇到了这样的问题。由于需要使用 <a href="https://www.teambition.com/">Teambition</a> 的用户和团队数据，并且当<a href="https://talk.ai/">简聊</a>更新了用户数据之后，在 <a href="https://www.teambition.com/">Teambition</a> 中能实时的将这些更新推送到用户那里。按照惯例，我们最初使用的是 restful 接口。</p>

<h2 id="restful-">第一阶段，使用 restful 接口</h2>

<p>restful 接口的应用面最广，但是仍然存在很多不足，比如接口在参数和结构上限制较多，在考虑修改接口 api 的时候，往往会顾虑客户端的兼容性，而一旦客户端程序有新的需求，则需等待接口的更新。另一个麻烦的地方是需要做签名校验，对于内部的应用来说，我们完全可以通过防火墙来控制特定 ip 对端口的访问，签名在此处就显得有点多余。</p>

<h2 id="schema">第二阶段，单独拆封 Schema</h2>

<p>然后我们想到了将 Schema 拆封成一个单独的仓库，nodejs 有良好的模块管理，在不同的应用中，我们只需要将这些模块引入进来，既做到同步更新，又做到 DRY。相对于 restful 接口的缺点就是，对于数据的调用入口过多，而且应用之间互相是不知情的。例如在<a href="https://talk.ai/">简聊</a>中有更新用户数据，在 <a href="https://www.teambition.com">Teambition</a> 中就无法得知，并推送给其他客户端。</p>

<h2 id="rpc">第三阶段，远程过程调用（rpc）</h2>

<p>这个阶段和 restful 接口其实类似，我们在 <a href="https://www.teambition.com">Teambition</a>  的后端进程中将一些接口方法暴露出来，这样我们的客户端程序就能通过简单的 rpc 方式调用这些接口。例如我们导出了 <code>user.update</code> 方法，在客户端代码中使用 <code>rpc.call('user.update', params, callback)</code> 即可调用相应的过程。这样的调用行为与使用本地代码无异，可能是目前能找到的最简单直接的方式了。</p>

<h2 id="rpc--mongoose-">第四阶段，rpc 与 mongoose 的结合</h2>

<p>事情可以变得更简单，由于目的主要是为了操作数据库，所以我们开发了一个模块 <a href="https://github.com/teambition/limbo">limbo</a>，将 mongoose model 中所有方法暴露出来，以命名空间来划分，实现了在客户端与服务端程序一致的使用体验。</p>

<p>例如我们在服务端程序中使用 limbo 连接 mongodb，只需要做如下声明：（以下的代码都以 coffeescript 作为示例）</p>

<p>```coffeescript
limbo = require ‘limbo’</p>

<h1 id="schema-1">定义 Schema</h1>
<p>UserSchame = (Schema) -&gt;
  # 这里的 Schema 即 mongoose.Schema
  new Schema
    name: String
    email: String</p>

<h1 id="use-">use 方法用作区分不同数据库连接的命名空间，一般参数选择数据库名就行</h1>
<p>db = limbo.use(‘test’).connect(‘mongodb://localhost:27017/test’).load ‘User’, UserSchema
```</p>

<p>使用方式就与 mongoose 一致了</p>

<p><code>coffeescript
user = db.user
# user 是一个 limbo 中用于封装 model 的一个对象，你可以直接使用 user.model 来直接调用 mongoose model
user.findOne _id: 'xxxx'
user.create name: 'xxx', email: 'yyy'
</code></p>

<p>下面是 limbo 中最激动人心的地方，你可以导出一个 collection 中的所有方法到 rpc server 中，只需要通过一个简单的声明</p>

<p><code>coffeescript
limbo.use('test').bind(7001).enableRpc()
</code></p>

<p>下面我们就要提到如何在客户端程序中调用这些方法</p>

<p>```coffeescript
# 在客户端也需要初始化一个 limbo 命名空间，需要与服务端一致，链接改为服务端的域名和端口号
db = limbo.use(‘test’).connect(‘tcp://localhost:7001’)</p>

<h1 id="rpc-1">下面有两种方式来使用 rpc</h1>
<p># 1. 使用 call 方法
db.call ‘user.findOne’, _id: ‘xxxx’, -&gt;
# 2. 使用方法链
db.user.findOne _id: ‘xxxx’, -&gt;
# 第二种方式存在一个延迟，必须要在 limbo 与服务端程序握手成功之后才可以使用，
# 否则会抛出一个对象不存在的异常，不过在一般的应用中，
# 初始化所需的时间都会长于这个链接所需时间，所以延迟可以忽略不计了
```</p>

<p>可以看出，上面的第二种方式与服务端在本地使用 mongoose 的方式一模一样，这种黑魔法式的调用方式应该是广大码农喜闻乐见的。</p>

<p>limbo 另一个值得称道的功能是可以在服务端程序监听这些远程调用的事件，这得益于 nodejs 的 event 对象，limbo 本身就继承于 EventEmitter 对象，所以我们在每次远程调用后会触发一个事件给服务端程序，而在服务端只需要简单的监听这个事件即可</p>

<p><code>coffeescript
limbo.on 'test.user.findOne', (user) -&gt; ...
</code></p>

<p>正是这种 rpc 加事件反馈的机制，让<a href="https://talk.ai/">简聊</a>和 <a href="https://www.teambition.com">Teambition</a> 可以实现简单实时的数据交换。我们将 <a href="https://github.com/teambition/limbo">limbo</a> 托管在 github 上开源，是深知它还存在很多可以改进的地方，所以不免庸俗的说一句，欢迎 issue 和 pr~</p>

<p>最后，欢迎访问我们的新产品<a href="https://talk.ai">简聊</a>，一款基于话题的轻量级协作应用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回调 vs 协同程序]]></title>
    <link href="http://jingxin.me/blog/blog/2014/04/19/hui-diao-vs-xie-tong-cheng-xu/"/>
    <updated>2014-04-19T15:44:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2014/04/19/hui-diao-vs-xie-tong-cheng-xu</id>
    <content type="html"><![CDATA[<blockquote>
  <p>原文地址：<a href="https://medium.com/code-adventures/174f1fe66127">Callbacks vs Coroutines</a></p>
</blockquote>

<p>最近 Google V8 引擎的一个补丁提供了 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">ES6 生成器</a>，一篇叫做<a href="http://jlongster.com/A-Study-on-Solving-Callbacks-with-JavaScript-Generators">“用 Javascript 生成器来解决回调问题的研究”</a>的文章引发了很大的争议。虽然生成器到目前为止仍然需要 <code>--harmony</code> 或 <code>--harmony-generators</code> 选项才能激活，但是它已经值得你跃跃欲试！在这篇文章中我想要阐述的是自己对于<a href="http://en.wikipedia.org/wiki/Coroutine">协同程序</a>的体验，并且说明为什么我认为它们是一种好方法。</p>

<h2 id="section">回调和生成器</h2>
<p>在认识回调和生成器之间的不同之前，我们先来看看生成器在 Nodejs 或浏览器这种由回调主宰的环境中是怎样发挥作用的。</p>

<p>首先生成器是回调的一种扩展，有些类型的回调就是用来“模拟”生成器的。这些“futures”，“thunks”，或“promises” —— 无论你怎么称呼，都是用来延迟执行一小段逻辑的，就好比你 yield 了一个变量然后由生成器来处理其他的部分。</p>

<p>一旦这些变量 yield 给了调用方，这个调用方等待回调然后重新回到生成器。见仁见智，生成器的原理和回调其实是一样的，然而下面我们会说到使用它的一些好处。</p>

<p>假如你还是不太清楚该怎么使用生成器，这里有一个简单的例子实现了由生成器来控制流程。</p>

<p>```javascript
var fs = require(‘fs’);
function thread(fn) {
  var gen = fn();
  function next(err, res) {
    var ret = gen.next(res);
    if (ret.done) return;
    ret.value(next);
  }</p>

<p>next();
}
thread(function *(){
  var a = yield read(‘app.js’);
  var b = yield read(‘package.json’);
  console.log(a);
  console.log(b);
});
function read(path) {
  return function(done){
    fs.readFile(path, ‘utf8’, done);
  }
}
```</p>

<h2 id="section-1">为什么协同程序会使代码更健壮</h2>

<p>对于传统的浏览器或 Nodejs 环境，协同程序在自己的堆栈上运行每个“纤程”。这些纤程的实现各不相同，但是它们只需要一个很小的栈空间就能初始化（大约4kb），然后随需求增长。</p>

<p>为什么这样棒极了？错误处理！假如你使用过 Nodejs， 你就会知道错误处理不是那么简单。有些时候你会得到多个包含未知边际效应的回调，或者完全忘了回调这回事并且没有正确的处理和汇报异常。也许你忘了监听一个“error”事件，这样的话它就变成了一个未捕获的异常而让整个进程挂掉。</p>

<p>有些人喜欢使用进程，而且这样也挺好，但是作为一个在早期就使用 Nodejs 的人来说，在我看来这种流程有很多地方值得改进。Nodejs 在很多方面都很出色，但是这个就是它的阿喀琉斯之踵。</p>

<p>我们用一个简单的例子来看看由回调来读写同一个文件：</p>

<p><code>javascript
function read(path, fn) {
  fs.readFile(path, 'utf8', fn);
}
function write(path, str, fn) {
  fs.writeFile(path, str, fn);
}
function readAndWrite(fn) {
  read('Readme.md', function(err, str){
    if (err) return fn(err);
    str = str.replace('Something', 'Else');
    write('Readme.md', str, fn);
  });
}
</code></p>

<p>你可能会想这看起来也没那么糟糕，那是因为你整天看到这样的代码！好吧这是错误的:)为什么？应为大多数 node 核心方法，和多数第三方库都没有 try/catch 他们的回调。</p>

<p>下面的代码会抛出一个未捕获异常而且没有任何方法能捕获它。就算内核检测到这个异常并且告诉调用方这可能是一个错误点，大多数回调都有未知的行为。</p>

<p><code>javascript
function readAndWrite(fn) {
  read('Readme.md', function(err, str){
    throw new Error('oh no, reference error etc');
    if (err) return fn(err);
    str = str.replace('Something', 'Else');
    write('Readme.md', str, fn);
  });
}
</code></p>

<p>所以生成器是怎么来优化这一点的？下面的代码片段用生成器和 <a href="https://github.com/visionmedia/co">Co</a> 库来实现了相同的逻辑。你可能会想“这只是一些愚蠢的语法糖而已” - 但是你错了。只要我们将生成器传给 <code>Co()</code> 方法，所有委派给调用方的 yields，特别是强健的错误处理都会由 Co 来委派。</p>

<p><code>javascript
co(function *(){
  var str = yield read('Readme.md')
  str = str.replace('Something', 'Else')
  yield write('Readme.md', str)
})
</code></p>

<p>就像下面这样，Co 这样的库会将异常“抛”回给他们原本的流程，这意味着你可以用 try/catch 来捕获异常，或者任其自流由最后 Co 的回调来处理这些错误。</p>

<p><code>javascript
co(function *(){
  try {
    var str = yield read('Readme.md')
  } catch (err) {
    // whatever
  }
  str = str.replace('Something', 'Else')
  yield write('Readme.md', str)
})
</code></p>

<p>在编写 Co 的时候貌似只有它实现了健壮的错误处理，但是假如你看一下 Co 的<a href="https://github.com/visionmedia/co/blob/master/index.js#L30">源代码</a>你会注意到所有的 try/catch 代码块。假如你用生成器你需要将 try/catch 添加到每个你用过的库中，来保证代码的健壮性。这就是为什么在今天看来，用 Nodejs 编写健壮性代码是一件不可能完成的任务。</p>

<h2 id="section-2">生成器对于协同程序</h2>
<p>生成器有时会被当成“半协同程序”，一个不完善，仅对调用方有效的协同程序。这让使用生成器比协同程序的目的更明确，好比 yield 能被当成“线程”。</p>

<p>协同程序要更加灵活一些，看起来就像是普通代码块，而不需要 yield：</p>

<p><code>javascript
var str = read('Readme.md')
str = str.replace('Something', 'Else')
write('Readme.md', str)
console.log('all done!')
</code></p>

<p>有些人认为完整的协同程序是“危险的”，因为它不清楚哪个方法有没有延迟执行线程。个人来说我认为这种争论很可笑，大部分延迟执行的方法都很明显，比方说从文件或套接字中读写，http 请求，睡眠等等延迟执行不会让任何人感到惊讶。</p>

<p>假如有些不友善的方法，那么你就 “fork” 它们来强迫这些任务变成异步的，就像你在 Go 中做的一样。</p>

<p>在我看来生成器可能比协同程序更危险（当然比回调好得多）——仅仅是忘记一个 yield 表达式就可能让你费解或在它执行下面的代码时导致未知的行为结果。半协同程序和协同程序两者各自有优缺点，但是我很高兴现在至少已经有了其一。</p>

<p>让我们来看看你用生成器可以怎样实现新的构造方法。</p>

<h2 id="section-3">用协同程序实现简单的异步流程</h2>
<p>你已经看到一个简单读/写表达式看起来比回调更优雅，我们来看看更多的内容。</p>

<p>假设所有操作默认按顺序执行简化了模型，有些人声称生成器或协同程序使状态变得复杂化，这事不正确的。用回调处理状态也是一样的。全局变量依然是全局变量，局部变量依然是局部变量，而闭包依然是闭包。</p>

<p>我们用例子来说明这个流程，假设你需要请求一个 web 页面，解析其中的链接，然后同步请求所有的链接并输出他们的 Content-types。</p>

<p>这里是一个使用传统回调的例子，没有使用第三方流程控制库。</p>

<p>```javascript
function showTypes(fn) {
 get(‘http://cloudup.com’, function(err, res){
   if (err) return fn(err);
   var done;
   var urls = links(res.text);
   var pending = urls.length;
   var results = new Array(pending);
   urls.forEach(function(url, i){
     get(url, function(err, res){
       if (done) return;
       if (err) return done = true, fn(err);
       results[i] = res.header[‘content-type’];
       —pending || fn(null, results);
     });
   });
 });
}</p>

<p>showTypes(function(err, types){
  if (err) throw err;
  console.log(types);
});
```</p>

<p>这么简单的一个任务被回调搞得毫无可读性。再加上错误处理，重复回调的预防，存储结果和他们本身的一些回调，你会完全搞不懂这个方法是用来干嘛的。假如你需要使代码更健壮，还需要在最后的方法处加上 try/catch 代码块。</p>

<p>现在下面有一个由生成器实现的相同的 showTypes() 方法。你会看到结果和用回调实现的方法是一样的，在这里例子中 Co 处理了所有我们在上面需要手工处理的错误和结果集的组装。被 urls.maps(get) 方法 yield 的数组被平行执行，但是结果集然后是保持不变的顺序。</p>

<p><code>javascript
function header(field) {
  return function(res){
    return res.headers[field]
  }
}
function showTypes(fn) {
  co(function *(){
    var res = yield get('http://cloudup.com')
    var responses = yield links(res.text).map(get)
    return responses.map(header('content-type'))
  })(fn)
}
</code></p>

<p>我并不是建议所有的 Npm 模块使用生成器并且强制依赖 Co，我仍然建议使用相反的方法 —— 但是在应用层面我强烈推荐它。</p>

<p>我希望这能说明协同程序在编写无阻塞的程序时是一个强有力的工具。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个例子验证 do 在 coffeescript 中干了什么]]></title>
    <link href="http://jingxin.me/blog/blog/2013/08/07/yi-ge-li-zi-yan-zheng-do-zai-coffeescript-zhong-gan-li-shen-me/"/>
    <updated>2013-08-07T17:20:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2013/08/07/yi-ge-li-zi-yan-zheng-do-zai-coffeescript-zhong-gan-li-shen-me</id>
    <content type="html"><![CDATA[<p>使用jslint的时候有可能会见到这样的提示</p>

<blockquote>
  <p>Don’t make functions within a loop</p>
</blockquote>

<p>一直没有太在意这个警告，直到最近做项目的时候还真的碰到了因为这个问题产生的bug。</p>

<p>那么下面就用一个例子来看看在循环中定义方法会产生什么样的后果吧。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">array = </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="k">for</span> <span class="nx">num</span> <span class="k">in</span> <span class="nx">array</span>
</span><span class='line'>  <span class="nx">setTimeout</span> <span class="p">(</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">num</span><span class="p">),</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>得到的结果是’3,3,3’，而不是预期的’1,2,3’，先不说为什么，我们来看看coffeescript给出的解决方案。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">array = </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="k">for</span> <span class="nx">num</span> <span class="k">in</span> <span class="nx">array</span>
</span><span class='line'>    <span class="nx">do</span> <span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>        <span class="nx">setTimeout</span> <span class="p">(</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">num</span><span class="p">),</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在这里不得不佩服<a href="https://github.com/jashkenas">Jeremy Ashkenas</a>的无限创造力，短短一个<code>do</code>，就解决了这么让人纠结的问题。下面来看看编译成javascript之后的结果</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">array</span><span class="p">,</span> <span class="nx">num</span><span class="p">,</span> <span class="nx">_fn</span><span class="p">,</span> <span class="nx">_i</span><span class="p">,</span> <span class="nx">_len</span><span class="p">;</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">_fn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">setTimeout</span><span class="p">((</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}),</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_len</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&amp;</span><span class="nx">lt</span><span class="p">;</span> <span class="nx">_len</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">num</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
</span><span class='line'>    <span class="nx">_fn</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}).</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>下面我们来解释一下为什么上面的代码会有问题，以及这个<code>do</code>为我们做了些啥。</p>

<p>关于javascript的作用域，我们可以看一下<a href="http://rzrsharp.net/2011/06/27/what-does-coffeescripts-do-do.html">这篇文章的引用</a></p>

<blockquote>
  <p>JavaScript’s scopes are function-level, not block-level, and creating a closure just means that the enclosing scope gets added to the lexical environment of the enclosed function.</p>
</blockquote>

<p>大意是说</p>

<blockquote>
  <p>JavaScript的作用域是方法级别，而非块级的。创造一个闭包可以将作用域限定在这个封闭的方法中</p>
</blockquote>

<p>这里的<code>for..in</code>循环在其他语言中就是一个块级的作用域，但是Javascript并不买它的帐，于是最后在方法中调用的num就变成了整个作用域中最后的状态(3)。解决的办法就是在循环中创建闭包，让num当成参数传入闭包，那么它在方法作用域中就不会受外部的变化而改变(实际上完全可以当成一个新的变量，不信你传个object进去，在闭包中的任何修改，都不会对外部作用域的object产生影响的)。</p>

<p>coffeescript用<code>do</code>关键字为我们将这种操作最简化，所以，尝试一下吧。</p>

<h2 id="section">参考文档</h2>

<ul>
  <li><a href="http://stackoverflow.com/questions/10810815/variable-scope-in-coffeescript-for-loop">Variable scope in coffeescript for loop?</a></li>
  <li><a href="http://rzrsharp.net/2011/06/27/what-does-coffeescripts-do-do.html">What Does Coffeescript’s “Do” Do?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 coffeescript 的注意点]]></title>
    <link href="http://jingxin.me/blog/blog/2013/06/13/shi-yong-coffeescript-de-zhu-yi-dian/"/>
    <updated>2013-06-13T14:48:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2013/06/13/shi-yong-coffeescript-de-zhu-yi-dian</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/jashkenas/coffee-script">coffeescript</a>是javascript的一个方言，随着javascript在前后端的流行，它在<a href="https://github.com/languages">github</a>的排名也扶摇直上，最近终于挤掉高帅富<a href="https://github.com/languages/Objective-C">Objective-C</a>跻身前十，可喜可贺。</p>

<p>虽然coffeescript号称”It’s just javascript”，但是相比较而言，仍然是添加了很多有趣的特性，大部分特性都是去粗取精，去伪存真，让js玩家喜闻乐见，让旁观路人不明觉厉，但是也随之带来了一些容易忽视的问题，不得不提一下，以免以后碰到后不知所措。</p>

<h1 id="section">重载的符号</h1>

<p>coffeescript重载了javascript中的一些符号和语法结构，最常用的就是<code>==</code>和<code>in</code>。</p>

<h2 id="section-1"><code>==</code></h2>
<p>在js中最为人诟病的就是<code>==</code>符号表意不明，所以很多严谨的js开发者就强迫自己在比较时尽可能的使用<code>===</code>，coffeescript在这一点上做的更绝，你不能使用<code>===</code>，因为它将所有的<code>==</code>都转化成了<code>===</code>。这样对于一些经常需要在两种语言之间切换的码农来说，就是一种考验了。</p>

<h2 id="in"><code>in</code></h2>
<p>在js中，遍历一个数组或hash对象可以使用<code>for(var i in arr)</code>的语言结构，这个时候遍历得到的<code>i</code>其实是数组的下标或者hash的key。coffeescript对<code>in</code>做了重载，使其更符合自然语义，遍历出的是数组的值和hash的value。同时引入<code>of</code>操作符，可以用它来代替原生的<code>in</code>，遍历出数组的下标，如<code>for i of arr</code>。</p>

<h1 id="class">class</h1>

<p>原生的js中是没有class的概念的，但是有经验的码农会用prototype模型来将方法打包成class，以实现代码的重复利用。coffeescript中提供了class关键词，让类的实现和继承更加简单，但是也由此引发一些问题。假如说上面的问题只是人所共知的新特性的话，下面这些就是需要在编码时注意绕行的坑了。</p>

<h2 id="section-2">变量名与类名</h2>

<p>coffeescript对于类型和变量名并没有强制性的格式要求，这在其他语言中也不会出现问题，因为可以通过类型检查来区分两者，但是在coffeescript中，其实类和变量都是通过<code>var</code>关键词生成的变量，而在coffeescript语法中又禁用了<code>var</code>（这样就无法人为的指定变量的作用域，虽然coffeescript会比较智能的分配的作用域）。这在一般情况下也没有问题，直到碰到了下面的代码：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="k">class</span> <span class="nx">demo</span>
</span><span class='line'>  <span class="nv">foo1: </span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">demo</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">@</span>
</span><span class='line'>  <span class="nv">foo2: </span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>    <span class="nv">demo = </span><span class="p">[]</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">@</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="k">new</span> <span class="nx">demo</span><span class="p">().</span><span class="nx">foo1</span><span class="p">().</span><span class="nx">foo2</span><span class="p">().</span><span class="nx">foo1</span><span class="p">()</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;==&amp;</span><span class="nx">gt</span><span class="p">;</span> <span class="p">[</span><span class="nb">Function</span><span class="o">:</span> <span class="nx">demo</span><span class="p">]</span>
</span><span class='line'><span class="o">==&amp;</span><span class="nx">gt</span><span class="p">;</span> <span class="p">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>同样的两次调用foo1方法，得到的结果却是不同的，这是因为foo2中的变量与类名冲突了，而且他们处于同一个作用域，这样foo2方法就变成了一个隐藏的地雷，踩到就爆炸。避免这种情况的一种做法是在命名上做区分，比如类命名必须以大字母开头，变量必须以小写字母开头，这样就不会造成这两者的混淆。</p>

<h2 id="section-3">类成员变量</h2>

<p>使用类的一个好处就是可以初始化一些变量，让这个类的所有方法共享，而又不会影响外层作用域。但是需要注意的是，javascript中对于数组和对象是引用传递，在coffeescript类中使用这两种类型作为成员变量时，就会产生一些不曾期待的后果。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="k">class</span> <span class="nx">Demo</span>
</span><span class='line'>  <span class="nv">member: </span><span class="p">[]</span>
</span><span class='line'>  <span class="nv">setMember: </span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">@member</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nv">a = </span><span class="k">new</span> <span class="nx">Demo</span>
</span><span class='line'><span class="nx">a</span><span class="p">.</span><span class="nx">setMember</span><span class="p">(</span><span class="err">‘</span><span class="nx">a</span><span class="err">’</span><span class="p">)</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">a</span><span class="p">.</span><span class="nx">member</span>  <span class="c1"># [‘a’]</span>
</span><span class='line'><span class="nv">b = </span><span class="k">new</span> <span class="nx">Demo</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">b</span><span class="p">.</span><span class="nx">member</span>  <span class="c1"># [‘a’]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>当我们使用<code>new</code>关键词的时候，希望得到的是一个干干净净的对象，可是在初始化b的时候我们发现他的成员变量member已经变成了<code>['a']</code>，这是我们不希望看到的。究其原因就是member是一个数组。解决办法是将这些变量的初始化放在coffeescript的构造方法<code>constructor</code>中。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="k">class</span> <span class="nx">Demo</span>
</span><span class='line'>  <span class="nv">constructor: </span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>    <span class="vi">@member = </span><span class="p">[]</span>
</span><span class='line'>  <span class="nv">setMember: </span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">@member</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nv">a = </span><span class="k">new</span> <span class="nx">Demo</span>
</span><span class='line'><span class="nx">a</span><span class="p">.</span><span class="nx">setMember</span><span class="p">(</span><span class="err">‘</span><span class="nx">a</span><span class="err">’</span><span class="p">)</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">a</span><span class="p">.</span><span class="nx">member</span>  <span class="c1"># [‘a’]</span>
</span><span class='line'><span class="nv">b = </span><span class="k">new</span> <span class="nx">Demo</span>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">b</span><span class="p">.</span><span class="nx">member</span>  <span class="c1"># []</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>至于为什么这两种写法会产生不一样的效果，可以将coffeescript编译成js来分析。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>    <span class="p">(</span><span class="nx">use</span> <span class="nx">constructor</span><span class="p">)</span>                                             <span class="o">|</span>    <span class="p">(</span><span class="nx">not</span> <span class="nx">use</span> <span class="nx">constructor</span><span class="p">)</span>
</span><span class='line'>    <span class="mi">5</span>   <span class="nx">Demo</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>                                      <span class="o">|</span>    <span class="mi">5</span>   <span class="nx">Demo</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="mi">6</span>     <span class="kd">function</span> <span class="nx">Demo</span><span class="p">()</span> <span class="p">{</span>                                       <span class="o">|</span>    <span class="mi">6</span>     <span class="kd">function</span> <span class="nx">Demo</span><span class="p">()</span> <span class="p">{}</span>                                   <span class="o">&lt;</span><span class="nx">br</span> <span class="o">/&gt;</span>
</span><span class='line'>    <span class="mi">7</span>       <span class="k">this</span><span class="p">.</span><span class="nx">member</span> <span class="o">=</span> <span class="p">[];</span>                                     <span class="o">|</span>    <span class="mi">7</span>                                                          <span class="o">&lt;</span><span class="nx">br</span> <span class="o">/&gt;</span>
</span><span class='line'>    <span class="mi">8</span>     <span class="p">}</span>                                                       <span class="o">|</span>    <span class="mi">8</span>     <span class="nx">Demo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">member</span> <span class="o">=</span> <span class="p">[];</span>                          <span class="o">&lt;</span><span class="nx">br</span> <span class="o">/&gt;</span>
</span><span class='line'>    <span class="mi">9</span>                                                             <span class="o">|</span>    <span class="mi">9</span>
</span><span class='line'>   <span class="mi">10</span>     <span class="nx">Demo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setMember</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>              <span class="o">|</span>   <span class="mi">10</span>     <span class="nx">Demo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setMember</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="mi">11</span>       <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">member</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>                         <span class="o">|</span>   <span class="mi">11</span>       <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">member</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
</span><span class='line'>   <span class="mi">12</span>     <span class="p">};</span>                                                      <span class="o">|</span>   <span class="mi">12</span>     <span class="p">};</span>                   <span class="o">&lt;</span><span class="nx">br</span> <span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上面是vimdiff对比出的两种不同写法，第一种是使用构造方法<code>constructor</code>的，可以看到member作为Demo方法的私有变量，在没有用<code>new</code>实例化的时候，这个<code>member</code>是不存在的，所以每一次实例化我们都能得到一个全新未开箱的<code>member</code>。但是第二种写法则不同，在没有实例化Demo类的时候，<code>member</code>对象就已经存在，所有无论你实例化Demo多少次，调用的都是同一个<code>member</code>，也就造成了在多个Demo实例中共用一个<code>member</code>的结果。</p>

<h1 id="section-4">后记</h1>

<p>假如让我在javascript和coffeescript两种语言之间选择，我仍然倾向于coffeescript，抛开上面的问题不说，它给人编码的时候带来的愉悦是无法衡量的。So just try it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[node-neo4j 学习笔记]]></title>
    <link href="http://jingxin.me/blog/blog/2013/01/28/node-neo4j-xue-xi-bi-ji/"/>
    <updated>2013-01-28T11:49:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2013/01/28/node-neo4j-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h2 id="node-neo4jhttpsgithubcomthingdomnode-neo4j"><a href="https://github.com/thingdom/node-neo4j">node-neo4j</a></h2>

<h3 id="section">查找节点</h3>
<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">neo4j = </span><span class="nx">require</span> <span class="err">‘</span><span class="nx">neo4j</span><span class="err">’</span>
</span><span class='line'><span class="nv">db = </span><span class="k">new</span> <span class="nx">neo4j</span><span class="p">.</span><span class="nx">GraphDatabase</span><span class="p">(</span><span class="err">‘</span><span class="nx">http</span><span class="o">://</span><span class="nx">localhost</span><span class="o">:</span><span class="mi">7474</span><span class="err">’</span><span class="p">)</span>
</span><span class='line'><span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="nx">err</span> <span class="o">||</span> <span class="o">!</span><span class="nx">node</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">err</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">node</span><span class="p">.</span><span class="nx">data</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
查找节点的api设计的很有dom的风格，与大多数nodejs方法一样，node-neo4j提供的api都是异步的，回调函数中第一个参数都是错误流，第二个因方法而异，<code>getNodeById</code>中的第二个参数node是一个完整的json对象，在这个对象上可以使用node-neo4j针对node的所有方法，要取得或修改node中的成员则可以通过<code>node.data</code>获取。</p>

<h3 id="section-1">创建关系</h3>
<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="c1"># 创建节点</span>
</span><span class='line'><span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">n1</span><span class="p">)</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">n2</span><span class="p">)</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>       <span class="c1">#当前节点                 目标节点 关系类型 关系结构</span>
</span><span class='line'>        <span class="nx">n2</span><span class="p">.</span><span class="nx">createRelationshipTo</span> <span class="nx">n1</span><span class="p">,</span> <span class="err">‘</span><span class="nx">isdogof</span><span class="err">’</span><span class="p">,</span> <span class="p">{</span><span class="nv">ctime: </span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()},</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">r</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">h1</span> <span class="nx">id</span><span class="o">=</span><span class="s">&quot;section-2&quot;</span><span class="o">&gt;</span><span class="err">查找节点</span><span class="o">&lt;/</span><span class="nx">h1</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">db</span><span class="p">.</span><span class="nx">getRelationshipById</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">rel</span><span class="p">)</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">rel</span>          <span class="o">&lt;</span><span class="nx">br</span> <span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
目前通过<code>node-neo4j</code>创建关系只能在node上做文章，通过<code>createRelationshipFrom</code>和<code>createRelationshipTo</code>来创建点对点的关系。客户端的作者很坑爹的在Graphdatabase._coffee中声明了一个<code>createRelationship</code>方法，但是没有实现，调用这个方法是不会有任何效果的。</p>

<h3 id="section-3">查询关系</h3>
<p><code>node-neo4j</code>中声明了四种方式来获取关于某个节点的关系，分别是
* node.getRelationships 获取与节点相关的所有关系
* node.outgoing         获取以该节点为起点的关系
* node.incoming         获取以该节点为终点的关系
* node.all              同getRelationships
这些方法最终都调用<code>_getRelationships</code>，虽然我们也能直接调用这个方法，不过既然人家已声明其为私有，那还是直接调用上面的方法比较好。下面举例：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">nBran</span><span class="p">)</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">nSnow</span><span class="p">)</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>        <span class="nx">nSnow</span><span class="p">.</span><span class="nx">incoming</span> <span class="err">‘</span><span class="nx">islittlebrotherof</span><span class="err">’</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">rel</span><span class="p">)</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">rel</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">data</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>假如关系类型(type)不存在或者没有关联到这个节点的关系，getRelationships返回rel为一个空数组。否则返回节点在这个类型的所有关系数组，<code>rel[0].data</code>则是获取关系的属性。</p>

<h3 id="section-4">根据关系种类查询</h3>
<p>neo4j的关系中还有个比较重要的概念是种类(type)，在<code>Cypher</code>中可以通过<code>type()</code>方法来获取某个关系的种类
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">r</span> <span class="o">=</span> rel<span class="o">(</span>*<span class="o">)</span> <span class="k">return </span><span class="nb">type</span><span class="o">(</span>r<span class="o">)</span>;
</span><span class='line'>+———————+
</span><span class='line'>| <span class="nb">type</span><span class="o">(</span>r<span class="o">)</span>             |
</span><span class='line'>+———————+
</span><span class='line'>| “islittlebrotherof” |
</span><span class='line'>+———————+
</span><span class='line'>1 row
</span><span class='line'>0 ms
</span></code></pre></td></tr></table></div></figure></notextile></div>
在<code>node-neo4j</code>中，<code>getRelationships</code>可以获取某节点某个种类的关系，
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nx">db</span><span class="p">.</span><span class="nx">getNodeById</span> <span class="mi">13</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">bran</span><span class="p">)</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">bran</span><span class="p">.</span><span class="nx">getRelationships</span> <span class="err">‘</span><span class="nx">islittlebrotherof</span><span class="err">’</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">rel</span><span class="p">)</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">rel</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">data</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
callback中返回的是一个关系对象数组。</p>

<h3 id="query">万能的query</h3>
<p>db对象上有一个万能的<code>query</code>方法，就是直接通过<code>Cypher</code>语句得到查询结果啦，这个弥补了作者很多没有实现的方法。</p>

]]></content>
  </entry>
  
</feed>
