<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nodejs | CodeBean]]></title>
  <link href="http://jingxin.me/blog/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://jingxin.me/blog/"/>
  <updated>2016-06-18T21:02:21+08:00</updated>
  <id>http://jingxin.me/blog/</id>
  <author>
    <name><![CDATA[Xu Jingxin]]></name>
    <email><![CDATA[sailxjx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何写出好爬虫]]></title>
    <link href="http://jingxin.me/blog/blog/2015/12/07/ru-he-xie-chu-hao-pa-chong/"/>
    <updated>2015-12-07T18:21:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2015/12/07/ru-he-xie-chu-hao-pa-chong</id>
    <content type="html"><![CDATA[<p>写爬虫可以说是一个程序员必修课，因为上手简单，成效明显，深受各大培训机构和教学材料的青睐。于是无数新手也加入了造轮子的队列，写的爬虫满天飞。</p>

<p>说爬虫上手简单，是有原因的，只要了解了 http 请求和 html/xml 结构，谁都能做出一个可用的爬虫，再辅以一个好用的请求库和解析库，完成老板的任务简直就是分分钟的事情，老婆孩子再也不用担心我加班了有木有？</p>

<p>———————- 下面是转折的分割线 ———————-</p>

<p>但是，这样写出来的爬虫真的达到了生产级别吗，答案是否定的。码农界常说的一个词是 Robust，来看看怎样让我们的爬虫变得更加 Robust</p>

<h2 id="section">编码问题</h2>

<p>互联网上存在各种各样的编码，虽然现代的浏览器都能智能的识别编码，但是对于爬虫来说它们却是需要跨过的第一道坎。</p>

<p>多数网站都会在响应头中给出本站编码，我们只需要检测响应头中 content-type encoding 就能准确的得到站点的编码。再不济也会在 html meta 中标识出编码内容，检测 meta 中的 charset 属性就行了，例如 <code>&lt;meta http-equiv="Content-Type" content="text/html" charset="utf-8"&gt;</code> 就表示该网页使用的是 utf8 编码。</p>

<p>如果站长丧心病狂到什么提示都不给，那么我们就只能靠猜了，iconv 是一个不错的库，可以检测文本内容的编码，而且准确率比较高，在各种语言中也能找到对应的 iconv 模块。</p>

<p>如果最后还是检测不出对应的编码，那就默认当做目前最常见的 utf8 编码吧，<a href="https://github.com/danmactough/node-feedparser/blob/master/examples/iconv.js">这段简单的代码片段</a>可以说明检测编码的过程。</p>

<h2 id="section-1">压缩问题</h2>

<p>某些网站会在响应内容是使用 gzip 压缩以便节约流量（例如整天被爬的知乎同学），遇到这种站点，爬虫也需要做特殊的解析才能得到最后的纯文本内容。</p>

<p>解析的过程与检测编码类似，先通过响应头检测网站使用的是什么压缩编码，然后使用对应的解压缩方法解压内容即可，使用压缩的网站会在响应头 Content-Encoding 中加上压缩编码，例如 Content-Type: gzip 就表示该网页使用的是 gzip 压缩，<a href="https://github.com/danmactough/node-feedparser/blob/master/examples/compressed.js">这段代码</a>可以说明检测压缩编码的过程</p>

<h2 id="user-agent">添加 User-Agent</h2>

<p>下面的问题就是与内容提供者斗智斗勇的过程了，有些站点会识别爬虫行为然后屏蔽掉一些爬虫的请求。我们要做的就是尽量让我们的爬虫看起来，像个人。</p>

<p>首先请求头中必须添加 User-Agent，如果你还不知道 user-agent 是什么，出门左转看了wiki再回来。由于 ip 轻易无法修改，但是 user-agent 却是可以任意修改的，如果内容网站条件较宽，只使用 user-agent 识别爬虫的话，那么我们就乖乖的写上一些常用浏览器的 user-agent，如果你不知道有哪些，<a href="http://www.useragentstring.com/pages/All/">去这里</a>可以查到所有的 ua。</p>

<p>至于专业的搜索引擎，内容网站欢迎还来不及，怎么会屏蔽呢。所以它们一般都会使用自己的特定 ua 标识，例如 Baidu spider，Google spider 等，普通野生的爬虫就不要参考了。</p>

<h2 id="section-2">合并相同请求</h2>

<p>如果我们的内容提供者地址是由用户添加的，难免碰到会有重复地址的情况，这时最好就是将这些链接给合并掉，以免重复请求。例如 A 和 B 同时添加了链接 abc，那么我们的爬虫只需请求一次 abc 然后将内容分别返回给 A 和 B 就行了，或者请求 abc 之后缓存一段时间，当其他用户添加这个链接时，返回缓存内容就行了。我们的宗旨就是用最少的请求干最多的事。</p>

<h2 id="section-3">错误</h2>

<p>有的时候爬虫在请求网站时会碰到一些错误，这些有的是由于内容网站的错误，有些是由于权限或受到了屏蔽，在大多数情况下面这些错误都可以通过 http status code 来分辨（如果不知道什么是 http status code，再出门去看一遍 wiki）。</p>

<p>如果区分每个 http status code 太麻烦，有一个基本的原则就是看 code 前缀，例如：</p>

<ul>
  <li>3xx 开头的表示这个地址被跳转到其他地址了，爬虫可以根据响应头跟进，很多库自动做了跳转跟进，返回最终网址的内容，所以找到合适的请求库最重要，例如<a href="https://github.com/request/request">request</a></li>
  <li>4xx 表示内容网站拒绝了你的请求，有可能是你的 ip 被屏蔽，或者这个地址需要验证。遇到这种情况，可以等待一段时间再次请求，并逐渐增加请求间隔，直到返回的响应头为 2xx。一般的屏蔽会在一段时间后解除。</li>
  <li>5xx 表示内容网站挂了或你的服务器网络挂了，遇到这种情况，我们能做的就只能等，等内容网站修复错误。</li>
</ul>

<p>连续错误次数过多的网站就不要再爬取了，以便节约带宽资源</p>

<h2 id="section-4">请求频率</h2>

<p>上面提到了错误重试的问题，这一节我们聊一下调整请求频率以防止被屏蔽。</p>

<p>如果你的爬虫现在可以正常访问内容网站，不要玩的太 high，尽量约束一下自己的请求频率，一分钟一次已经是很多网站能够忍耐的底线了，如果内容更新不频繁，可以设置为 20 分钟一次。</p>

<p>此外，还能制定一些比较聪明的策略，例如发现网站内容较上次没有更新，那么下次请求间隔设置为 1.5 倍，依次递增，直到你设定的请求间隔上限。如果内容有了更新，再把请求间隔重置为最小值。这样既不影响及时得到网站的更新，也会尽量减小被屏蔽的风险。</p>

<p>如果你的爬虫 ip 已经被屏蔽了（怎样判断被屏蔽请参考上文），那么就消停一会儿，设定一个较长的请求间隔再尝试，直至解除屏蔽。</p>

<h2 id="section-5">分布式</h2>

<p>爬虫受制于单台服务器的带宽和请求数限制，往往在高配置的机器中也无法发挥最大的效能。所以将爬虫分布在多台低配高带宽的服务器上是比较合理的做法。至于如果分布式，这个话题聊起来就没完了，可以使用最基础的消息队列（例如 zmq, rabbitmq 或 redis）和经典的 master/worker 结构，来实现多台机器协同工作。</p>

<h2 id="section-6">大数据</h2>

<p>大数据没有以前那么火了，但是为了提高这篇文章的逼格，仍然是一个值得一提的话题。</p>

<p>我们知道互联网的世界是开放的，很多内容其实不需要我们亲自去爬取，搜索引擎已经帮我们收录了这些网站内容，合理利用搜索引擎的 site: 命令，有时候可以得到比亲自爬取更满意的结果。</p>

<h2 id="dont-be-evil">Don’t be evil</h2>

<p>大部分网站会在站点根目录下包含一个 robots.txt 文件，可以通过 http://域名/robots.txt 来访问，里面的内容表明了站长对于爬虫的限定，如果发现某些内容是站长不希望你爬取的，那么还是乖乖绕过吧。如果不知道 robots.txt 是什么，再去一次 wiki。</p>

<h2 id="section-7">结语</h2>

<p>以上简单介绍了一下我多年以来作为一名非大数据非分布式非社区明星开发的经验，抛砖引玉，希望能对读者有所帮助。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js 沙盒]]></title>
    <link href="http://jingxin.me/blog/blog/2015/06/18/node-dot-js-sha-he/"/>
    <updated>2015-06-18T16:36:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2015/06/18/node-dot-js-sha-he</id>
    <content type="html"><![CDATA[<h2 id="section">为什么要使用沙盒</h2>

<p>eval 在很多语言中都是一个很有用的方法，合理利用它可以编写出很多让人拍案叫绝的功能。但是由于它实在过于开放和危险，很多人给它冠上了 <strong>evil</strong> 的称号。</p>

<p>使用沙盒可以给 eval 类的功能增加一些条件限制，让它变得更加安全，而不丢失其灵活性。</p>

<p>Node.js 中提供的 vm 模块可以轻松实现沙盒的功能。</p>

<h2 id="vm-">如何使用 vm 模块</h2>

<h3 id="vmruninthiscontext"><code>vm.runInThisContext</code></h3>

<p><code>vm.runInThisContext</code> 可以执行代码并得到它的返回值，被执行的代码没有权限访问本地对象，但是可以访问全局对象。相比之下， eval 则有权限访问上下文中的对象。</p>

<p>```javascript
var localVar = ‘initial value’;</p>

<p>var vmResult = vm.runInThisContext(‘localVar = “vm”;’);
console.log(‘vmResult: ‘, vmResult);
console.log(‘localVar: ‘, localVar);</p>

<p>var evalResult = eval(‘localVar = “eval”;’);
console.log(‘evalResult: ‘, evalResult);
console.log(‘localVar: ‘, localVar);</p>

<p>// vmResult: ‘vm’, localVar: ‘initial value’
// evalResult: ‘eval’, localVar: ‘eval’
```</p>

<h3 id="vmcreatecontext--vmrunincontext"><code>vm.createContext</code> 与 <code>vm.runInContext</code></h3>

<p><code>vm.createContext</code> 则是真正创造了一个沙盒对象，使用 <code>vm.runInContext</code> 可以完全让代码在这个沙盒环境中运行。</p>

<p>```javascript
var util = require(‘util’);
var vm = require(‘vm’);</p>

<p>sandbox = vm.createContext({ globalVar: 1 });</p>

<p>for (var i = 0; i &lt; 10; ++i) {
    vm.runInContext(‘globalVar *= 2;’, sandbox);
}</p>

<p>console.log(util.inspect(sandbox));
console.log(global.globalVar);</p>

<p>// { globalVar: 1024 }
// undefined
```</p>

<h2 id="vm--1">vm 的具体应用</h2>

<p><a href="https://github.com/teambition/configd"><code>configd</code></a> 是我为公司部署流程开发的一个小工具，功能是将各种来源的配置文件合并成一个 json 文件。由于它支持 <code>ssh</code>, <code>git</code>, <code>http</code> 等多种来源的配置或代码，所以需要在工具内部来执行这些代码以实现和本地 <code>require</code> 类似的效果。如果用 <code>eval</code>，那么除却风险问题，<code>module.exports</code> 也不能生效了。所以在工具中使用了 vm 模块来执行这些代码。</p>

<p>```coffeescript
_eval = (js, options = {}) -&gt;
  sandbox = vm.createContext()
  sandbox.exports = exports
  sandbox.module = exports: exports
  sandbox.global = sandbox
  sandbox.require = require
  sandbox.__filename = options.filename or ‘eval’
  sandbox.__dirname = path.dirname sandbox.__filename</p>

<p>vm.runInContext js, sandbox</p>

<p>sandbox.module.exports</p>

<p>data = _eval js
```</p>

<h2 id="section-1">参考资料</h2>

<p><a href="https://nodejs.org/api/vm.html">Executing JavaScript</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一次神奇的 nodejs debug 经历]]></title>
    <link href="http://jingxin.me/blog/blog/2014/09/13/yi-ci-shen-qi-de-nodejs-debug-jing-li/"/>
    <updated>2014-09-13T18:09:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2014/09/13/yi-ci-shen-qi-de-nodejs-debug-jing-li</id>
    <content type="html"><![CDATA[<p>中秋之后，服务器上老是出现 cpu 爆满的情况，难道服务器也闹情绪想休假。当然这种情况是很紧急的，所以马上就着手排查。</p>

<p>还没找出问题，又有同学报测试机上也有这种情况，但是应用进程不同。想到有可能这两件事是有关联的，所以先从测试机开始排查。</p>

<h2 id="settimeout--bug">问题一， setTimeout 的 bug</h2>

<p>测试机上的问题很好排查，每次进程重启后立刻飙升到 100%，通过万能的 log 大法，很快就定位到问题。应用中使用了 <a href="https://github.com/visionmedia/axon">axon</a> 模块作为消息中间件，在连接不成功时会用 <code>setTimeout</code> 尝试重连，间隔由最初的 100ms 开始每次乘以 1.5，这样在三次之后间隔就变成了 337.5ms，nodejs 有<a href="https://github.com/joyent/node/issues/5796">一个 bug</a>，Timer 函数中出现小数时会导致死循环，我们用的是 0.10.30 版本，这个 bug 依然可以重现。所以解决办法也很简单了，直接 <a href="https://github.com/visionmedia/axon/commit/68a23cacd5fd94527b52738b0d43876187ee82e9#diff-595746af128d06d3cac45cb001ad2219R280">round 一下</a>就可以了。以后在使用 Timer 类函数时也需要注意不要出现小数哦。</p>

<h2 id="section">问题二，正则表达式的效率问题</h2>

<p>由于 axon 在生产环境中也有使用，我们就将所有的版本都进行了升级，以为万事大吉。结果却不遂人愿，生产环境中的几个进程在启动后，时不时会出现负载 100% 的情况，这种可能性分析起来就很复杂了。我们依次尝试了 node-inspector，node-heapdump 等工具，都没有找到原因（实话说，以前用这些 debug 内存问题时也是一无所获，nodejs 的 debug 工具实在鸡肋）。也没有重现线上的问题。</p>

<p>一个有趣的现象是，我发现每次进程重启之后，飙升到 100% 的时间不定，但是每次都是瞬间从 0 到 100%。这种现象说明导致问题的原因可能不是程序内部产生，而是由外力产生，这个外力是什么呢，其实就是请求。再一次借助万能 log 大法，express 的 log 只能记录有响应的请求，如果一个请求在中途陷入了死循环，那么就得不到 express 的 log，所以我们自己写了一个中间件，在 express 的最前部引入，只打印出请求的链接。</p>

<p>接下来问题就很明显了（其实也破费一番周折），每当出现某一请求时，程序就陷入了死循环，屡试不爽。一步步排查下来，发现问题出现在 <a href="https://github.com/leizongmin/js-xss">xss</a> 模块中，其中的一个正则表达式，在匹配某些字符串时出现了问题：</p>

<ul>
  <li>表达式：<code>/&lt;!--(.|\s)*?--&gt;/gm</code></li>
  <li>测试字符串：<code>&lt;!--                                    </code></li>
</ul>

<p>当表达式未找到匹配内容时，效率指数级的下降，特别是在多个重复空格和子表达式时。这个原因解释起来就比较复杂了。<a href="http://swtch.com/~rsc/regexp/regexp1.html">大神的一篇文章</a>很好的解释了这个问题，有时间我要翻译一下，一定又有很多收获。</p>

<p>解决的方法很简单，在<a href="https://github.com/leizongmin/js-xss/commit/161f9510aab78aba83cf75c54c0dafd3a0436a84#diff-666d669efc2fef279da605aba853e681L354">这个 Pull Request</a>中可以找到。看来以后使用正则表达式的时候得过留个心眼了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[limbo: 简单访问远程数据库]]></title>
    <link href="http://jingxin.me/blog/blog/2014/08/28/limbo-jian-dan-fang-wen-yuan-cheng-shu-ju-ku/"/>
    <updated>2014-08-28T17:41:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2014/08/28/limbo-jian-dan-fang-wen-yuan-cheng-shu-ju-ku</id>
    <content type="html"><![CDATA[<p><img src="https://dn-talk.oss.aliyuncs.com/site/images/workspace-c16d9d49.jpg" alt="简聊一下 轻松协作" /></p>

<p>对于 nodejs 生态来说，使用 mongoose 作为 Model 模块是再好不过的一件事，其一大特点就是简洁优雅的 Schema 定义，提供了每个键值的类型验证，数据验证，索引声明，虚拟键，并自带实例化方法的扩展，大大节省了开发的成本。但是在考虑开放数据的时候，一切就显得不那么美好了。</p>

<p>在打造<a href="https://talk.ai/">简聊</a>这款应用的过程中，我们就实实在在的遇到了这样的问题。由于需要使用 <a href="https://www.teambition.com/">Teambition</a> 的用户和团队数据，并且当<a href="https://talk.ai/">简聊</a>更新了用户数据之后，在 <a href="https://www.teambition.com/">Teambition</a> 中能实时的将这些更新推送到用户那里。按照惯例，我们最初使用的是 restful 接口。</p>

<h2 id="restful-">第一阶段，使用 restful 接口</h2>

<p>restful 接口的应用面最广，但是仍然存在很多不足，比如接口在参数和结构上限制较多，在考虑修改接口 api 的时候，往往会顾虑客户端的兼容性，而一旦客户端程序有新的需求，则需等待接口的更新。另一个麻烦的地方是需要做签名校验，对于内部的应用来说，我们完全可以通过防火墙来控制特定 ip 对端口的访问，签名在此处就显得有点多余。</p>

<h2 id="schema">第二阶段，单独拆封 Schema</h2>

<p>然后我们想到了将 Schema 拆封成一个单独的仓库，nodejs 有良好的模块管理，在不同的应用中，我们只需要将这些模块引入进来，既做到同步更新，又做到 DRY。相对于 restful 接口的缺点就是，对于数据的调用入口过多，而且应用之间互相是不知情的。例如在<a href="https://talk.ai/">简聊</a>中有更新用户数据，在 <a href="https://www.teambition.com">Teambition</a> 中就无法得知，并推送给其他客户端。</p>

<h2 id="rpc">第三阶段，远程过程调用（rpc）</h2>

<p>这个阶段和 restful 接口其实类似，我们在 <a href="https://www.teambition.com">Teambition</a>  的后端进程中将一些接口方法暴露出来，这样我们的客户端程序就能通过简单的 rpc 方式调用这些接口。例如我们导出了 <code>user.update</code> 方法，在客户端代码中使用 <code>rpc.call('user.update', params, callback)</code> 即可调用相应的过程。这样的调用行为与使用本地代码无异，可能是目前能找到的最简单直接的方式了。</p>

<h2 id="rpc--mongoose-">第四阶段，rpc 与 mongoose 的结合</h2>

<p>事情可以变得更简单，由于目的主要是为了操作数据库，所以我们开发了一个模块 <a href="https://github.com/teambition/limbo">limbo</a>，将 mongoose model 中所有方法暴露出来，以命名空间来划分，实现了在客户端与服务端程序一致的使用体验。</p>

<p>例如我们在服务端程序中使用 limbo 连接 mongodb，只需要做如下声明：（以下的代码都以 coffeescript 作为示例）</p>

<p>```coffeescript
limbo = require ‘limbo’</p>

<h1 id="schema-1">定义 Schema</h1>
<p>UserSchame = (Schema) -&gt;
  # 这里的 Schema 即 mongoose.Schema
  new Schema
    name: String
    email: String</p>

<h1 id="use-">use 方法用作区分不同数据库连接的命名空间，一般参数选择数据库名就行</h1>
<p>db = limbo.use(‘test’).connect(‘mongodb://localhost:27017/test’).load ‘User’, UserSchema
```</p>

<p>使用方式就与 mongoose 一致了</p>

<p><code>coffeescript
user = db.user
# user 是一个 limbo 中用于封装 model 的一个对象，你可以直接使用 user.model 来直接调用 mongoose model
user.findOne _id: 'xxxx'
user.create name: 'xxx', email: 'yyy'
</code></p>

<p>下面是 limbo 中最激动人心的地方，你可以导出一个 collection 中的所有方法到 rpc server 中，只需要通过一个简单的声明</p>

<p><code>coffeescript
limbo.use('test').bind(7001).enableRpc()
</code></p>

<p>下面我们就要提到如何在客户端程序中调用这些方法</p>

<p>```coffeescript
# 在客户端也需要初始化一个 limbo 命名空间，需要与服务端一致，链接改为服务端的域名和端口号
db = limbo.use(‘test’).connect(‘tcp://localhost:7001’)</p>

<h1 id="rpc-1">下面有两种方式来使用 rpc</h1>
<p># 1. 使用 call 方法
db.call ‘user.findOne’, _id: ‘xxxx’, -&gt;
# 2. 使用方法链
db.user.findOne _id: ‘xxxx’, -&gt;
# 第二种方式存在一个延迟，必须要在 limbo 与服务端程序握手成功之后才可以使用，
# 否则会抛出一个对象不存在的异常，不过在一般的应用中，
# 初始化所需的时间都会长于这个链接所需时间，所以延迟可以忽略不计了
```</p>

<p>可以看出，上面的第二种方式与服务端在本地使用 mongoose 的方式一模一样，这种黑魔法式的调用方式应该是广大码农喜闻乐见的。</p>

<p>limbo 另一个值得称道的功能是可以在服务端程序监听这些远程调用的事件，这得益于 nodejs 的 event 对象，limbo 本身就继承于 EventEmitter 对象，所以我们在每次远程调用后会触发一个事件给服务端程序，而在服务端只需要简单的监听这个事件即可</p>

<p><code>coffeescript
limbo.on 'test.user.findOne', (user) -&gt; ...
</code></p>

<p>正是这种 rpc 加事件反馈的机制，让<a href="https://talk.ai/">简聊</a>和 <a href="https://www.teambition.com">Teambition</a> 可以实现简单实时的数据交换。我们将 <a href="https://github.com/teambition/limbo">limbo</a> 托管在 github 上开源，是深知它还存在很多可以改进的地方，所以不免庸俗的说一句，欢迎 issue 和 pr~</p>

<p>最后，欢迎访问我们的新产品<a href="https://talk.ai">简聊</a>，一款基于话题的轻量级协作应用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回调 vs 协程]]></title>
    <link href="http://jingxin.me/blog/blog/2014/04/19/hui-diao-vs-xie-tong-cheng-xu/"/>
    <updated>2014-04-19T15:44:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2014/04/19/hui-diao-vs-xie-tong-cheng-xu</id>
    <content type="html"><![CDATA[<blockquote>
  <p>原文地址：<a href="https://medium.com/code-adventures/174f1fe66127">Callbacks vs Coroutines</a></p>
</blockquote>

<p>最近 Google V8 引擎的一个补丁提供了 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">ES6 生成器</a>，一篇叫做<a href="http://jlongster.com/A-Study-on-Solving-Callbacks-with-JavaScript-Generators">“用 Javascript 生成器来解决回调问题的研究”</a>的文章引发了很大的争议。虽然生成器到目前为止仍然需要 <code>--harmony</code> 或 <code>--harmony-generators</code> 选项才能激活，但是它已经值得你跃跃欲试！在这篇文章中我想要阐述的是自己对于<a href="http://en.wikipedia.org/wiki/Coroutine">协程</a>的体验，并且说明为什么我认为它们是一种好方法。</p>

<h2 id="section">回调和生成器</h2>

<p>在认识回调和生成器之间的不同之前，我们先来看看生成器在 Nodejs 或浏览器这种由回调主宰的环境中是怎样发挥作用的。</p>

<p>首先生成器是回调的一种扩展，有些类型的回调就是用来”模拟”生成器的。这些”futures”，”thunks”，或”promises” —- 无论你怎么称呼，都是用来延迟执行一小段逻辑的，就好比你 yield 了一个变量然后由生成器来处理其他的部分。</p>

<p>一旦这些变量 yield 给了调用方，这个调用方等待回调然后重新回到生成器。见仁见智，生成器的原理和回调其实是一样的，然而下面我们会说到使用它的一些好处。</p>

<p>假如你还是不太清楚该怎么使用生成器，这里有一个简单的例子实现了由生成器来控制流程。</p>

<p>```javascript
var fs = require(‘fs’);
function thread(fn) {
  var gen = fn();
  function next(err, res) {
    var ret = gen.next(res);
    if (ret.done) return;
    ret.value(next);
  }</p>

<p>next();
}
thread(function *(){
  var a = yield read(‘app.js’);
  var b = yield read(‘package.json’);
  console.log(a);
  console.log(b);
});
function read(path) {
  return function(done){
    fs.readFile(path, ‘utf8’, done);
  }
}
```</p>

<h2 id="section-1">为什么协程会使代码更健壮</h2>

<p>对于传统的浏览器或 Nodejs 环境，协程在自己的堆栈上运行每个”纤程”。这些纤程的实现各不相同，但是它们只需要一个很小的栈空间就能初始化（大约4kb），然后随需求增长。</p>

<p>为什么这样棒极了？错误处理！假如你使用过 Nodejs， 你就会知道错误处理不是那么简单。有些时候你会得到多个包含未知边际效应的回调，或者完全忘了回调这回事并且没有正确的处理和汇报异常。也许你忘了监听一个”error”事件，这样的话它就变成了一个未捕获的异常而让整个进程挂掉。</p>

<p>有些人喜欢使用进程，而且这样也挺好，但是作为一个在早期就使用 Nodejs 的人来说，在我看来这种流程有很多地方值得改进。Nodejs 在很多方面都很出色，但是这个就是它的阿喀琉斯之踵。</p>

<p>我们用一个简单的例子来看看由回调来读写同一个文件：</p>

<p><code>javascript
function read(path, fn) {
  fs.readFile(path, 'utf8', fn);
}
function write(path, str, fn) {
  fs.writeFile(path, str, fn);
}
function readAndWrite(fn) {
  read('Readme.md', function(err, str){
    if (err) return fn(err);
    str = str.replace('Something', 'Else');
    write('Readme.md', str, fn);
  });
}
</code></p>

<p>你可能会想这看起来也没那么糟糕，那是因为你整天看到这样的代码！好吧这是错误的:)为什么？应为大多数 node 核心方法，和多数第三方库都没有 try/catch 他们的回调。</p>

<p>下面的代码会抛出一个未捕获异常而且没有任何方法能捕获它。就算内核检测到这个异常并且告诉调用方这可能是一个错误点，大多数回调都有未知的行为。</p>

<p><code>javascript
function readAndWrite(fn) {
  read('Readme.md', function(err, str){
    throw new Error('oh no, reference error etc');
    if (err) return fn(err);
    str = str.replace('Something', 'Else');
    write('Readme.md', str, fn);
  });
}
</code></p>

<p>所以生成器是怎么来优化这一点的？下面的代码片段用生成器和 <a href="https://github.com/visionmedia/co">Co</a> 库来实现了相同的逻辑。你可能会想”这只是一些愚蠢的语法糖而已” - 但是你错了。只要我们将生成器传给 <code>Co()</code> 方法，所有委派给调用方的 yields，特别是强健的错误处理都会由 Co 来委派。</p>

<p><code>javascript
co(function *(){
  var str = yield read('Readme.md')
  str = str.replace('Something', 'Else')
  yield write('Readme.md', str)
})
</code></p>

<p>就像下面这样，Co 这样的库会将异常”抛”回给他们原本的流程，这意味着你可以用 try/catch 来捕获异常，或者任其自流由最后 Co 的回调来处理这些错误。</p>

<p><code>javascript
co(function *(){
  try {
    var str = yield read('Readme.md')
  } catch (err) {
    // whatever
  }
  str = str.replace('Something', 'Else')
  yield write('Readme.md', str)
})
</code></p>

<p>在编写 Co 的时候貌似只有它实现了健壮的错误处理，但是假如你看一下 Co 的<a href="https://github.com/visionmedia/co/blob/master/index.js#L30">源代码</a>你会注意到所有的 try/catch 代码块。假如你用生成器你需要将 try/catch 添加到每个你用过的库中，来保证代码的健壮性。这就是为什么在今天看来，用 Nodejs 编写健壮性代码是一件不可能完成的任务。</p>

<h2 id="section-2">生成器对于协程</h2>

<p>生成器有时会被当成”半协程”，一个不完善，仅对调用方有效的协程。这让使用生成器比协程的目的更明确，好比 yield 能被当成”线程”。</p>

<p>协程要更加灵活一些，看起来就像是普通代码块，而不需要 yield：</p>

<p><code>javascript
var str = read('Readme.md')
str = str.replace('Something', 'Else')
write('Readme.md', str)
console.log('all done!')
</code></p>

<p>有些人认为完整的协程是”危险的”，因为它不清楚哪个方法有没有延迟执行线程。个人来说我认为这种争论很可笑，大部分延迟执行的方法都很明显，比方说从文件或套接字中读写，http 请求，睡眠等等延迟执行不会让任何人感到惊讶。</p>

<p>假如有些不友善的方法，那么你就 “fork” 它们来强迫这些任务变成异步的，就像你在 Go 中做的一样。</p>

<p>在我看来生成器可能比协程更危险（当然比回调好得多）—-仅仅是忘记一个 yield 表达式就可能让你费解或在它执行下面的代码时导致未知的行为结果。半协程和协程两者各自有优缺点，但是我很高兴现在至少已经有了其一。</p>

<p>让我们来看看你用生成器可以怎样实现新的构造方法。</p>

<h2 id="section-3">用协程实现简单的异步流程</h2>

<p>你已经看到一个简单读/写表达式看起来比回调更优雅，我们来看看更多的内容。</p>

<p>假设所有操作默认按顺序执行简化了模型，有些人声称生成器或协程使状态变得复杂化，这事不正确的。用回调处理状态也是一样的。全局变量依然是全局变量，局部变量依然是局部变量，而闭包依然是闭包。</p>

<p>我们用例子来说明这个流程，假设你需要请求一个 web 页面，解析其中的链接，然后同步请求所有的链接并输出他们的 Content-types。</p>

<p>这里是一个使用传统回调的例子，没有使用第三方流程控制库。</p>

<p>```javascript
function showTypes(fn) {
 get(‘http://cloudup.com’, function(err, res){
   if (err) return fn(err);
   var done;
   var urls = links(res.text);
   var pending = urls.length;
   var results = new Array(pending);
   urls.forEach(function(url, i){
     get(url, function(err, res){
       if (done) return;
       if (err) return done = true, fn(err);
       results[i] = res.header[‘content-type’];
       —pending || fn(null, results);
     });
   });
 });
}</p>

<p>showTypes(function(err, types){
  if (err) throw err;
  console.log(types);
});
```</p>

<p>这么简单的一个任务被回调搞得毫无可读性。再加上错误处理，重复回调的预防，存储结果和他们本身的一些回调，你会完全搞不懂这个方法是用来干嘛的。假如你需要使代码更健壮，还需要在最后的方法处加上 try/catch 代码块。</p>

<p>现在下面有一个由生成器实现的相同的 showTypes() 方法。你会看到结果和用回调实现的方法是一样的，在这里例子中 Co 处理了所有我们在上面需要手工处理的错误和结果集的组装。被 urls.maps(get) 方法 yield 的数组被平行执行，但是结果集然后是保持不变的顺序。</p>

<p><code>javascript
function header(field) {
  return function(res){
    return res.headers[field]
  }
}
function showTypes(fn) {
  co(function *(){
    var res = yield get('http://cloudup.com')
    var responses = yield links(res.text).map(get)
    return responses.map(header('content-type'))
  })(fn)
}
</code></p>

<p>我并不是建议所有的 Npm 模块使用生成器并且强制依赖 Co，我仍然建议使用相反的方法 —- 但是在应用层面我强烈推荐它。</p>

<p>我希望这能说明协程在编写无阻塞的程序时是一个强有力的工具。</p>
]]></content>
  </entry>
  
</feed>
