<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: database | CodeBean]]></title>
  <link href="http://jingxin.me/blog/blog/categories/database/atom.xml" rel="self"/>
  <link href="http://jingxin.me/blog/"/>
  <updated>2016-09-28T16:58:59+08:00</updated>
  <id>http://jingxin.me/blog/</id>
  <author>
    <name><![CDATA[Xu Jingxin]]></name>
    <email><![CDATA[sailxjx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[limbo: 简单访问远程数据库]]></title>
    <link href="http://jingxin.me/blog/blog/2014/08/28/limbo-jian-dan-fang-wen-yuan-cheng-shu-ju-ku/"/>
    <updated>2014-08-28T17:41:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2014/08/28/limbo-jian-dan-fang-wen-yuan-cheng-shu-ju-ku</id>
    <content type="html"><![CDATA[<p><img src="https://dn-talk.oss.aliyuncs.com/site/images/workspace-c16d9d49.jpg" alt="简聊一下 轻松协作" /></p>

<p>对于 nodejs 生态来说，使用 mongoose 作为 Model 模块是再好不过的一件事，其一大特点就是简洁优雅的 Schema 定义，提供了每个键值的类型验证，数据验证，索引声明，虚拟键，并自带实例化方法的扩展，大大节省了开发的成本。但是在考虑开放数据的时候，一切就显得不那么美好了。</p>

<p>在打造<a href="https://talk.ai/">简聊</a>这款应用的过程中，我们就实实在在的遇到了这样的问题。由于需要使用 <a href="https://www.teambition.com/">Teambition</a> 的用户和团队数据，并且当<a href="https://talk.ai/">简聊</a>更新了用户数据之后，在 <a href="https://www.teambition.com/">Teambition</a> 中能实时的将这些更新推送到用户那里。按照惯例，我们最初使用的是 restful 接口。</p>

<h2 id="restful-">第一阶段，使用 restful 接口</h2>

<p>restful 接口的应用面最广，但是仍然存在很多不足，比如接口在参数和结构上限制较多，在考虑修改接口 api 的时候，往往会顾虑客户端的兼容性，而一旦客户端程序有新的需求，则需等待接口的更新。另一个麻烦的地方是需要做签名校验，对于内部的应用来说，我们完全可以通过防火墙来控制特定 ip 对端口的访问，签名在此处就显得有点多余。</p>

<h2 id="schema">第二阶段，单独拆封 Schema</h2>

<p>然后我们想到了将 Schema 拆封成一个单独的仓库，nodejs 有良好的模块管理，在不同的应用中，我们只需要将这些模块引入进来，既做到同步更新，又做到 DRY。相对于 restful 接口的缺点就是，对于数据的调用入口过多，而且应用之间互相是不知情的。例如在<a href="https://talk.ai/">简聊</a>中有更新用户数据，在 <a href="https://www.teambition.com">Teambition</a> 中就无法得知，并推送给其他客户端。</p>

<h2 id="rpc">第三阶段，远程过程调用（rpc）</h2>

<p>这个阶段和 restful 接口其实类似，我们在 <a href="https://www.teambition.com">Teambition</a>  的后端进程中将一些接口方法暴露出来，这样我们的客户端程序就能通过简单的 rpc 方式调用这些接口。例如我们导出了 <code>user.update</code> 方法，在客户端代码中使用 <code>rpc.call('user.update', params, callback)</code> 即可调用相应的过程。这样的调用行为与使用本地代码无异，可能是目前能找到的最简单直接的方式了。</p>

<h2 id="rpc--mongoose-">第四阶段，rpc 与 mongoose 的结合</h2>

<p>事情可以变得更简单，由于目的主要是为了操作数据库，所以我们开发了一个模块 <a href="https://github.com/teambition/limbo">limbo</a>，将 mongoose model 中所有方法暴露出来，以命名空间来划分，实现了在客户端与服务端程序一致的使用体验。</p>

<p>例如我们在服务端程序中使用 limbo 连接 mongodb，只需要做如下声明：（以下的代码都以 coffeescript 作为示例）</p>

<p>```coffeescript
limbo = require ‘limbo’</p>

<h1 id="schema-1">定义 Schema</h1>
<p>UserSchame = (Schema) -&gt;
  # 这里的 Schema 即 mongoose.Schema
  new Schema
    name: String
    email: String</p>

<h1 id="use-">use 方法用作区分不同数据库连接的命名空间，一般参数选择数据库名就行</h1>
<p>db = limbo.use(‘test’).connect(‘mongodb://localhost:27017/test’).load ‘User’, UserSchema
```</p>

<p>使用方式就与 mongoose 一致了</p>

<p><code>coffeescript
user = db.user
# user 是一个 limbo 中用于封装 model 的一个对象，你可以直接使用 user.model 来直接调用 mongoose model
user.findOne _id: 'xxxx'
user.create name: 'xxx', email: 'yyy'
</code></p>

<p>下面是 limbo 中最激动人心的地方，你可以导出一个 collection 中的所有方法到 rpc server 中，只需要通过一个简单的声明</p>

<p><code>coffeescript
limbo.use('test').bind(7001).enableRpc()
</code></p>

<p>下面我们就要提到如何在客户端程序中调用这些方法</p>

<p>```coffeescript
# 在客户端也需要初始化一个 limbo 命名空间，需要与服务端一致，链接改为服务端的域名和端口号
db = limbo.use(‘test’).connect(‘tcp://localhost:7001’)</p>

<h1 id="rpc-1">下面有两种方式来使用 rpc</h1>
<p># 1. 使用 call 方法
db.call ‘user.findOne’, _id: ‘xxxx’, -&gt;
# 2. 使用方法链
db.user.findOne _id: ‘xxxx’, -&gt;
# 第二种方式存在一个延迟，必须要在 limbo 与服务端程序握手成功之后才可以使用，
# 否则会抛出一个对象不存在的异常，不过在一般的应用中，
# 初始化所需的时间都会长于这个链接所需时间，所以延迟可以忽略不计了
```</p>

<p>可以看出，上面的第二种方式与服务端在本地使用 mongoose 的方式一模一样，这种黑魔法式的调用方式应该是广大码农喜闻乐见的。</p>

<p>limbo 另一个值得称道的功能是可以在服务端程序监听这些远程调用的事件，这得益于 nodejs 的 event 对象，limbo 本身就继承于 EventEmitter 对象，所以我们在每次远程调用后会触发一个事件给服务端程序，而在服务端只需要简单的监听这个事件即可</p>

<p><code>coffeescript
limbo.on 'test.user.findOne', (user) -&gt; ...
</code></p>

<p>正是这种 rpc 加事件反馈的机制，让<a href="https://talk.ai/">简聊</a>和 <a href="https://www.teambition.com">Teambition</a> 可以实现简单实时的数据交换。我们将 <a href="https://github.com/teambition/limbo">limbo</a> 托管在 github 上开源，是深知它还存在很多可以改进的地方，所以不免庸俗的说一句，欢迎 issue 和 pr~</p>

<p>最后，欢迎访问我们的新产品<a href="https://talk.ai">简聊</a>，一款基于话题的轻量级协作应用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初试图形数据库 neo4j]]></title>
    <link href="http://jingxin.me/blog/blog/2013/01/23/chu-shi-tu-xing-shu-ju-ku-neo4j/"/>
    <updated>2013-01-23T11:25:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2013/01/23/chu-shi-tu-xing-shu-ju-ku-neo4j</id>
    <content type="html"><![CDATA[<h2 id="section">安装</h2>

<p>作为一个java软件，就得充分发挥它<code>Write Once, Run Anywhere</code>的精神。直接下载tarball，解压后运行即可。官方还很贴心的提供了一个init脚本(./bin/neo4j)，链接到init.d下就可以开搞啦。</p>

<p>默认的服务实例在localhost:7474，其余配置还是值得好好研究一番的。</p>

<h2 id="neo4j-shell">neo4j shell</h2>
<p>neo4j提供了一种叫做<code>Cypher Query Language</code>的查询方言，可以看做是图形数据库的sql，neo4j还提供了一个<code>neo4j-shell</code>用于做查询交互，在命令行下可以使用<code>./bin/neo4j-shell</code>来开启，web中也有一个tab叫做<code>power-tool console</code>可以使用neo4j-shell。</p>

<h3 id="section-1">增删改节点</h3>
<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 创建节点</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>CREATE <span class="nv">n</span> <span class="o">=</span> <span class="o">{</span> name : ‘Andres’, title : ‘Developer’ <span class="o">}</span> RETURN n;
</span><span class='line'>+——————————————-+
</span><span class='line'>| n                                         |
</span><span class='line'>+——————————————-+
</span><span class='line'>| Node<span class="o">[</span>37<span class="o">]{</span>name:”Andres”,title:”Developer”<span class="o">}</span> |
</span><span class='line'>+——————————————-+
</span><span class='line'>1 row
</span><span class='line'>Nodes created: 1
</span><span class='line'>Properties <span class="nb">set</span>: 2
</span><span class='line'>8 ms
</span><span class='line'><span class="c"># 修改节点</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>START <span class="nv">n</span> <span class="o">=</span> node<span class="o">(</span>37<span class="o">)</span> SET n.surname <span class="o">=</span> ‘Taylor’ RETURN n;
</span><span class='line'>+————————————————————+
</span><span class='line'>| n                                                          |
</span><span class='line'>+————————————————————+
</span><span class='line'>| Node<span class="o">[</span>37<span class="o">]{</span>name:”Andres”,title:”Developer”,surname:”Taylor”<span class="o">}</span> |
</span><span class='line'>+————————————————————+
</span><span class='line'>1 row
</span><span class='line'>Properties <span class="nb">set</span>: 1
</span><span class='line'>15 ms
</span><span class='line'><span class="c"># 删除节点</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>START <span class="nv">n</span> <span class="o">=</span> node<span class="o">(</span>37<span class="o">)</span> DELETE n;
</span><span class='line'>+——————-+
</span><span class='line'>| No data returned. |
</span><span class='line'>+——————-+
</span><span class='line'>Nodes deleted: 1
</span><span class='line'>4 ms
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3 id="section-2">创建关系</h3>
<p>图形数据库最重要的一个概念就是关系(relationship)，各个节点直接通过双向或单向的关系连接在一起，这样才能从一个节点查找到其他的节点，这种设计在某些场景下会让查询变得更加高效而灵活，例如社交网络中的好友关系，人立方中查找任意两人之间的亲友，假如使用传统的关系数据库，查找朋友的朋友就会变得非常的困难，其耗时也是指数型的增长，而使用图形数据库，则可以保持线性的效率。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 创建两个节点的关系</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>START <span class="nv">a</span> <span class="o">=</span> node<span class="o">(</span>34<span class="o">)</span>, <span class="nv">b</span> <span class="o">=</span> node<span class="o">(</span>36<span class="o">)</span> CREATE a-<span class="o">[</span>r:knowns<span class="o">]</span>-&amp;gt;b RETURN r;
</span><span class='line'>+—————+
</span><span class='line'>| r             |
</span><span class='line'>+—————+
</span><span class='line'>| :knowns<span class="o">[</span>0<span class="o">]</span> <span class="o">{}</span> |
</span><span class='line'>+—————+
</span><span class='line'>1 row
</span><span class='line'>Relationships created: 1
</span><span class='line'>20 ms
</span><span class='line'><span class="c"># 查找关系</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">r</span> <span class="o">=</span> rel<span class="o">(</span>0<span class="o">)</span> <span class="k">return </span>r;  &lt;br /&gt;
</span><span class='line'>+———————————–+
</span><span class='line'>| r                                 |
</span><span class='line'>+———————————–+
</span><span class='line'>| :isdogof<span class="o">[</span>0<span class="o">]</span> <span class="o">{</span>ctime:1359365331933<span class="o">}</span> |
</span><span class='line'>+———————————–+
</span><span class='line'>1 row
</span><span class='line'>1 ms
</span><span class='line'><span class="c"># 删除某节点和它的所有关系</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>START <span class="nv">n</span> <span class="o">=</span> node<span class="o">(</span>34<span class="o">)</span> MATCH n-<span class="o">[</span>r<span class="o">]</span>-<span class="o">()</span> DELETE n, r;
</span><span class='line'>+——————-+
</span><span class='line'>| No data returned. |
</span><span class='line'>+——————-+
</span><span class='line'>Nodes deleted: 1
</span><span class='line'>Relationships deleted: 3
</span><span class='line'>3 ms
</span><span class='line'><span class="c"># 查找节点的关系</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">a</span> <span class="o">=</span> node<span class="o">(</span>2<span class="o">)</span> match a&amp;lt;-<span class="o">[</span>r:isfamilyof<span class="o">]</span>-&amp;gt;b RETURN a,r,b;
</span><span class='line'>+—————————————————————————————-+
</span><span class='line'>| a                           | r                          | b                           |
</span><span class='line'>+—————————————————————————————-+
</span><span class='line'>| Node<span class="o">[</span>2<span class="o">]{</span>name:”bran”,age:10<span class="o">}</span> | :isfamilyof<span class="o">[</span>2<span class="o">]</span> <span class="o">{</span>ctime:200<span class="o">}</span> | Node<span class="o">[</span>1<span class="o">]{</span>name:”snow”,age:17<span class="o">}</span> |
</span><span class='line'>+—————————————————————————————-+
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>有意思的是注意其中<code>CREATE a-[r:knowns]-&gt;b</code>中的箭头走向表示这种关系的指向，我们可以通过<code>CREATE a&lt;-[r:knowns]-b</code>来创建一个b到a的关系，但是当我想用<code>CREATE a&lt;-[r:knowns]-&gt;b</code>来创建一个双向关系时却没有成功，仍然只创建了从a到b的关系。而在查找某个节点的关系时，双向箭头确是起作用的，应该算做一个bug。</p>

<h3 id="section-3">删除所有节点和关系</h3>
<p><code>Cypher</code>中可以使用通配符<code>*</code>来找出所有的节点或者关系，那么假如我们需要删除所有节点，语句如下
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 如果节点上还有对应的关系，该节点是无法删除的，所以需要先删除所有关系</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">r</span> <span class="o">=</span> rel<span class="o">(</span>&lt;em&gt;<span class="o">)</span> delete r;
</span><span class='line'>+——————————————–+
</span><span class='line'>| No data returned, and nothing was changed. |
</span><span class='line'>+——————————————–+
</span><span class='line'>0 ms
</span><span class='line'><span class="c"># 删除节点</span>
</span><span class='line'>neo4j-sh <span class="o">(</span>?<span class="o">)</span><span class="nv">$ </span>start <span class="nv">n</span> <span class="o">=</span> node<span class="o">(</span>&lt;/em&gt;<span class="o">)</span> delete n;
</span><span class='line'>+——————-+
</span><span class='line'>| No data returned. |
</span><span class='line'>+——————-+
</span><span class='line'>Nodes deleted: 2
</span><span class='line'>4 ms
</span></code></pre></td></tr></table></div></figure></notextile></div>
删除所有节点后，在web端显示的节点数和关系数可能会对不上真实的数据，这些数量官方叫做”Primitive count”，其实在<code>neo4j-shell</code>下可以用下面的命令得到，按字面意思应该表示一个估算值，并不准确。
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>neo4j-sh <span class="o">(</span>0<span class="o">)</span><span class="nv">$ </span>dbinfo -g “Primitive count”
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  “NumberOfNodeIdsInUse”: 1,
</span><span class='line'>  “NumberOfPropertyIdsInUse”: 0,
</span><span class='line'>  “NumberOfRelationshipIdsInUse”: 0,
</span><span class='line'>  “NumberOfRelationshipTypeIdsInUse”: 0
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在自己看来，<code>Cypher Query Language</code>的增删改语句还是比较直观的，但是一旦牵涉到关系就有点没节操了，一句查询中一半的操作符，真是让人看花眼，相较之下还是sql发展的比较成熟，也更易为人所接受了。<a href="http://docs.neo4j.org/chunked/milestone/cypher-query-lang.html">更多的操作符和更多的语法</a></p>

<p>不过，各种neo4j的客户端都将晦涩的<code>Cypher</code>语言封装起来，提供了可读性更高的接口方法，下面就找个客户端来试用一下。</p>

<h2 id="nodejs-bundle">nodejs bundle</h2>
<p>官网上给出了java和python版本的实例，我等屌丝玩点轻量级的，这里找了一个<a href="https://github.com/thingdom/node-neo4j">nodejs的客户端</a>，初窥图形数据库的魅力。</p>

<h3 id="section-4">创建及修改节点</h3>
<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">neo4j = </span><span class="nx">require</span> <span class="err">‘</span><span class="nx">neo4j</span><span class="err">’</span>     <span class="c1">#使用coffee-script，那就尽量写的更coffee一点儿吧</span>
</span><span class='line'><span class="nv">db = </span><span class="k">new</span> <span class="nx">neo4j</span><span class="p">.</span><span class="nx">GraphDatabase</span><span class="p">(</span><span class="err">‘</span><span class="nx">http</span><span class="o">://</span><span class="nx">localhost</span><span class="o">:</span><span class="mi">7474</span><span class="err">’</span><span class="p">)</span> <span class="c1">#连接默认的REST端口</span>
</span><span class='line'><span class="nx">node</span><span class="p">.</span><span class="nx">createNode</span> <span class="p">{</span>             <span class="c1">#初始化一个节点</span>
</span><span class='line'>    <span class="nv">username: </span><span class="err">‘</span><span class="nx">bran</span><span class="err">’</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">node</span><span class="p">.</span><span class="nx">save</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span><span class="o">-&amp;</span><span class="nx">gt</span><span class="p">;</span>       <span class="c1">#需要save才能真正的保存这个节点到数据库</span>
</span><span class='line'>    <span class="nv">node.data = </span><span class="p">{</span>           <span class="c1">#可以通过直接修改node的data属性来修改node值</span>
</span><span class='line'>        <span class="nv">username: </span><span class="err">‘</span><span class="nx">bran</span><span class="err">’</span>
</span><span class='line'>        <span class="nv">nickname: </span><span class="err">‘</span><span class="nx">bird</span> <span class="nx">man</span><span class="err">’</span>
</span><span class='line'>        <span class="nv">email: </span><span class="err">‘</span><span class="nx">bran@gmail</span><span class="p">.</span><span class="nx">com</span><span class="err">’</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">node</span><span class="p">.</span><span class="nx">save</span><span class="p">()</span>             <span class="c1">#不要忘了再次保存</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2 id="section-5">备份数据库</h2>
<p>之前造出了那么多的脏数据，有点洁癖的人都想要把数据清理一下吧。网上找了找，发现只有’enterprise’版才有export的功能，这不是明摆着鄙视我等屌丝么。在<a href="http://www.mail-archive.com/user@lists.neo4j.org/msg08932.html">这里</a>(翻墙可入)有兄台说了一个很暴力的办法，直接删除<code>data/graph.db</code>文件夹，我试了一下，确实可行，重启后世界干干净净，只剩下了0号node，果断再用<code>start n = node(0) delete n;</code>删除之。这大概也是nosql的好处，数据就是文件，取消了维护索引，关系等等的麻烦，随去随用，冷备份和迁移的时候也简单，直接copy文件夹即可。</p>

<h2 id="section-6">参考文档</h2>
<ul>
  <li><a href="http://docs.neo4j.org/chunked/milestone/">v1.9手册</a></li>
  <li><a href="http://docs.neo4j.org.cn/">v1.8中文开发文档</a></li>
  <li><a href="http://coffeedoc.info/github/thingdom/node-neo4j/master/">node-neo4j文档</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
