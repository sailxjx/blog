<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mysql | CodeBean]]></title>
  <link href="http://jingxin.me/blog/blog/categories/mysql/atom.xml" rel="self"/>
  <link href="http://jingxin.me/blog/"/>
  <updated>2014-11-23T13:08:36+08:00</updated>
  <id>http://jingxin.me/blog/</id>
  <author>
    <name><![CDATA[Xu Jingxin]]></name>
    <email><![CDATA[sailxjx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[mysql 中的 date datetime 和 timestamp]]></title>
    <link href="http://jingxin.me/blog/blog/2013/06/05/mysql-zhong-de-date-datetime-he-timestamp/"/>
    <updated>2013-06-05T11:02:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2013/06/05/mysql-zhong-de-date-datetime-he-timestamp</id>
    <content type="html"><![CDATA[<p>mysql中用于表示时间的三种类型date, datetime, timestamp (如果算上int的话，四种) 比较容易混淆，下面就比较一下这三种类型的异同</p>

<h1 id="section">相同点</h1>

<ul>
  <li>都可以用于表示时间</li>
  <li>都呈字符串显示</li>
</ul>

<h1 id="section-1">不同点</h1>

<ul>
  <li>顾名思义，date只表示’YYYY-MM-DD’形式的日期，datetime表示’YYYY-MM-DD HH:mm:ss’形式的日期加时间，timestamp与datetime显示形式一样。</li>
  <li>date和datetime可表示的时间范围为’1000-01-01’到’9999-12-31’，timestamp由于受32位int型的限制，能表示’1970-01-01 00:00:01’到’2038-01-19 03:14:07’的UTC时间。</li>
  <li>mysql在存储timestamp类型时会将时间转为UTC时间，然后读取的时候再恢复成当前时区。
假如你存储了一个timestamp类型的值之后，修改了mysql的时区，当你再读取这个值时就会得到一个错误的时间。而这种情况在date和datetime中不会发生。</li>
  <li>timestamp类型提供了自动更新的功能，你只需要将它的默认值设置为CURRENT_TIMESTAMP。</li>
  <li>除了date是保留到天，datetime和timestamp都保留到秒，而忽略毫秒。</li>
</ul>

<h1 id="section-2">时间格式</h1>

<p>mysql提供了一种比较宽松的时间字符串格式用于增删改查。参考<a href="http://wwp.greenwichmeantime.com/info/iso.htm">iso时间格式</a>，一般习惯于写成’2013-06-05 16:34:18’。但是你也可以简写成’13-6-5’，但是这样容易造成混淆，比如mysql也会把’13:6:5’也当做年月日处理，而当’13:16:5’这种形式，则被mysql认为是不正确的格式，会给出一个警告，然后存入数据库的值是’0000-00-00 00:00:00’。</p>

<p>手册中还特意提到了一种情况，就是当年的值是0~69时，mysql认为是2000~2069，而70~99时则认为是1970~1999。我感觉是一种画蛇添足了。</p>

<p>总之，以不变应万变，使用’YYYY-MM-DD HH:mm:ss’格式总是不会错的。</p>

<p>原文链接：<a href="http://dev.mysql.com/doc/refman/5.1/en/datetime.html">datetime</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql btree 与 hash 索引比较]]></title>
    <link href="http://jingxin.me/blog/blog/2013/05/07/mysql-btree-yu-hash-suo-yin-bi-jiao/"/>
    <updated>2013-05-07T11:45:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2013/05/07/mysql-btree-yu-hash-suo-yin-bi-jiao</id>
    <content type="html"><![CDATA[<p>mysql最常用的索引结构是btree(<code>O(log(n))</code>)，但是总有一些情况下我们为了更好的性能希望能使用别的类型的索引。hash就是其中一种选择，例如我们在通过用户名检索用户id的时候，他们总是一对一的关系，用到的操作符只是<code>=</code>而已，假如使用hash作为索引数据结构的话，时间复杂度可以降到<code>O(1)</code>。不幸的是，目前的mysql版本(5.6)中，hash只支持MEMORY和NDB两种引擎，而我们最常用的INNODB和MYISAM都不支持hash类型的索引。</p>

<p>不管怎样，还是要了解一下这两种索引的区别，下面翻译自<a href="http://dev.mysql.com/doc/refman/5.6/en/index-btree-hash.html">mysql官网文档</a>中对这两者的解释。</p>

<h2 id="b-tree-">B-Tree 索引特征</h2>
<p>B-Tree索引可以被用在像<code>=</code>,<code>&gt;</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&lt;=</code>和<code>BETWEEN</code>这些比较操作符上。而且还可以用于<code>LIKE</code>操作符，只要它的查询条件是一个不以通配符开头的常量。像下面的语句就可以使用索引：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tbl_name</span> <span class="k">WHERE</span> <span class="n">key_col</span> <span class="k">LIKE</span> <span class="err">‘</span><span class="n">Patrick</span><span class="o">%</span><span class="err">’</span><span class="p">;</span>
</span><span class='line'><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tbl_name</span> <span class="k">WHERE</span> <span class="n">key_col</span> <span class="k">LIKE</span> <span class="err">‘</span><span class="n">Pat</span><span class="o">%</span><span class="n">_ck</span><span class="o">%</span><span class="err">’</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>下面这两种情况不会使用索引：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tbl_name</span> <span class="k">WHERE</span> <span class="n">key_col</span> <span class="k">LIKE</span> <span class="err">‘</span><span class="o">%</span><span class="n">Patrick</span><span class="o">%</span><span class="err">’</span><span class="p">;</span>
</span><span class='line'><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tbl_name</span> <span class="k">WHERE</span> <span class="n">key_col</span> <span class="k">LIKE</span> <span class="n">other_col</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>第一条是因为它以通配符开头，第二条是因为没有使用常量。</p>

<p>假如你使用<code>... LIKE '%string%'</code>而且<code>string</code>超过三个字符，MYSQL使用<code>Turbo Boyer-Moore algorithm</code>算法来初始化查询表达式，然后用这个表达式来让查询更迅速。</p>

<p>一个这样的查询<code>col_name IS NULL</code>是可以使用<code>col_name</code>的索引的。</p>

<p>任何一个没有覆盖所有<code>WHERE</code>中<code>AND</code>级别条件的索引是不会被使用的。也就是说，要使用一个索引，这个索引中的第一列需要在每个<code>AND</code>组中出现。</p>

<p>下面的<code>WHERE</code>条件会使用索引：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="err">…</span> <span class="k">WHERE</span> <span class="n">index_part1</span><span class="o">=</span><span class="mi">1</span> <span class="k">AND</span> <span class="n">index_part2</span><span class="o">=</span><span class="mi">2</span> <span class="k">AND</span> <span class="n">other_column</span><span class="o">=</span><span class="mi">3</span>
</span><span class='line'>    <span class="cm">/* index = 1 OR index = 2 &lt;em&gt;/</span>
</span><span class='line'><span class="cm">… WHERE index=1 OR A=10 AND index=2</span>
</span><span class='line'><span class="cm">    /&lt;/em&gt; 优化成 “index_part1=’hello’” &lt;em&gt;/</span>
</span><span class='line'><span class="cm">… WHERE index_part1=’hello’ AND index_part3=5</span>
</span><span class='line'><span class="cm">    /&lt;/em&gt; 可以使用 index1 的索引但是不会使用 index2 和 index3 */</span>
</span><span class='line'><span class="err">…</span> <span class="k">WHERE</span> <span class="n">index1</span><span class="o">=</span><span class="mi">1</span> <span class="k">AND</span> <span class="n">index2</span><span class="o">=</span><span class="mi">2</span> <span class="k">OR</span> <span class="n">index1</span><span class="o">=</span><span class="mi">3</span> <span class="k">AND</span> <span class="n">index3</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>下面的<code>WHERE</code>条件不会使用索引：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'>    <span class="cm">/* index_part1 没有被使用到 */</span>
</span><span class='line'><span class="err">…</span> <span class="k">WHERE</span> <span class="n">index_part2</span><span class="o">=</span><span class="mi">1</span> <span class="k">AND</span> <span class="n">index_part3</span><span class="o">=</span><span class="mi">2</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="cm">/* 索引 index 没有出现在每个 where 子句中 */</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">index</span><span class="o">=</span><span class="mi">1</span> <span class="k">OR</span> <span class="n">A</span><span class="o">=</span><span class="mi">10</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* 没有索引覆盖所有列 */</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">index_part1</span><span class="o">=</span><span class="mi">1</span> <span class="k">OR</span> <span class="n">index_part2</span><span class="o">=</span><span class="mi">10</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
</code></pre>

<p>有时候mysql不会使用索引，即使这个在可用的情况下。例如当mysql预估使用索引会读取大部分的行数据时。（在这种情况下，一次全表扫描可能比使用索引更快，因为它需要更少的检索）。然而，假如语句中使用<code>LIMIT</code>来限定返回的行数，mysql则会使用索引。因为当结果行数较少的情况下使用索引的效率会更高。</p>

<h2 id="hash-">Hash 索引特征</h2>

<p>Hash类型的索引有一些区别于以上所述的特征：</p>

<ul>
  <li>
    <p>它们只能用于对等比较，例如<code>=</code>和<code>&lt;=&gt;</code>操作符（但是快很多）。它们不能被用于像<code>&lt;</code>这样的范围查询条件。假如系统只需要使用像“键值对”的这样的存储结构，尽量使用hash类型索引。</p>
  </li>
  <li>
    <p>优化器不能用hash索引来为<code>ORDER BY</code>操作符加速。（这类索引不能被用于搜索下一个次序的值）</p>
  </li>
  <li>
    <p>mysql不能判断出两个值之间有多少条数据（这需要使用范围查询操作符来决定使用哪个索引）。假如你将一个<code>MyISAM</code>表转为一个依靠hash索引的<code>MEMORY</code>表，可能会影响一些语句（的性能）。</p>
  </li>
  <li>
    <p>只有完整的键才能被用于搜索一行数据。（假如用B-tree索引，任何一个键的片段都可以用于查找。我觉得可能意味着带通配符<code>LIKE</code>操作符会不起作用）。</p>
  </li>
</ul>

<h1 id="section">后记</h1>

<p>顺便记录一下在使用mysql过程中碰到的一些问题：</p>

<ul>
  <li>有时候使用脚本迁移数据时会碰到乱码的问题，即使将表字符集设置成<code>utf8</code>也无济于事，这个时候在执行sql之前加一句<code>set names utf8</code>即可。</li>
</ul>

<h1 id="section-1">参考文档</h1>

<ul>
  <li><a href="http://dev.mysql.com/doc/refman/5.6/en/index-btree-hash.html">index-btree-hash</a></li>
  <li><a href="http://dba.stackexchange.com/questions/2817/why-does-mysql-not-have-hash-indices-on-myisam-or-innodb">why-does-mysql-not-have-hash-indices-on-myisam-or-innodb</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql 多实例启动]]></title>
    <link href="http://jingxin.me/blog/blog/2012/08/13/mysql-duo-shi-li-qi-dong/"/>
    <updated>2012-08-13T17:03:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2012/08/13/mysql-duo-shi-li-qi-dong</id>
    <content type="html"><![CDATA[<p>当开发与生产环境在同一台机器上，或需要在一台机器上部署多套测试环境时，往往需要同时起多个mysqld进程，最近帮测试搭环境的时候就碰到了这样的问题。</p>

<p>还是从安装mysql开始，下载tarball安装，</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>安装mysql  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>groupadd mysql
</span><span class='line'>useradd -g mysql mysql
</span><span class='line'>cmake . -DCMAKE_INSTALL_PREFIX<span class="o">=</span>/usr/local/mysql5.5.27/  -DMYSQL_DATADIR<span class="o">=</span>/data/mysql  -DWITH_INNOBASE_STORAGE_ENGINE<span class="o">=</span>1  -DMYSQL_TCP_PORT<span class="o">=</span>3306  -DMYSQL_UNIX_ADDR<span class="o">=</span>/var/run/mysql/mysql.sock -DWITH_DEBUG<span class="o">=</span>0
</span><span class='line'>make &amp;amp;&amp;amp; make install
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>然后配置my.cnf，从support-files里面拷贝一个my-medium.cnf到/etc/my.cnf，里面mysqld配置段的内容基本是这个样子</p>

<p>Liquid error: ClassNotFound: no lexer for alias 'cnf' found</p>

<p>默认mysqld只启动一个实例，既然我们的目的是启动多个mysqld实例，需要使用mysqld_multi。它是一个perl脚本，在使用之前，需要给my.cnf加一些料。</p>

<p>Liquid error: ClassNotFound: no lexer for alias 'cnf' found</p>

<p>然后依配置创建mysql运行时文件夹并用mysql_install_db脚本初始化系统库
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>mkdir -p /data/mysql1 /data/mysql2 /var/log/mysql /var/run/mysql
</span><span class='line'>chgrp mysql /data/mysql* /var/log/mysql /var/run/mysql
</span><span class='line'>chown mysql /data/mysql* /var/log/mysql /var/run/mysql
</span><span class='line'>mysql_install_db –datadir<span class="o">=</span>/data/mysql1 –user<span class="o">=</span>mysql
</span><span class='line'>mysql_install_db –datadir<span class="o">=</span>/data/mysql2 –user<span class="o">=</span>mysql
</span><span class='line'>mysqld_multi start 1-2
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>最后一条命令其实已经将我们配置好的mysqld1和mysqld2启动了，这时候在进程表中应该能看到两个mysqld进程，试着用-P参数指定端口能分别访问在/data/mysql1和/data/mysql2下面的两个库，两者互不影响，正好能满足测试的要求。当然需要配置更多的实例也是可以的。</p>

<h2 id="mysql_extra">额外收获</h2>

<p>这次配置过程中还遇到一些额外的问题，记下来备忘。</p>

<ul>
  <li>假如使用的是ubuntu(我目前的版本还是11.10)，默认会安装apparmor，这个软件是一个诡异的存在，它就像一个暗恋者，一直默默限制软件的访问权限，然后又不被系统待见，以至于我根本不知道它的存在。其实它是一个白名单，在/etc/apparmor.d/中指定了/usr/sbin/mysqld对各文件的访问权限，当我想将mysql的数据文件夹迁移到别的位置时，一直报这个错误</li>
</ul>

<p><code>Can't create test file /data/mysql1/littleboy.lower-test</code></p>

<p>而令人费解的就是mysql对这些文件夹是有读写权限的，其实只需要编辑/etc/apparmor.d/usr.sbin.mysqld文件，依样画葫芦地为文件夹加上rw权限就可以了</p>

<ul>
  <li>给mysql设置远程访问权限，只需要下面这条sql</li>
</ul>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">INSERT</span> <span class="n">mysql</span><span class="p">.</span><span class="k">user</span> <span class="p">(</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">Host</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">User</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Password</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span> <span class="err">‘</span><span class="o">%</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">root</span><span class="err">’</span><span class="p">,</span> <span class="n">PASSWORD</span><span class="p">(</span><span class="err">‘</span><span class="mi">123456</span><span class="err">’</span><span class="p">)</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其中最关键的就是那个’%’，表示通过任意host均可以访问到本机的mysql</p>

<ul>
  <li>给mysql设置密码。</li>
</ul>

<p><code>mysqladmin -u root -h 127.0.0.1 password 123456</code></p>

<p>上面那种是在不登录mysql的情况下修改密码，还有两种可以通过改表的方式。见<a href="#mysql_refer">MySQL设置密码的三种方法</a></p>

<p>修改过密码以后，mysqld_multi可能就不能通过默认配置来结束mysqld进程了，这时候需要在配置里加上用户名和密码</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[mysqld_multi]
</span><span class='line'>mysqld = /usr/local/mysql/bin/mysqld
</span><span class='line'>mysqladmin = /usr/local/mysql/bin/mysqladmin
</span><span class='line'>user = root
</span><span class='line'>password = 123456</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>当然这样可能会有一些安全隐患，因为my.cnf是可见的。假如是多人使用，可以将password这行去掉，每次操作mysqld_multi的时候，在后面加上<code>--password=123456</code>参数就行了</p>

<h2 id="mysql_refer">参考资料</h2>
<ul>
  <li><a href="http://www.neocanable.com/error-for-mysql-multi-and-mysql-install-db/">解决apparmor引起的报错1</a></li>
  <li><a href="http://ubuntuforums.org/showthread.php?t=1861136">解决apparmor引起的报错2</a></li>
  <li><a href="http://blog.csdn.net/magicbreaker/article/details/2392764">MySQL设置密码的三种方法</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
