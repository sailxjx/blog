<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: software | CodeBean]]></title>
  <link href="http://jingxin.me/blog/blog/categories/software/atom.xml" rel="self"/>
  <link href="http://jingxin.me/blog/"/>
  <updated>2016-08-08T18:27:51+08:00</updated>
  <id>http://jingxin.me/blog/</id>
  <author>
    <name><![CDATA[Xu Jingxin]]></name>
    <email><![CDATA[sailxjx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[工具软件的未来]]></title>
    <link href="http://jingxin.me/blog/blog/2016/08/08/gong-ju-ruan-jian-de-wei-lai/"/>
    <updated>2016-08-08T16:25:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2016/08/08/gong-ju-ruan-jian-de-wei-lai</id>
    <content type="html"><![CDATA[<p>上一篇<a href="/blog/2016/08/08/gong-ju-ruan-jian-de-kun-jing/" title="工具软件的困境">工具软件的困境</a>分析了我对工具软件现状的看法，归纳一下就是两个问题：1. 使用体验难创新。2. 用户需求难覆盖。下面说一下我的解法。</p>

<h1 id="section">新的平台</h1>

<p>颠覆性的创新更容易出现在新的平台上，移动设备的普及让人们习惯了手势操作。但在今天，移动设备上做交互创新已然不是一个明智的选择，而新的平台其实就在我们身边。</p>

<p>一个叫 Pokemon GO 的游戏火遍了全世界，其最大的特点就是利用了增强现实技术，让人们在现实世界中寻找游戏的乐趣。</p>

<p>增强现实和虚拟现实之所以有吸引力，是因为他能给人带来新奇的同时又不感到陌生，天然的容易上手。工具软件在这个领域大有作为，例如，如今许多人喜欢用电子名片，或者把自己的信息发布在互联网上，如果软件能通过摄像头识别出对方并且显示信息的话，对于我这种永远记不住陌生人名字的人来说，实在算是一种福音。同样适用这种技术还有地图，视频，社交，以及很多意想不到的地方，充斥着生活的方方面面。</p>

<p>如果觉得新的平台实验性太强，那么在旧的平台上，也可以用新的方式来创新。在我看来，语音在移动平台上还没有完全发挥出应有的作用，目前的技术对于语音识别的准确率已经完全没有问题，难点在于对语义的分析和揣测用户的目的。Siri 大家都觉得好玩，但是不好用，问题就在于人们不知道能用它干什么，Siri 也「听」不懂你想干什么。而这在目标比较单一的工具软件中就能得到很好的应用。如果有一款应用是用来推荐餐馆的，那么我更乐于通过自然语言的方式让他为我推荐附近好吃的餐馆，而不是每次想好了关键词再写在输入框里。</p>

<h1 id="section-1">海纳百川</h1>

<p>工具软件需要应对用户提出的各种需求，这些需求零散，独立，无法整合在一个应用中，然而对于留住用户又必不可少。传统软件的做法是自己开发，然后发行一款配置无限繁琐的软件，或者针对大客户做定制化开发。这种做法在工具匮乏的时代可以在市场中站稳脚跟，如今成本这么高的做法是走不通了。</p>

<p>于是就出现了开放 API，各个软件将自己的 API 开放出来，供其他软件接入。这在工具类软件中尤其鲜明。一款好用的软件，只需要做好自己的核心功能，并接入其他优秀软件。</p>

<p>仔细想一想，这其实就是各种软件在做的「应用平台」。但是我不愿意将它称作「平台」，而更乐意称作「协议」。「平台」意味着大家只能加入到我的软件生态中来，「协议」则表明了一种开放的态度，大家可以自由的选择与我的协议对接，或选择其他应用的协议，甚至利用我的协议，和其他第三方应用对接。</p>

<h1 id="section-2">服务至上</h1>

<p>软件作为一种看不见摸不着的产品，天然的隔绝了用户和开发者，用户看不到开发软件背后的付出，于是很容易低估软件的成本。现实的软件发行方式也增强了用户的这种观念，大部分软件都以免费的方式发行，软件变得和说明书一样，成为了「载体」的附庸。</p>

<p>而在其他领域，用户的付费意愿则比软件高得多，用户拿到一台相机，很容易通过做工和质感估算出这台相机的成本，而其附带的软件则看起来一文不值。甚至改变了世界的 iPhone，大部分用户还是直接将它和手里的手机划上等号，而很少有人去了解 iOS 的成本。</p>

<p>这种观念根深蒂固，那么工具软件该从另一个角度出发，找到自己的「载体」。如果工具软件没有对应的硬件，可以将与软件配套的服务作为「载体」来出售。例如给用户的咨询，培训，发展线下的社区，一方面可以给开发者带来直接的收益，同时也大大提高了用户粘性。一款软件能否和竞争者拉开差距，更多的是看与软件配套的服务，我想这也是「软件即服务」的定义。</p>

<h1 id="section-3">写在最后</h1>

<p>在软件这个行业，每天都能看到很多很棒的点子，希望这些点子能尽早变成现实，而不是像我这样的拖延症患者，挖了<a href="https://github.com/sailxjx/Cycle" title="Cycle">一堆</a>的<a href="https://github.com/sailxjx/storyship" title="Storyship">坑</a>，离完成却遥遥无期。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工具软件的困境]]></title>
    <link href="http://jingxin.me/blog/blog/2016/08/08/gong-ju-ruan-jian-de-kun-jing/"/>
    <updated>2016-08-08T14:07:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2016/08/08/gong-ju-ruan-jian-de-kun-jing</id>
    <content type="html"><![CDATA[<p>这个话题改成「软件的困境」，我觉得也没什么不妥，但是船小好调头，从一个领域说起，总能更有说服力。平时写的最多，用的最多的就是工具软件，现在来分析一下工具软件的困境。</p>

<p>工欲善其事，必先利其器。随着互联网的普及，软件从一个专业领域的工具，飞入寻常百姓家，成为了人们生活的一部分。软件界的摩尔定律依然有效，曾经动辄上百万的解决方案，如今也能找到免费的替代品。而这些成熟的软件背后，是几百人在键盘面前的敲敲打打，软件的人力成本节节攀升，盈利就成了一个很大的问题。</p>

<h1 id="section">匮乏的盈利模式</h1>

<p>软件的收费模式基本可分两类，一类贩售软件本身的价值，给软件一个定价，由人去下载，例如 App store 上的一票收费软件。另一类是贩售软件附带的服务，例如依靠购买会员，道具等虚拟物品盈利的网站。</p>

<p>上面这两类盈利方式都有局限性，第一类本身造就了一个很高的门槛，大部分人不肯为素未谋面的软件买单，而且这类软件如果能在自己的行业内做到占有量第一，也就意味着触到了天花板，难以发展新用户，老用户也不再买单，这时的出路就只有推出新产品或进行大版本升级，接下来造就的产品，要么华而不实，要么臃肿不堪。</p>

<p>第二类收费模式通常会带一个免费版，满足 80% 用户的需求，然后让另外 20% 用户为软件买单，养活所有的用户和开发者自己。这就很容易造成需求的失衡，为了追求「转化率」，开发者肯定优先考虑付费端的需求，对于大部分用户需要的功能则被「列入计划」迟迟得不到开发。开发者大部分时间在做的都是给需求排优先级，而忘了考虑软件本身的定位。这也是为什么很多软件刚面世时非常惊艳，迭代了几个版本之后却变得平庸。</p>

<h1 id="section-1">固化的使用体验</h1>

<p>工具软件如何从一并同僚中脱颖而出，使用体验起到了相当重要的作用。软件的发展过程就是一个去繁化简的过程，早期糟糕的软件培养了糟糕的用户习惯，例如常见的顶部菜单就是一个错误的存在，懒惰的开发者将所有的功能藏在菜单里面，让用户通过反复点击去寻找。如果当初的工具设计者能够合理的布置空间，用户使用软件的效率必能得到一个极大的提升。因为用户已经习惯了这种操作，往后的所有桌面端软件都沿袭了顶部菜单的模式，因为改变习惯需要冒较大的风险，体验好坏很难说的清楚，于是用户继续忍耐着打开一个文件需要点击 4 次的操作。</p>

<p>好在如今的移动端应用已经很少用到菜单模式，工具软件很容易在一个新的平台上面找到创新点，例如 Clear 就靠着方便的手势操作获得了大批拥趸。而到了今天，经过了大量 App 的锻炼之后，用户在移动端的使用习惯也已经固化，新的软件将很难再依赖使用体验来吸引用户。</p>

<h1 id="section-2">难以满足的需求</h1>

<p>关于工具软件应该是大而全还是专注于一个功能，一直难下定论。有意思的是，这个问题在国内外呈现出完全不同的两派做法，在国外我们发现了很多小而美的工具软件，例如前面提到的 Clear, sunrise, paper 等，在国内知名的软件都是功能完备的，例如做支付的微信和做社交的支付宝，似乎每家都觉得能把自家的软件做成操作系统。</p>

<p>一个软件获得了一批种子用户，证明了这个软件的价值，也带来了各种稀奇古怪的需求。工具应用本身的目标是提高用户效率，而如果每个软件只能满足一个需求，用户就不得不在一大堆的软件中频繁切换来满足日常所需，这本身就非常低效。所以我认为工具软件迭代了几个周期之后，免不了加入很多不曾计划的功能，以至于同质化越来越重，竞争对手越来越多，想要脱颖而出，光靠软件自身的素质是非常难的了。</p>

<h1 id="section-3">写在最后</h1>

<p>如今想要盈利，开发工具软件实在不能算是一门好生意。固化的使用习惯，难以满足的个性化需求，都会让开发者入不敷出。然而市场依然在，需求依然强烈，仔细思考一下<a href="/blog/2016/08/08/gong-ju-ruan-jian-de-wei-lai/" title="工具软件的未来">工具软件的未来</a>，成为这个领域的黑马也未可知。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件与配置]]></title>
    <link href="http://jingxin.me/blog/blog/2014/02/28/ruan-jian-yu-pei-zhi/"/>
    <updated>2014-02-28T13:07:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2014/02/28/ruan-jian-yu-pei-zhi</id>
    <content type="html"><![CDATA[<p>前段时间不间断的开发新项目，实际是想得多，写得少，最后落实到代码中，大概也就200多k文件。现在回头看一下，觉得还挺满意的，因为每个新项目会找出些不一样的地方，不求做到最好，但求标新立异，否则岂不是失去了开发的意义，也辜负了“程序猿”这个需要些许创造性的工作。</p>

<p>每次新项目达到一个阶段，能回顾一下，总是极好的。这次细想一下，有什么值得总结的地方，就又回到了“软件配置”这个极庸俗的话题上来了。</p>

<p>在我看来，任何软件都少不了配置，但是在之前的文章中我也提到过，<a href="/blog/2013/09/17/ruan-jian-ji-jian-zhu-yi/">配置是软件的大敌</a>。任何软件配置越复杂，学习成本也就越高，这是一种反人类的趋势，所以这种软件，要么被更新，更简单的软件取代，要么就根本无人问津，消失在软件的海洋中。</p>

<p>当然，配置也可以被广泛的定义，形式是多种多样的，有些还是群众们喜闻乐见的，不能一棒子打死了。下面谨罗列一下我心目中的配置文件类型，和它们的适用范围。</p>

<h2 id="key-value">第一阶段，单纯的key-value</h2>
<p>这应该是最常见的一种配置，也最接近配置文件的本意。所谓人各有所好，软件在部署的过程中会遭遇不同的平台，也会遇到不同的适用情况和环境，这个时候就需要依靠配置文件来告诉软件应该怎样正确的运行。操作系统中的环境变量就是一种最常见的配置，<code>PATH</code>定义了用户需要的可执行文件的搜索范围，<code>SHELL</code>决定了和人交互的shell版本。在web应用中，数据库连接，域名，api签名秘钥等等都应当以配置的形式出现，否则就是给懒惰的开发者增加麻烦。</p>

<p>为什么说是“懒惰的开发者”，应为这些配置其实都可以通过在源代码中通过<code>if-else</code>条件来解决，要是碰到个勤快的开发（也许也是愚蠢的开发），就会把签名秘钥写在代码中，通过<code>if-else</code>来判断哪种环境应该调用哪种签名生成规则。但是在编程界，“懒惰是一种美德”，前面的做法非但徒增开发的难度，也不够灵活，用逼格更高的话来说，就是“不够优雅”。</p>

<p>所以需要用到<code>key-value</code>类型的配置。通常情况下，这种配置文件的出现形式会是一个json文件或是一个xml文件。假如这种配置文件不需要做到跨语言调用的话，跟进一步的做法是直接使用软件可用的脚本语言，通常会于源代码的语言保持一致。像我们写nodejs应用，使用js文件来做配置，就会比用json来的更加灵活。</p>

<h2 id="section">第二阶段，预定义方法</h2>
<p>下面提到的配置类型都有别于狭义的配置文件。比如说某些预先定义好的方法。我们可以在软件中预先定义好一些方法，这些方法我们不知道会不会用到，也不知道什么时候会用到，唯一明确的一点就是，我们知道这些方法能接受哪些参数，并且会得到哪些输出。我们在定义这些方法时，假如能确保他们的参数形式保持一致，那就更好了。这样对于习惯拿来主义的用户或我们自己，就更加的便利了。</p>

<p>具体的例子，比方说rails中的路由就是个这样的例子（从routes.rb文件的位置也可以看出它就是个配置文件），作者给我们定义好了一系列的方法，<code>get</code>，<code>post</code>，最有意思的就是<code>resource</code>。我们知道这些方法需要什么样的参数，能得到什么样的效果，假如我们不用这些配置，那么写上完整的路由控制代码，也能达到一样的目的。但是不需要，因为我们“很懒惰”。</p>

<h2 id="section-1">第三阶段，钩子</h2>
<p>如果你对于软件的使用者有足够的信心或信任，那么完全可以将一些接口留给用户来实现，软件中的钩子就是一个很好的例子，这在很多full-stack的框架中是很常见的，另一个场景是git的hook，在每个命令的前后，git都预留了钩子由用户来实现，这样它的可玩性就高了很多，到了github上，网站把很多常用的钩子打包成一个个模块，用户只需要给需要的模块打上勾就行了，这也可以称为配置的一种形式。</p>

<h2 id="section-2">第四阶段，可编程性</h2>
<p>这已经脱离了配置的范畴了，一些软件提供强大的api，用户通过这些api来拓展软件，甚至集成到软件本身。比如nginx使用lua来作为对单纯配置的拓展，实现了任何你所需要的功能。而github有一个很有意思的项目，叫做<a href="https://github.com/github/hubot">hubot</a>，是一个智能机器人项目，以消息的输入输出作为基本要素，用户可以加上任意的adapter，为hubot增加应答规则。其核心非常简单，但是众人拾柴火焰高，也许日久天长，这种基于规则库的低级智能，真的能发展成影响到每个人生活方方面面的智能管家。</p>

<h2 id="section-3">第五阶段，无配置文件</h2>
<p>从智能的话题延伸出去，既然软件本身需要具有智慧，那么为什么不能领悟它自己的需求，而要由人来给它写好配置？最起码，软件要能记忆曾经执行的过的操作，记录过的配置。</p>

<p>以两个monitor软件为例，’supervisor’是一款老牌的进程监控软件，由python写成，’pm2’是后起之秀，由nodejs写成，但是他们都不局限于监控python或nodejs进程，而可以做到全平台任意进程的监控。</p>

<p>假如初次使用这两款软件，更多的人会习惯于’supervisor’的操作方式，先写好一个配置文件，也许叫做<code>supervisor.conf</code>，定义好有哪些程序需要运行，执行文件的路径，环境变量，等等。然后我们敲下’supervisord start’来让这些进程运行起来，一切看起都很完美。</p>

<p>然后我们开始使用pm2，一开始会惊奇于它没有要求任何配置文件，你找到需要执行的文件，敲下<code>pm2 start app.js</code>，程序就开始执行，然后我们就可以通过<code>start|restart|reload|kill</code>等一系列命令操作这个进程。这个过程没有任何要求编写配置文件的步骤。</p>

<p>这怎么可能？我一开始的反应是这样，然后开始在各个目录中翻找所谓的’默认配置’，发现一无所获，后来我阅读了pm2的<a href="https://github.com/Unitech/pm2">源代码</a>，发现其实所有的配置，都在第一次启动进程的时候被忠实的记录下来。事情本该如此，既然第一次我已经告诉了软件需要的所有参数和变量，为什么有那么多的软件，还需要进行人为的干预来决定需要的参数，这不是一个优秀软件应该具备的素质。</p>

<p>我最近在修改一个在团队内部用了一段时间的部署工具<a href="https://github.com/sailxjx/sneaky">sneaky</a>。一直以来它都工作的很好，唯一的烦恼是在发布一个新项目前需要编写一段配置文件，填上发布的目标地址，端口，必要的时候再加上一些钩子。近期的一次更新已经将原本需要的5到6个配置项缩减到最少1个。下一步，当然是干掉配置文件。我们告诉它，把软件部署到某某服务器，然后到了下次，我们需要干同样的事时，软件已经比我们先知道它要做的事。这才是软件的未来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件极简主义]]></title>
    <link href="http://jingxin.me/blog/blog/2013/09/17/ruan-jian-ji-jian-zhu-yi/"/>
    <updated>2013-09-17T21:03:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2013/09/17/ruan-jian-ji-jian-zhu-yi</id>
    <content type="html"><![CDATA[<p>今天回家的路上，竟然刮起了大风，虽然骑行艰难，但是想想公交中的闷热，倒是觉得凉爽多了。</p>

<p>在路上的时间是无聊的，于是就喜欢胡思乱想，很多自以为很棒的点子其实都是在这种不经意间想到的，办公室里的久坐反而显得效率低下了。回味一下最近做的几个项目，高屋建瓴的想想当初的设计，突然很想写一些关于软件设计的文章。就着饮料和巧克力（来点酒么？），今天就来写写软件极简主义吧。</p>

<p>Google了一圈，也没找到对“软件极简主义”的定义，姑且当做是我的独创吧。一般认为“极简主义”是设计界的一种风潮，但是软件发展至今，好像也渐渐有了这样的趋势，甚至我认为这是未来的必然，我们经常听人说“flexible”这个词，字面上来看就是“灵活的”，但是具体到这个软件是否灵活，就不太好判断了。但是，简单的软件，一定是灵活的。</p>

<h2 id="section">极简主义的的大敌</h2>

<p>软件极简主义的三个大敌：配置文件，冗余的参数，和大量复杂的接口。</p>

<p>很多人热爱配置，迷恋配置，认为越多的配置项意味着软件越强大，适用范围越广，但这是九十年代的事了。实际我们仔细翻翻常用的软件，90%的配置都是多余，没有人明白他是做什么的，也没有人希望去改变他。比方很多软件的configure文件，常常能列出上百个配置项，但是我们真的需要这么多吗？不，我们需要默认的那些值就行了。何谓默认？因为软件的设计者觉得这些是最优化也最有可能被选择的配置，那么既然是最优配置，我们又有什么理由去改变他们？</p>

<p>再说说冗余的参数，linux中有一个非常强大的命令’tar’，从man文件看来他起码有二十来个参数，但是我真的需要这么多参数吗？其实我只要记住压缩是<code>-c</code>，解压是<code>-x</code>就可以了，那么何必为了1%的功能而去加上这99%的参数呢。</p>

<p>最后是复杂的接口，举个栗子，全文搜索引擎solr非常强大，能满足我们对于文档索引的各种需求。但是他使用起来可不简单，原因我想就是因为他那种sql式的查询接口，把一件很单纯的事情搞复杂了。我们来设想一下，需要找出包含某几个关键词的文章，必要的条件是什么？关键词，文档，没了。而文档是存储在服务器的，为什么我们提供了关键词之后，仍需加上各种条件，他才能告诉我们想要的答案呢？我想软件发展到一定的智能，他就应该像一部能说话的百科全书，提问，然后告诉我们答案即可。</p>

<p>凡事都要对比着看，所以我们找点软件来对比一下。</p>

<h2 id="redis--sql">redis 与 sql</h2>

<p>redis很灵巧，所有源代码加起来不满5M，但是他很强大，hash结构能取代我们80%对于sql的需求。他也有配置文件，但是选项很少，而且每一项都有详尽的注释，并且使用默认配置就可以应对大部分的情况。唯一值得诟病的就是他的接口种类繁多，但好在这些接口很有规律可循，你只需了解了redis的基础数据结构，那么跟着官网的文档就很容易搞懂所有接口的用途，而且大部分的接口都只接受3个以内的参数，这可好记多了。我刚接触redis的时候，只花了半个小时就能玩得起来，我想面对sql恐怕没人能这么轻松的掌握吧。</p>

<h2 id="cake--grunt">cake 与 grunt</h2>
<p><a href="https://github.com/jashkenas/coffee-script/blob/master/src/cake.coffee">cake</a>和<a href="https://github.com/gruntjs/grunt">grunt</a>是nodejs中两个管理任务的模块，后者的名声更大一些，前者甚至不能说是一个模块，他只是coffeescript中附带的一个小工具。我曾尝试使用grunt来做任务管理，但是当我看到grunt官网那长长的一段initConfig时，就望而却步了。就像是我希望在墙里敲个钉子，你却给了我一台破城锤。我只不过想要给每个任务起个名字方便我以后调用和查阅而已，所以cake的一行命令足矣。</p>

<h2 id="zmq--rabbitmq">zmq 与 rabbitmq</h2>
<p>zmq是我见过的最具有极简主义风格的软件（组件）。一方面他要面对的任务非常繁杂，在异步通信中所有我们可能遇到的情况，他都为我们考虑到了，但是他又将底层的复杂问题掩盖起来，让我们看到一个光滑的表面，深藏功与名。同样来看看他的同行rabbitmq，关键词：中心服务，多线程，模式单一，最后一个特点，慢！而仅有1.7M的zmq，快是最直观的感觉，而分布式和扩展性则是锦上添花。有人说zmq就像乐高积木，每个人都能搭出他想要的形状，这话一点都不错。</p>

<h2 id="section-1">不是结束的结语</h2>
<p>软件的设计日新月异，将来肯定会接触到更多优秀的软件，也许哪天我想法变了，也许哪天遇到了更神奇的方案，可能我会补充在这里。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 mac 中安装 wine]]></title>
    <link href="http://jingxin.me/blog/blog/2013/04/28/zai-mac-zhong-an-zhuang-wine/"/>
    <updated>2013-04-28T12:39:00+08:00</updated>
    <id>http://jingxin.me/blog/blog/2013/04/28/zai-mac-zhong-an-zhuang-wine</id>
    <content type="html"><![CDATA[<p>公司用奇葩的imo，由于没有mac版本，只能用web版。最近imo web版升级之后老是不稳定，又不想装一个笨重的windows虚拟机，于是曲线救国，找找mac上的<a href="http://www.winehq.org/">wine</a>该怎么用。</p>

<p>在mac上安装wine需要备齐三样神器：</p>

<ul>
  <li><a href="http://xquartz.macosforge.org/landing/">xquartz</a>，在mac上提供对x11的支持，由于mountain lion之后不在预装x11，所以这个需要手动下载。</li>
  <li><a href="http://winebottler.kronenberg.org/">winebottler</a>，这个包里两个软件，wine和winebottler，winebottler算是一个wine的管理器，里面预设了一些各种wine应用下需要的类库模板。</li>
</ul>

<p>安装顺序是xquartz-&gt;winebottler-&gt;wine，后面两个从包中直接拖到Application中就行了。安装完后需要先启动xquartz，然后启动wine之后在上面的panel中会有一个酒杯的图标，里面可以打开资源管理器等等，第一次打开时会在用户目录里生成一个Wine Files文件夹，这个就是winebottler中所谓的prefix，里面模拟了一套windows下面的环境。可以通过在winebottler中安装不同的prefix来切换不同应用环境。不过每个prefix都是一个完整的windows环境，非常占空间，没有必要的话，用默认的就行。然后增加类库可以点击wine图标，选择wine trick来安装，还是比较方便的。</p>

<p>youtube上有个<a href="http://www.youtube.com/watch?v=m0BBkISOcEA">视频</a>介绍了如何在mac上安装wine，按照上面说的一步步来，基本不会出错。</p>

<p>但是wine的种种缺点还是很明显的，一个是字体界面都很丑，在mac下更甚，即使想各种办法优化也无济于事。第二个就是很多库都没有，这是最致命的，imo最后还是没有安装成功，按照错误提示装了.net和vcrun2008等等之后还是不能正常启动，也是预料之中的事。wine还是只能算是一个玩具，给喜欢折腾的geek玩玩而已，真要用来跑wow之类的应用，那肯定是闲的蛋疼了。</p>
]]></content>
  </entry>
  
</feed>
