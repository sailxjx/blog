<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | CodeBean]]></title>
  <link href="http://sailxjx.github.io/blog/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://sailxjx.github.io/blog/"/>
  <updated>2013-07-12T16:36:02+08:00</updated>
  <id>http://sailxjx.github.io/blog/</id>
  <author>
    <name><![CDATA[tristan]]></name>
    <email><![CDATA[sailxjx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[蛋疼的刷屏算法问题]]></title>
    <link href="http://sailxjx.github.io/blog/blog/2013/04/15/dan-teng-de-shua-ping-suan-fa-wen-ti/"/>
    <updated>2013-04-15T11:15:00+08:00</updated>
    <id>http://sailxjx.github.io/blog/blog/2013/04/15/dan-teng-de-shua-ping-suan-fa-wen-ti</id>
    <content type="html"><![CDATA[<p>最近在v2ex的看到一道有趣而蛋疼的<a href="http://www.v2ex.com/t/65703">求助帖</a>，搜了一下，原题刊登在神人matrix67的<a href="http://www.matrix67.com/blog/archives/4092">博客</a>上。先看看题目：</p>

<p>你有一个特殊的键盘，只有四个键：</p>

<ul>
  <li><code>a</code>, 输入字符a</li>
  <li><code>ctrl+a</code>, 全选</li>
  <li><code>ctrl+c</code>, 复制</li>
  <li><code>ctrl+v</code>, 粘贴</li>
</ul>

<p>还需要说明一下的是，上面的<code>ctrl+x</code>都只算一个按键，而且全选之后的第一次复制粘贴，是不会增加字符长度的，（也就是只覆盖了已有字符，这个在现实生活中应该有体会）。</p>

<p>这是一个不着边际的题目，乍看非常简单，但是细想一下脑子就打结了。牛逼的matrix67大神，用两个公式，三下五除二就搞定了这个问题：</p>

<ul>
  <li>f(n) = f(n-1) + 1</li>
  <li>f(n) = f(n/k) + k + 2</li>
</ul>

<p>然后在以上两种情况下取最小值，再用递推法，递推的层数就是所走的步数了。</p>

<p>具体的计算情况在博客里有介绍，这里不再赘述，我感兴趣的是上面这两个公式，是否能涵盖所有情况，已经怎么推导出这两个公式，这才是真正神奇的地方，而且matrix67也没有给出详细的推导过程。</p>

<h2 id="section">倒推法</h2>

<p>要推导出递推公式，顺着题目的意思思考是不行的（事实上，我认为所有最大值n不确定的问题，都需要逆向思维，否则很容易就陷入无底深渊了）。我们可以看到问题结束的几种情况：</p>

<ul>
  <li>最后一个按键是<code>a</code>，则这种情况最简单，f(n) = f(n) + 1。</li>
  <li>最后一个按键是<code>cv</code>，则这种情况下，最后第二个按键只能是<code>cc</code>或者<code>cv</code>，最后第三个按键只能是<code>ca</code>，<code>cc</code>或<code>cv</code>，整个按键流程可以归纳为<code>x-&gt;ca-&gt;cc-&gt;cv...cv-&gt;y</code>，其中<code>x</code>是在全选前的字符数，<code>y</code>表示总字符数，那么设按键<code>cv</code>的次数为<code>k</code>，全选复制阶段的按键次数就是<code>k+2</code>，而且值得一提的是，这个<code>k</code>必须大于或等于2，否则复制就是多余的。然后<code>y</code>是由<code>x</code>复制<code>k</code>次而来，所以就不难推导出公式f(n) = f(n/k) + k + 2，其中<code>k</code>为大于等于2的<code>n</code>的约数。</li>
</ul>

<p>由此，两个公式都被推导出来了，但这就结束了吗？是否所有的情况都涵盖到了？根据计算结果可以得出f(n)并非单调函数，也就是说f(n-2)有可能小于f(n-1)，那么会不会有f(n-2)到f(n)比f(n-1)到f(n)快的情况呢，这个还需要证明一下：</p>

<p><code>
f(n) = f(n-1) + 1 &lt;=&gt; f(n-2) + 2
</code></p>

<p>f(n-2)到f(n-1)最快的路径应该就是<code>f(n-2) + 1</code>了吧，所以不可能是这种情况，那么还剩下一种情况：</p>

<p><code>
f(n) = f(n-2) + k + 2 &lt;=&gt; f(n-1) + 1  # n = (n-2) * k
</code></p>

<p>那么这里又回到了之前预设的第二种情况，其本身就是需要参与递归的比较的，所以这种情况也是已涵盖了的。</p>

<p>这样看了是我多虑了，下面要做的就是将这个递归程序写出来。</p>

<h2 id="section-1">实现</h2>

<p>从程序的角度看，其实算法中还有一些值得优化的地方：</p>

<ul>
  <li>1到100之间(这个范围甚至可以再扩大些)的素数的最小步数可以事先计算出来作为常数数组保存，这些数字是递归的终点，预处理可以让递归的最后一步变成O(1)，而不是O(n)</li>
  <li>上面提到的，k是从2到n，但事实上范围可以更小。在<code>f(n) = f(n/k) + k +2</code>中，随着n的增加，步数的增加并不是线性的，步数的增速的是逐渐放缓的，但是<code>k</code>对于步数的增长变化却是线性的。对公式求导，<code>f(n/k)' &lt; 1</code>而<code>k' = 1</code>，所以我们有理由相信，<code>k</code>的范围只需要从2到√n（包含）就可以了。</li>
</ul>

<p>实际上，第二点对于代码的效率优化是显而易见的，差不多是省了50%的时间。而第一点对于效率的提升是相当惊人的，以n=200为例，有素数索引和没有素数索引的情况下执行时间如下：</p>

<ul>
  <li>4.05s user 0.06s system 99% cpu 4.129 total  # no index</li>
  <li>0.05s user 0.01s system 92% cpu 0.067 total  # have index</li>
</ul>

<p>提升了整整60倍，而且随着n的提高，这个差距会更加明显，100以内的索引可以涵盖n等于0到10000的情况，当n大于10000时，提升这个素数索引即可，代码中提供了很方便的实现索引生成的方法。</p>

<h2 id="section-2">代码</h2>

<p>我做了一个ruby版本的demo，放在<a href="https://gist.github.com/sailxjx/5388648">gist</a>上。</p>

<h2 id="section-3">扩展</h2>

<p>这个命题其实还可以扩展，比方说还是这四个键，但是<code>ctrl+a</code>, <code>ctrl+c</code>, <code>ctrl+v</code>均算作两次按键，那么情况又复杂了，因为不光增加了按键的不确定性，而且复制时候增加了一种情况，在不松开<code>ctrl</code>的情况下，可以多次按<code>v</code>来实现复制。<del>这个扩展命题只有等将来有时间再思考了。</del></p>

<p>这个命题仍然套用倒推法，只需要对第二个公式做一些修改即可：</p>

<ul>
  <li>f(n) = f(n-1) + 1</li>
  <li>f(n) = f(n/k) + k + 5</li>
</ul>

<p>下面的事情就跟之前一模一样啦，这里也有一个<a href="https://gist.github.com/sailxjx/5393701">demo版本</a>，在不算两次按键的时候，最少在n=9时出现了复制，算作两次按键的时候，到n=15才出现复制。</p>

<h2 id="section-4">来源及参考资料</h2>
<ul>
  <li><a href="http://www.matrix67.com/blog/archives/4092">matrix67的蛋疼问题</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态规划求解数组最大差值]]></title>
    <link href="http://sailxjx.github.io/blog/blog/2013/04/08/dong-tai-gui-hua-qiu-jie-shu-zu-zui-da-chai-zhi/"/>
    <updated>2013-04-08T12:47:00+08:00</updated>
    <id>http://sailxjx.github.io/blog/blog/2013/04/08/dong-tai-gui-hua-qiu-jie-shu-zu-zui-da-chai-zhi</id>
    <content type="html"><![CDATA[<p>前几天碰到一道有趣的面试题，见微知著，由此记录一下一些新的启发和发现。</p>

<p>题目很简单，给一个数组，其中有n个数字，求后面的数与前面的数的差值，将最大差值的两个数找出来。映射到生活中，就是一个股票何时买入何时卖出能达到最大收益的情况（前提是能预知未来的所有报价）。</p>

<p>一个测试用例是下面这样：</p>

<ul>
  <li>输入：[3,10,11,9,1,2,-1,10,7]</li>
  <li>输出：[-1, 10]</li>
</ul>

<p>这个题目乍看上去相当的简单，我第一个想到的就是，既然要求最大差值，那可以先将每个值与的数之间的差值求出来，然后再进行一次排序，结果不就出来了嘛。这样需要用到两次循环，代码可以参考下面。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">stepIn</span><span class="p">(</span><span class="n">dataInput</span><span class="p">)</span>
</span><span class='line'>  <span class="n">dataLen</span> <span class="o">=</span> <span class="n">dataInput</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'>  <span class="n">diff</span> <span class="o">=</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="n">dataResule</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="err">…</span><span class="n">dataLen</span><span class="o">-</span><span class="mi">1</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="err">…</span><span class="n">dataLen</span>
</span><span class='line'>      <span class="n">diff2</span> <span class="o">=</span> <span class="n">dataInput</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">-</span> <span class="n">dataInput</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">diff</span> <span class="o">==</span> <span class="kp">nil</span> <span class="ow">or</span> <span class="n">diff</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">diff2</span>
</span><span class='line'>        <span class="n">diff</span> <span class="o">=</span> <span class="n">diff2</span>
</span><span class='line'>        <span class="n">dataResule</span><span class="o">[</span><span class="err">”</span><span class="c1">#{i},#{n}”] = diff</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">rIdxs</span> <span class="o">=</span> <span class="n">dataResule</span><span class="o">.</span><span class="n">sort_by</span> <span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="o">|</span> <span class="o">-</span><span class="n">v</span><span class="p">}</span> <span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">].</span><span class="n">split</span> <span class="err">‘</span><span class="p">,</span><span class="err">’</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">[</span><span class="n">dataInput</span><span class="o">[</span><span class="n">rIdxs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">to_i</span><span class="o">]</span><span class="p">,</span> <span class="n">dataInput</span><span class="o">[</span><span class="n">rIdxs</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="n">to_i</span><span class="o">]]</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上面的代码已经经过了优化，在每次循环后，保留了之前计算的差值的结果，下面的循环中小于这个差值的索引值就被抛弃了，这样的一个好处是可以减少最后sort时花费的时间。假如保留所有两数之间的差值，假设使用冒泡排序，输入数组长度是m，排序算法复杂度是O(n<sup>2</sup>)，而这个n会达到(m+1)*m/2，所以总的算法复杂度就成了O(n<sup>4</sup>)。而在循环中预处理之后，最后参与排序的元素个数最大不会超过m，总的时间复杂度还是O(n<sup>2</sup>)。其实这只是针对最后的sort而言，而这个程序真正的耗时在上面的嵌套循环，这里的复杂度不管有没有优化，其实都是一样的O(n<sup>2</sup>)，下面sort的消费可以忽略不计。</p>

<p>这是一种比较直观的解法了，事实证明，没有经过斟酌的想法都是不完善的（事实也证明，很多灵光一闪的想法都很很靠谱滴，不过在这里不适用(^_^)。经人启发，才知道有一种解法，只需要一次循环，时间复杂度是O(n)。</p>

<p>这个叫做动态规划的算法说的太笼统，网上的解释也实在是太理论，我们联系实际，就以上面的题目为例。</p>

<p>动态规划的思想通常可以分成下面几部：</p>

<ol>
  <li>给问题分阶段</li>
  <li>确定每个阶段的状态</li>
  <li>确定相邻阶段的之间的递推关系（也就是找出从前一个阶段转化到后一个阶段的条件）</li>
</ol>

<p>上面的例子很容易可以分出三个阶段</p>

<ol>
  <li>开始阶段，将数组中开头的两个元素作为最大，最小值记录在结果数组中，[3,10]</li>
  <li>过程阶段，将后面的数与前面的数比较，比如将11与10比较，并将符合条件的值替换结果数组</li>
  <li>结束阶段，当游标抵达数组最后一个元素时，跳出循环。</li>
</ol>

<p>而这几个状态之间的转移条件在上面已有了说明，主要在第二个阶段，哪些条件能决定替换结果数组，这些条件称为决策</p>

<ol>
  <li>游标所指的数大于结果数组中的最大值，比如后面有11，那么结果数组就变成[3,11]</li>
  <li>游标所指的数小于结果数组中的最小值，那么它就有可能在后面替换结果数组中的最小值，例如后面出现了1，这个时候不能立刻替换掉3，需要找个临时变量将1保存下来。</li>
  <li>游标所指的数与临时最小值之差大于结果数组中两数字之差。这个条件应该优先于决策2和决策1，一旦这个决策生效，将同时替换结果数组中的最大最小值，决策1和决策2在这个时候应该不生效。例如后面出现了12，那么结果数组就应该变成[1,12]。假如这个时候决策1优先生效，那么结果数组会变成[3,12]，而临时变量1将永远没有上位之日了。</li>
</ol>

<p>有了上面的阶段和决策之后，代码就很容易实现了</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">stepIn</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
</span><span class='line'>  <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># minimal index</span>
</span><span class='line'>  <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># maximal index</span>
</span><span class='line'>  <span class="n">differ</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># max differ</span>
</span><span class='line'>  <span class="n">minTmp</span> <span class="o">=</span> <span class="kp">nil</span>  <span class="c1"># temp minimal index</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="err">…</span><span class="n">list</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">minTmp</span> <span class="o">!=</span> <span class="kp">nil</span> <span class="ow">and</span> <span class="n">list</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">list</span><span class="o">[</span><span class="n">minTmp</span><span class="o">]</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">differ</span>  <span class="c1"># if current index minus temp minimal index is bigger than differ, replace it</span>
</span><span class='line'>      <span class="n">differ</span> <span class="o">=</span> <span class="n">list</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">list</span><span class="o">[</span><span class="n">minTmp</span><span class="o">]</span>  <span class="c1"># new differ</span>
</span><span class='line'>      <span class="n">min</span> <span class="o">=</span> <span class="n">minTmp</span>  <span class="c1"># new minimal index</span>
</span><span class='line'>      <span class="n">max</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># new maximal index</span>
</span><span class='line'>    <span class="k">elsif</span> <span class="n">list</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">list</span><span class="o">[</span><span class="n">max</span><span class="o">]</span>  <span class="c1"># replace the maximal index</span>
</span><span class='line'>      <span class="n">max</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># new maximal index</span>
</span><span class='line'>      <span class="n">differ</span> <span class="o">=</span> <span class="n">list</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">list</span><span class="o">[</span><span class="n">min</span><span class="o">]</span>  <span class="c1"># new differ</span>
</span><span class='line'>    <span class="k">elsif</span> <span class="n">list</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">list</span><span class="o">[</span><span class="n">min</span><span class="o">]</span> <span class="ow">and</span> <span class="p">(</span> <span class="n">minTmp</span> <span class="o">==</span> <span class="kp">nil</span> <span class="ow">or</span> <span class="n">list</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">list</span><span class="o">[</span><span class="n">minTmp</span><span class="o">]</span> <span class="p">)</span>  <span class="c1"># replace the temp minimal index</span>
</span><span class='line'>      <span class="n">minTmp</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># change temp minimal index</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="k">next</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">[</span><span class="n">list</span><span class="o">[</span><span class="n">min</span><span class="o">]</span><span class="p">,</span> <span class="n">list</span><span class="o">[</span><span class="n">max</span><span class="o">]]</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这种解法可能读起来需要稍微绕点弯，而且隐含问题，我在第一次写这段代码的时候就将决策3和决策1的顺序搞反了，但是几个测试脚本都顺利通过了，这就是一个“不明显的bug”，往往比“明显的bug”还要致命，因为根本无迹可查。</p>

<p>不过，相对于性能的提高，牺牲一点可读性还是值得的。在上面的例子中不太明显，但是当我将输入数组的长度变成1000甚至5000时，两种算法的反差是相当惊人的。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>bash<span class="nv">$ </span>ruby benchmark.rb 1000
</span><span class='line'>dysort: 0.000435
</span><span class='line'>trsort: 0.13827
</span><span class='line'>bash<span class="nv">$ </span>ruby benchmark.rb 5000
</span><span class='line'>dysort: 0.002027
</span><span class='line'>trsort: 3.28997
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上面是分别在1000和5000的数组长度下运行的结果，可以看出使用第二种算法的时间增长基本是线性的，而使用第一种算法的耗时则会指数级的增长。两种算法横向比较更是高下立分，本来想画图来表示，结果发现差距太大，使用第二种算法的时间柱在图上基本看不到了，于是作罢。</p>
]]></content>
  </entry>
  
</feed>
